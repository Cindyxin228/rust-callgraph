Target name: idna
The code is Ok(
    "{\n    if !transitional {\n        return Cow::Borrowed(domain);\n    }\n    let mut chars = domain.chars();\n    loop {\n        let prev = chars.clone();\n        if let Some(c) = chars.next() {\n            match c {\n                'ß' | 'ẞ' | 'ς' | '\\u{200C}' | '\\u{200D}' => {\n                    let mut s = String::with_capacity(domain.len());\n                    let tail = prev.as_str();\n                    let head = &domain[..domain.len() - tail.len()];\n                    s.push_str(head);\n                    for c in tail.chars() {\n                        match c {\n                            'ß' | 'ẞ' => {\n                                s.push_str(\"ss\");\n                            }\n                            'ς' => {\n                                s.push('σ');\n                            }\n                            '\\u{200C}' | '\\u{200D}' => {}\n                            _ => {\n                                s.push(c);\n                            }\n                        }\n                    }\n                    return Cow::Owned(s);\n                }\n                _ => {}\n            }\n        } else {\n            break;\n        }\n    }\n    Cow::Borrowed(domain)\n}",
)
The code is Ok(
    "if !transitional {\n        return Cow::Borrowed(domain);\n    }",
)
The code is Ok(
    "!transitional",
)
The code is Ok(
    "transitional",
)
The code is Ok(
    "return Cow::Borrowed(domain)",
)
The code is Ok(
    "Cow::Borrowed(domain)",
)
resolved new call Call { call_expr: HirId(DefId(0:15 ~ idna[bc6b]::deprecated::map_transitional).11), call_expr_span: idna/src/deprecated.rs:27:16: 27:37 (#0), caller: Some(DefId(0:15 ~ idna[bc6b]::deprecated::map_transitional)), caller_span: None, callee: DefId(5:791 ~ alloc[186e]::borrow::Cow::Borrowed::{constructor#0}), callee_span: idna/src/deprecated.rs:27:16: 27:29 (#0), callee_path: "std::borrow::Cow::Borrowed", constraint_depth: 1 }
The code is Ok(
    "Cow::Borrowed",
)
The code is Ok(
    "domain",
)
The code is Ok(
    "domain.chars()",
)
The code is Ok(
    "domain",
)
The code is Ok(
    "loop {\n        let prev = chars.clone();\n        if let Some(c) = chars.next() {\n            match c {\n                'ß' | 'ẞ' | 'ς' | '\\u{200C}' | '\\u{200D}' => {\n                    let mut s = String::with_capacity(domain.len());\n                    let tail = prev.as_str();\n                    let head = &domain[..domain.len() - tail.len()];\n                    s.push_str(head);\n                    for c in tail.chars() {\n                        match c {\n                            'ß' | 'ẞ' => {\n                                s.push_str(\"ss\");\n                            }\n                            'ς' => {\n                                s.push('σ');\n                            }\n                            '\\u{200C}' | '\\u{200D}' => {}\n                            _ => {\n                                s.push(c);\n                            }\n                        }\n                    }\n                    return Cow::Owned(s);\n                }\n                _ => {}\n            }\n        } else {\n            break;\n        }\n    }",
)
The code is Ok(
    "chars.clone()",
)
The code is Ok(
    "chars",
)
The code is Ok(
    "if let Some(c) = chars.next() {\n            match c {\n                'ß' | 'ẞ' | 'ς' | '\\u{200C}' | '\\u{200D}' => {\n                    let mut s = String::with_capacity(domain.len());\n                    let tail = prev.as_str();\n                    let head = &domain[..domain.len() - tail.len()];\n                    s.push_str(head);\n                    for c in tail.chars() {\n                        match c {\n                            'ß' | 'ẞ' => {\n                                s.push_str(\"ss\");\n                            }\n                            'ς' => {\n                                s.push('σ');\n                            }\n                            '\\u{200C}' | '\\u{200D}' => {}\n                            _ => {\n                                s.push(c);\n                            }\n                        }\n                    }\n                    return Cow::Owned(s);\n                }\n                _ => {}\n            }\n        } else {\n            break;\n        }",
)
The code is Ok(
    "chars.next()",
)
The code is Ok(
    "chars",
)
The code is Ok(
    "match c {\n                'ß' | 'ẞ' | 'ς' | '\\u{200C}' | '\\u{200D}' => {\n                    let mut s = String::with_capacity(domain.len());\n                    let tail = prev.as_str();\n                    let head = &domain[..domain.len() - tail.len()];\n                    s.push_str(head);\n                    for c in tail.chars() {\n                        match c {\n                            'ß' | 'ẞ' => {\n                                s.push_str(\"ss\");\n                            }\n                            'ς' => {\n                                s.push('σ');\n                            }\n                            '\\u{200C}' | '\\u{200D}' => {}\n                            _ => {\n                                s.push(c);\n                            }\n                        }\n                    }\n                    return Cow::Owned(s);\n                }\n                _ => {}\n            }",
)
The code is Ok(
    "c",
)
The code is Ok(
    "'ß'",
)
The code is Ok(
    "'ẞ'",
)
The code is Ok(
    "'ς'",
)
The code is Ok(
    "'\\u{200C}'",
)
The code is Ok(
    "'\\u{200D}'",
)
The code is Ok(
    "{\n                    let mut s = String::with_capacity(domain.len());\n                    let tail = prev.as_str();\n                    let head = &domain[..domain.len() - tail.len()];\n                    s.push_str(head);\n                    for c in tail.chars() {\n                        match c {\n                            'ß' | 'ẞ' => {\n                                s.push_str(\"ss\");\n                            }\n                            'ς' => {\n                                s.push('σ');\n                            }\n                            '\\u{200C}' | '\\u{200D}' => {}\n                            _ => {\n                                s.push(c);\n                            }\n                        }\n                    }\n                    return Cow::Owned(s);\n                }",
)
The code is Ok(
    "String::with_capacity(domain.len())",
)
The code is Ok(
    "String::with_capacity",
)
The code is Ok(
    "domain.len()",
)
The code is Ok(
    "domain",
)
The code is Ok(
    "prev.as_str()",
)
The code is Ok(
    "prev",
)
The code is Ok(
    "&domain[..domain.len() - tail.len()]",
)
The code is Ok(
    "domain[..domain.len() - tail.len()]",
)
The code is Ok(
    "domain",
)
The code is Ok(
    "..domain.len() - tail.len()",
)
The code is Ok(
    "domain.len() - tail.len()",
)
The code is Ok(
    "domain.len()",
)
The code is Ok(
    "domain",
)
The code is Ok(
    "tail.len()",
)
The code is Ok(
    "tail",
)
The code is Ok(
    "s.push_str(head)",
)
The code is Ok(
    "s",
)
The code is Ok(
    "head",
)
The code is Ok(
    "for c in tail.chars() {\n                        match c {\n                            'ß' | 'ẞ' => {\n                                s.push_str(\"ss\");\n                            }\n                            'ς' => {\n                                s.push('σ');\n                            }\n                            '\\u{200C}' | '\\u{200D}' => {}\n                            _ => {\n                                s.push(c);\n                            }\n                        }\n                    }",
)
The code is Ok(
    "for c in tail.chars() {\n                        match c {\n                            'ß' | 'ẞ' => {\n                                s.push_str(\"ss\");\n                            }\n                            'ς' => {\n                                s.push('σ');\n                            }\n                            '\\u{200C}' | '\\u{200D}' => {}\n                            _ => {\n                                s.push(c);\n                            }\n                        }\n                    }",
)
into Match call
The code is Ok(
    "tail.chars()",
)
LangItem path: idna/src/deprecated.rs:39:30: 39:42 (#177)
The code is Ok(
    "tail.chars()",
)
The code is Ok(
    "tail.chars()",
)
The code is Ok(
    "tail",
)
The code is Ok(
    "for c in tail.chars() {\n                        match c {\n                            'ß' | 'ẞ' => {\n                                s.push_str(\"ss\");\n                            }\n                            'ς' => {\n                                s.push('σ');\n                            }\n                            '\\u{200C}' | '\\u{200D}' => {}\n                            _ => {\n                                s.push(c);\n                            }\n                        }\n                    }",
)
The code is Ok(
    "tail.chars()",
)
into Match call
is inner Match
The code is Ok(
    "tail.chars()",
)
LangItem path: idna/src/deprecated.rs:39:30: 39:42 (#177)
The code is Ok(
    "tail.chars()",
)
The code is Ok(
    "tail.chars()",
)
The code is Ok(
    "tail.chars()",
)
The code is Ok(
    "for c in tail.chars() {\n                        match c {\n                            'ß' | 'ẞ' => {\n                                s.push_str(\"ss\");\n                            }\n                            'ς' => {\n                                s.push('σ');\n                            }\n                            '\\u{200C}' | '\\u{200D}' => {}\n                            _ => {\n                                s.push(c);\n                            }\n                        }\n                    }",
)
The code is Ok(
    "{\n                        match c {\n                            'ß' | 'ẞ' => {\n                                s.push_str(\"ss\");\n                            }\n                            'ς' => {\n                                s.push('σ');\n                            }\n                            '\\u{200C}' | '\\u{200D}' => {}\n                            _ => {\n                                s.push(c);\n                            }\n                        }\n                    }",
)
The code is Ok(
    "match c {\n                            'ß' | 'ẞ' => {\n                                s.push_str(\"ss\");\n                            }\n                            'ς' => {\n                                s.push('σ');\n                            }\n                            '\\u{200C}' | '\\u{200D}' => {}\n                            _ => {\n                                s.push(c);\n                            }\n                        }",
)
The code is Ok(
    "c",
)
The code is Ok(
    "'ß'",
)
The code is Ok(
    "'ẞ'",
)
The code is Ok(
    "{\n                                s.push_str(\"ss\");\n                            }",
)
The code is Ok(
    "s.push_str(\"ss\")",
)
The code is Ok(
    "s",
)
The code is Ok(
    "\"ss\"",
)
The code is Ok(
    "'ς'",
)
The code is Ok(
    "{\n                                s.push('σ');\n                            }",
)
The code is Ok(
    "s.push('σ')",
)
The code is Ok(
    "s",
)
The code is Ok(
    "'σ'",
)
The code is Ok(
    "'\\u{200C}'",
)
The code is Ok(
    "'\\u{200D}'",
)
The code is Ok(
    "{}",
)
The code is Ok(
    "{\n                                s.push(c);\n                            }",
)
The code is Ok(
    "s.push(c)",
)
The code is Ok(
    "s",
)
The code is Ok(
    "c",
)
The code is Ok(
    "return Cow::Owned(s)",
)
The code is Ok(
    "Cow::Owned(s)",
)
resolved new call Call { call_expr: HirId(DefId(0:15 ~ idna[bc6b]::deprecated::map_transitional).182), call_expr_span: idna/src/deprecated.rs:53:28: 53:41 (#0), caller: Some(DefId(0:15 ~ idna[bc6b]::deprecated::map_transitional)), caller_span: None, callee: DefId(5:794 ~ alloc[186e]::borrow::Cow::Owned::{constructor#0}), callee_span: idna/src/deprecated.rs:53:28: 53:38 (#0), callee_path: "std::borrow::Cow::Owned", constraint_depth: 2 }
The code is Ok(
    "Cow::Owned",
)
The code is Ok(
    "s",
)
The code is Ok(
    "{}",
)
The code is Ok(
    "break",
)
The code is Ok(
    "Cow::Borrowed(domain)",
)
resolved new call Call { call_expr: HirId(DefId(0:15 ~ idna[bc6b]::deprecated::map_transitional).202), call_expr_span: idna/src/deprecated.rs:61:5: 61:26 (#0), caller: Some(DefId(0:15 ~ idna[bc6b]::deprecated::map_transitional)), caller_span: None, callee: DefId(5:791 ~ alloc[186e]::borrow::Cow::Borrowed::{constructor#0}), callee_span: idna/src/deprecated.rs:61:5: 61:18 (#0), callee_path: "std::borrow::Cow::Borrowed", constraint_depth: 0 }
The code is Ok(
    "Cow::Borrowed",
)
The code is Ok(
    "domain",
)
The code is Ok(
    "36",
)
The code is Ok(
    "1",
)
The code is Ok(
    "26",
)
The code is Ok(
    "38",
)
The code is Ok(
    "700",
)
The code is Ok(
    "72",
)
The code is Ok(
    "0x80",
)
The code is Ok(
    "{\n    delta /= if first_time { DAMP } else { 2 };\n    delta += delta / num_points;\n    let mut k = 0;\n    while delta > ((BASE - T_MIN) * T_MAX) / 2 {\n        delta /= BASE - T_MIN;\n        k += BASE;\n    }\n    k + (((BASE - T_MIN + 1) * delta) / (delta + SKEW))\n}",
)
The code is Ok(
    "delta /= if first_time { DAMP } else { 2 }",
)
The code is Ok(
    "if first_time { DAMP } else { 2 }",
)
The code is Ok(
    "first_time",
)
The code is Ok(
    "DAMP",
)
The code is Ok(
    "2",
)
The code is Ok(
    "delta",
)
The code is Ok(
    "delta += delta / num_points",
)
The code is Ok(
    "delta / num_points",
)
The code is Ok(
    "delta",
)
The code is Ok(
    "num_points",
)
The code is Ok(
    "delta",
)
The code is Ok(
    "0",
)
The code is Ok(
    "while delta > ((BASE - T_MIN) * T_MAX) / 2 {\n        delta /= BASE - T_MIN;\n        k += BASE;\n    }",
)
The code is Ok(
    "while delta > ((BASE - T_MIN) * T_MAX) / 2 {\n        delta /= BASE - T_MIN;\n        k += BASE;\n    }",
)
The code is Ok(
    "delta > ((BASE - T_MIN) * T_MAX) / 2",
)
The code is Ok(
    "delta",
)
The code is Ok(
    "((BASE - T_MIN) * T_MAX) / 2",
)
The code is Ok(
    "((BASE - T_MIN) * T_MAX)",
)
The code is Ok(
    "(BASE - T_MIN)",
)
The code is Ok(
    "BASE",
)
The code is Ok(
    "T_MIN",
)
The code is Ok(
    "T_MAX",
)
The code is Ok(
    "2",
)
The code is Ok(
    "delta /= BASE - T_MIN",
)
The code is Ok(
    "BASE - T_MIN",
)
The code is Ok(
    "BASE",
)
The code is Ok(
    "T_MIN",
)
The code is Ok(
    "delta",
)
The code is Ok(
    "k += BASE",
)
The code is Ok(
    "BASE",
)
The code is Ok(
    "k",
)
The code is Ok(
    "while delta > ((BASE - T_MIN) * T_MAX) / 2 {\n        delta /= BASE - T_MIN;\n        k += BASE;\n    }",
)
The code is Ok(
    "k + (((BASE - T_MIN + 1) * delta) / (delta + SKEW))",
)
The code is Ok(
    "k",
)
The code is Ok(
    "(((BASE - T_MIN + 1) * delta) / (delta + SKEW))",
)
The code is Ok(
    "((BASE - T_MIN + 1) * delta)",
)
The code is Ok(
    "(BASE - T_MIN + 1)",
)
The code is Ok(
    "BASE - T_MIN",
)
The code is Ok(
    "BASE",
)
The code is Ok(
    "T_MIN",
)
The code is Ok(
    "1",
)
The code is Ok(
    "delta",
)
The code is Ok(
    "(delta + SKEW)",
)
The code is Ok(
    "delta",
)
The code is Ok(
    "SKEW",
)
The code is Ok(
    "{\n    Some(\n        Decoder::default()\n            .decode::<u8, ExternalCaller>(input.as_bytes())\n            .ok()?\n            .collect(),\n    )\n}",
)
The code is Ok(
    "Some(\n        Decoder::default()\n            .decode::<u8, ExternalCaller>(input.as_bytes())\n            .ok()?\n            .collect(),\n    )",
)
resolved new call Call { call_expr: HirId(DefId(0:50 ~ idna[bc6b]::punycode::decode_to_string).3), call_expr_span: idna/src/punycode.rs:49:5: 54:6 (#0), caller: Some(DefId(0:50 ~ idna[bc6b]::punycode::decode_to_string)), caller_span: None, callee: DefId(1:45302 ~ core[f118]::option::Option::Some::{constructor#0}), callee_span: idna/src/punycode.rs:49:5: 49:9 (#0), callee_path: "core::prelude::v1::Some", constraint_depth: 0 }
The code is Ok(
    "Some",
)
The code is Ok(
    "Decoder::default()\n            .decode::<u8, ExternalCaller>(input.as_bytes())\n            .ok()?\n            .collect()",
)
The code is Ok(
    "Decoder::default()\n            .decode::<u8, ExternalCaller>(input.as_bytes())\n            .ok()?",
)
into Match call
The code is Ok(
    "Decoder::default()\n            .decode::<u8, ExternalCaller>(input.as_bytes())\n            .ok()?",
)
LangItem path: idna/src/punycode.rs:50:9: 52:19 (#187)
The code is Ok(
    "Decoder::default()\n            .decode::<u8, ExternalCaller>(input.as_bytes())\n            .ok()?",
)
The code is Ok(
    "Decoder::default()\n            .decode::<u8, ExternalCaller>(input.as_bytes())\n            .ok()",
)
The code is Ok(
    "Decoder::default()\n            .decode::<u8, ExternalCaller>(input.as_bytes())",
)
The code is Ok(
    "Decoder::default()",
)
The code is Ok(
    "Decoder::default",
)
The code is Ok(
    "input.as_bytes()",
)
The code is Ok(
    "input",
)
The code is Ok(
    "?",
)
The code is Ok(
    "Decoder::default()\n            .decode::<u8, ExternalCaller>(input.as_bytes())\n            .ok()?",
)
LangItem path: idna/src/punycode.rs:52:18: 52:19 (#188)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "Decoder::default()\n            .decode::<u8, ExternalCaller>(input.as_bytes())\n            .ok()?",
)
The code is Ok(
    "{\n    Some(\n        Decoder::default()\n            .decode::<u8, ExternalCaller>(input.as_bytes())\n            .ok()?\n            .collect(),\n    )\n}",
)
The code is Ok(
    "Some(\n        Decoder::default()\n            .decode::<u8, ExternalCaller>(input.as_bytes())\n            .ok()?\n            .collect(),\n    )",
)
resolved new call Call { call_expr: HirId(DefId(0:51 ~ idna[bc6b]::punycode::decode).3), call_expr_span: idna/src/punycode.rs:63:5: 68:6 (#0), caller: Some(DefId(0:51 ~ idna[bc6b]::punycode::decode)), caller_span: None, callee: DefId(1:45302 ~ core[f118]::option::Option::Some::{constructor#0}), callee_span: idna/src/punycode.rs:63:5: 63:9 (#0), callee_path: "core::prelude::v1::Some", constraint_depth: 0 }
The code is Ok(
    "Some",
)
The code is Ok(
    "Decoder::default()\n            .decode::<u8, ExternalCaller>(input.as_bytes())\n            .ok()?\n            .collect()",
)
The code is Ok(
    "Decoder::default()\n            .decode::<u8, ExternalCaller>(input.as_bytes())\n            .ok()?",
)
into Match call
The code is Ok(
    "Decoder::default()\n            .decode::<u8, ExternalCaller>(input.as_bytes())\n            .ok()?",
)
LangItem path: idna/src/punycode.rs:64:9: 66:19 (#189)
The code is Ok(
    "Decoder::default()\n            .decode::<u8, ExternalCaller>(input.as_bytes())\n            .ok()?",
)
The code is Ok(
    "Decoder::default()\n            .decode::<u8, ExternalCaller>(input.as_bytes())\n            .ok()",
)
The code is Ok(
    "Decoder::default()\n            .decode::<u8, ExternalCaller>(input.as_bytes())",
)
The code is Ok(
    "Decoder::default()",
)
The code is Ok(
    "Decoder::default",
)
The code is Ok(
    "input.as_bytes()",
)
The code is Ok(
    "input",
)
The code is Ok(
    "?",
)
The code is Ok(
    "Decoder::default()\n            .decode::<u8, ExternalCaller>(input.as_bytes())\n            .ok()?",
)
LangItem path: idna/src/punycode.rs:66:18: 66:19 (#190)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "Decoder::default()\n            .decode::<u8, ExternalCaller>(input.as_bytes())\n            .ok()?",
)
The code is Ok(
    "59",
)
The code is Ok(
    "{\n    if input.len() > u32::MAX as usize {\n        return None;\n    }\n    let mut buf = String::with_capacity(input.len());\n    encode_into::<_, _, ExternalCaller>(input.chars(), &mut buf)\n        .ok()\n        .map(|()| buf)\n}",
)
The code is Ok(
    "if input.len() > u32::MAX as usize {\n        return None;\n    }",
)
The code is Ok(
    "input.len() > u32::MAX as usize",
)
The code is Ok(
    "input.len()",
)
The code is Ok(
    "input",
)
The code is Ok(
    "u32::MAX as usize",
)
The code is Ok(
    "u32::MAX",
)
The code is Ok(
    "return None",
)
The code is Ok(
    "None",
)
The code is Ok(
    "String::with_capacity(input.len())",
)
The code is Ok(
    "String::with_capacity",
)
The code is Ok(
    "input.len()",
)
The code is Ok(
    "input",
)
The code is Ok(
    "encode_into::<_, _, ExternalCaller>(input.chars(), &mut buf)\n        .ok()\n        .map(|()| buf)",
)
The code is Ok(
    "encode_into::<_, _, ExternalCaller>(input.chars(), &mut buf)\n        .ok()",
)
The code is Ok(
    "encode_into::<_, _, ExternalCaller>(input.chars(), &mut buf)",
)
resolved new call Call { call_expr: HirId(DefId(0:108 ~ idna[bc6b]::punycode::encode_str).40), call_expr_span: idna/src/punycode.rs:327:5: 327:65 (#0), caller: Some(DefId(0:108 ~ idna[bc6b]::punycode::encode_str)), caller_span: None, callee: DefId(0:119 ~ idna[bc6b]::punycode::encode_into), callee_span: idna/src/punycode.rs:327:5: 327:40 (#0), callee_path: "punycode::encode_into", constraint_depth: 0 }
The code is Ok(
    "encode_into::<_, _, ExternalCaller>",
)
The code is Ok(
    "input.chars()",
)
The code is Ok(
    "input",
)
The code is Ok(
    "&mut buf",
)
The code is Ok(
    "buf",
)
The code is Ok(
    "|()| buf",
)
The code is Ok(
    "buf",
)
The code is Ok(
    "{\n    if input.len() > u32::MAX as usize {\n        return None;\n    }\n    let mut buf = String::with_capacity(input.len());\n    encode_into::<_, _, ExternalCaller>(input.iter().copied(), &mut buf)\n        .ok()\n        .map(|()| buf)\n}",
)
The code is Ok(
    "if input.len() > u32::MAX as usize {\n        return None;\n    }",
)
The code is Ok(
    "input.len() > u32::MAX as usize",
)
The code is Ok(
    "input.len()",
)
The code is Ok(
    "input",
)
The code is Ok(
    "u32::MAX as usize",
)
The code is Ok(
    "u32::MAX",
)
The code is Ok(
    "return None",
)
The code is Ok(
    "None",
)
The code is Ok(
    "String::with_capacity(input.len())",
)
The code is Ok(
    "String::with_capacity",
)
The code is Ok(
    "input.len()",
)
The code is Ok(
    "input",
)
The code is Ok(
    "encode_into::<_, _, ExternalCaller>(input.iter().copied(), &mut buf)\n        .ok()\n        .map(|()| buf)",
)
The code is Ok(
    "encode_into::<_, _, ExternalCaller>(input.iter().copied(), &mut buf)\n        .ok()",
)
The code is Ok(
    "encode_into::<_, _, ExternalCaller>(input.iter().copied(), &mut buf)",
)
resolved new call Call { call_expr: HirId(DefId(0:110 ~ idna[bc6b]::punycode::encode).40), call_expr_span: idna/src/punycode.rs:341:5: 341:73 (#0), caller: Some(DefId(0:110 ~ idna[bc6b]::punycode::encode)), caller_span: None, callee: DefId(0:119 ~ idna[bc6b]::punycode::encode_into), callee_span: idna/src/punycode.rs:341:5: 341:40 (#0), callee_path: "punycode::encode_into", constraint_depth: 0 }
The code is Ok(
    "encode_into::<_, _, ExternalCaller>",
)
The code is Ok(
    "input.iter().copied()",
)
The code is Ok(
    "input.iter()",
)
The code is Ok(
    "input",
)
The code is Ok(
    "&mut buf",
)
The code is Ok(
    "buf",
)
The code is Ok(
    "|()| buf",
)
The code is Ok(
    "buf",
)
The code is Ok(
    "{\n    // Handle \"basic\" (ASCII) code points. They are encoded as-is.\n    let (mut input_length, mut basic_length) = (0u32, 0);\n    for c in input.clone() {\n        input_length = input_length\n            .checked_add(1)\n            .ok_or(PunycodeEncodeError::Overflow)?;\n        if c.is_ascii() {\n            output.write_char(c)?;\n            basic_length += 1;\n        }\n    }\n\n    if !C::EXTERNAL_CALLER {\n        // We should never get an overflow here with the internal caller being\n        // length-limited, but let's check anyway once here trusting the math\n        // from  RFC 3492 section 6.4 and then omit the overflow checks in the\n        // loop below.\n        let len_plus_one = input_length\n            .checked_add(1)\n            .ok_or(PunycodeEncodeError::Overflow)?;\n        len_plus_one\n            .checked_mul(u32::from(char::MAX) - INITIAL_N)\n            .ok_or(PunycodeEncodeError::Overflow)?;\n    }\n\n    if basic_length > 0 {\n        output.write_char('-')?;\n    }\n    let mut code_point = INITIAL_N;\n    let mut delta = 0u32;\n    let mut bias = INITIAL_BIAS;\n    let mut processed = basic_length;\n    while processed < input_length {\n        // All code points < code_point have been handled already.\n        // Find the next larger one.\n        let min_code_point = input\n            .clone()\n            .map(|c| c as u32)\n            .filter(|&c| c >= code_point)\n            .min()\n            .unwrap();\n        // Increase delta to advance the decoder’s <code_point,i> state to <min_code_point,0>\n        if C::EXTERNAL_CALLER {\n            let product = (min_code_point - code_point)\n                .checked_mul(processed + 1)\n                .ok_or(PunycodeEncodeError::Overflow)?;\n            delta = delta\n                .checked_add(product)\n                .ok_or(PunycodeEncodeError::Overflow)?;\n        } else {\n            delta += (min_code_point - code_point) * (processed + 1);\n        }\n        code_point = min_code_point;\n        for c in input.clone() {\n            let c = c as u32;\n            if c < code_point {\n                if C::EXTERNAL_CALLER {\n                    delta = delta.checked_add(1).ok_or(PunycodeEncodeError::Overflow)?;\n                } else {\n                    delta += 1;\n                }\n            }\n            if c == code_point {\n                // Represent delta as a generalized variable-length integer:\n                let mut q = delta;\n                let mut k = BASE;\n                loop {\n                    let t = if k <= bias {\n                        T_MIN\n                    } else if k >= bias + T_MAX {\n                        T_MAX\n                    } else {\n                        k - bias\n                    };\n                    if q < t {\n                        break;\n                    }\n                    let value = t + ((q - t) % (BASE - t));\n                    output.write_char(value_to_digit(value))?;\n                    q = (q - t) / (BASE - t);\n                    k += BASE;\n                }\n                output.write_char(value_to_digit(q))?;\n                bias = adapt(delta, processed + 1, processed == basic_length);\n                delta = 0;\n                processed += 1;\n            }\n        }\n        delta += 1;\n        code_point += 1;\n    }\n    Ok(())\n}",
)
The code is Ok(
    "(0u32, 0)",
)
The code is Ok(
    "0u32",
)
The code is Ok(
    "0",
)
The code is Ok(
    "for c in input.clone() {\n        input_length = input_length\n            .checked_add(1)\n            .ok_or(PunycodeEncodeError::Overflow)?;\n        if c.is_ascii() {\n            output.write_char(c)?;\n            basic_length += 1;\n        }\n    }",
)
The code is Ok(
    "for c in input.clone() {\n        input_length = input_length\n            .checked_add(1)\n            .ok_or(PunycodeEncodeError::Overflow)?;\n        if c.is_ascii() {\n            output.write_char(c)?;\n            basic_length += 1;\n        }\n    }",
)
into Match call
The code is Ok(
    "input.clone()",
)
LangItem path: idna/src/punycode.rs:365:14: 365:27 (#223)
The code is Ok(
    "input.clone()",
)
The code is Ok(
    "input.clone()",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:119 ~ idna[bc6b]::punycode::encode_into).13),
    call_expr_span: idna/src/punycode.rs:365:14: 365:27 (#0),
    caller: Some(
        DefId(0:119 ~ idna[bc6b]::punycode::encode_into),
    ),
    caller_span: None,
    callee: DefId(1:2809 ~ core[f118]::clone::Clone::clone),
    callee_span: idna/src/punycode.rs:365:14: 365:27 (#0),
    callee_path: "core::clone::Clone::clone",
    constraint_depth: 1,
}
The code is Ok(
    "input",
)
The code is Ok(
    "for c in input.clone() {\n        input_length = input_length\n            .checked_add(1)\n            .ok_or(PunycodeEncodeError::Overflow)?;\n        if c.is_ascii() {\n            output.write_char(c)?;\n            basic_length += 1;\n        }\n    }",
)
The code is Ok(
    "input.clone()",
)
into Match call
is inner Match
The code is Ok(
    "input.clone()",
)
LangItem path: idna/src/punycode.rs:365:14: 365:27 (#223)
The code is Ok(
    "input.clone()",
)
The code is Ok(
    "input.clone()",
)
The code is Ok(
    "input.clone()",
)
The code is Ok(
    "for c in input.clone() {\n        input_length = input_length\n            .checked_add(1)\n            .ok_or(PunycodeEncodeError::Overflow)?;\n        if c.is_ascii() {\n            output.write_char(c)?;\n            basic_length += 1;\n        }\n    }",
)
The code is Ok(
    "{\n        input_length = input_length\n            .checked_add(1)\n            .ok_or(PunycodeEncodeError::Overflow)?;\n        if c.is_ascii() {\n            output.write_char(c)?;\n            basic_length += 1;\n        }\n    }",
)
The code is Ok(
    "input_length = input_length\n            .checked_add(1)\n            .ok_or(PunycodeEncodeError::Overflow)?",
)
The code is Ok(
    "input_length\n            .checked_add(1)\n            .ok_or(PunycodeEncodeError::Overflow)?",
)
into Match call
The code is Ok(
    "input_length\n            .checked_add(1)\n            .ok_or(PunycodeEncodeError::Overflow)?",
)
LangItem path: idna/src/punycode.rs:366:24: 368:51 (#225)
The code is Ok(
    "input_length\n            .checked_add(1)\n            .ok_or(PunycodeEncodeError::Overflow)?",
)
The code is Ok(
    "input_length\n            .checked_add(1)\n            .ok_or(PunycodeEncodeError::Overflow)",
)
The code is Ok(
    "input_length\n            .checked_add(1)",
)
The code is Ok(
    "input_length",
)
The code is Ok(
    "1",
)
The code is Ok(
    "PunycodeEncodeError::Overflow",
)
The code is Ok(
    "?",
)
The code is Ok(
    "input_length\n            .checked_add(1)\n            .ok_or(PunycodeEncodeError::Overflow)?",
)
LangItem path: idna/src/punycode.rs:368:50: 368:51 (#226)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "input_length\n            .checked_add(1)\n            .ok_or(PunycodeEncodeError::Overflow)?",
)
The code is Ok(
    "input_length",
)
The code is Ok(
    "if c.is_ascii() {\n            output.write_char(c)?;\n            basic_length += 1;\n        }",
)
The code is Ok(
    "c.is_ascii()",
)
The code is Ok(
    "c",
)
The code is Ok(
    "output.write_char(c)?",
)
into Match call
The code is Ok(
    "output.write_char(c)?",
)
LangItem path: idna/src/punycode.rs:370:13: 370:34 (#228)
The code is Ok(
    "output.write_char(c)?",
)
The code is Ok(
    "output.write_char(c)",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:119 ~ idna[bc6b]::punycode::encode_into).63),
    call_expr_span: idna/src/punycode.rs:370:13: 370:33 (#0),
    caller: Some(
        DefId(0:119 ~ idna[bc6b]::punycode::encode_into),
    ),
    caller_span: None,
    callee: DefId(1:10605 ~ core[f118]::fmt::Write::write_char),
    callee_span: idna/src/punycode.rs:370:13: 370:33 (#0),
    callee_path: "core::fmt::Write::write_char",
    constraint_depth: 2,
}
The code is Ok(
    "output",
)
The code is Ok(
    "c",
)
The code is Ok(
    "?",
)
The code is Ok(
    "output.write_char(c)?",
)
LangItem path: idna/src/punycode.rs:370:33: 370:34 (#229)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "output.write_char(c)?",
)
The code is Ok(
    "basic_length += 1",
)
The code is Ok(
    "1",
)
The code is Ok(
    "basic_length",
)
The code is Ok(
    "if !C::EXTERNAL_CALLER {\n        // We should never get an overflow here with the internal caller being\n        // length-limited, but let's check anyway once here trusting the math\n        // from  RFC 3492 section 6.4 and then omit the overflow checks in the\n        // loop below.\n        let len_plus_one = input_length\n            .checked_add(1)\n            .ok_or(PunycodeEncodeError::Overflow)?;\n        len_plus_one\n            .checked_mul(u32::from(char::MAX) - INITIAL_N)\n            .ok_or(PunycodeEncodeError::Overflow)?;\n    }",
)
The code is Ok(
    "!C::EXTERNAL_CALLER",
)
The code is Ok(
    "C::EXTERNAL_CALLER",
)
The code is Ok(
    "input_length\n            .checked_add(1)\n            .ok_or(PunycodeEncodeError::Overflow)?",
)
into Match call
The code is Ok(
    "input_length\n            .checked_add(1)\n            .ok_or(PunycodeEncodeError::Overflow)?",
)
LangItem path: idna/src/punycode.rs:380:28: 382:51 (#231)
The code is Ok(
    "input_length\n            .checked_add(1)\n            .ok_or(PunycodeEncodeError::Overflow)?",
)
The code is Ok(
    "input_length\n            .checked_add(1)\n            .ok_or(PunycodeEncodeError::Overflow)",
)
The code is Ok(
    "input_length\n            .checked_add(1)",
)
The code is Ok(
    "input_length",
)
The code is Ok(
    "1",
)
The code is Ok(
    "PunycodeEncodeError::Overflow",
)
The code is Ok(
    "?",
)
The code is Ok(
    "input_length\n            .checked_add(1)\n            .ok_or(PunycodeEncodeError::Overflow)?",
)
LangItem path: idna/src/punycode.rs:382:50: 382:51 (#232)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "input_length\n            .checked_add(1)\n            .ok_or(PunycodeEncodeError::Overflow)?",
)
The code is Ok(
    "len_plus_one\n            .checked_mul(u32::from(char::MAX) - INITIAL_N)\n            .ok_or(PunycodeEncodeError::Overflow)?",
)
into Match call
The code is Ok(
    "len_plus_one\n            .checked_mul(u32::from(char::MAX) - INITIAL_N)\n            .ok_or(PunycodeEncodeError::Overflow)?",
)
LangItem path: idna/src/punycode.rs:383:9: 385:51 (#233)
The code is Ok(
    "len_plus_one\n            .checked_mul(u32::from(char::MAX) - INITIAL_N)\n            .ok_or(PunycodeEncodeError::Overflow)?",
)
The code is Ok(
    "len_plus_one\n            .checked_mul(u32::from(char::MAX) - INITIAL_N)\n            .ok_or(PunycodeEncodeError::Overflow)",
)
The code is Ok(
    "len_plus_one\n            .checked_mul(u32::from(char::MAX) - INITIAL_N)",
)
The code is Ok(
    "len_plus_one",
)
The code is Ok(
    "u32::from(char::MAX) - INITIAL_N",
)
The code is Ok(
    "u32::from(char::MAX)",
)
The code is Ok(
    "u32::from",
)
The code is Ok(
    "char::MAX",
)
The code is Ok(
    "INITIAL_N",
)
The code is Ok(
    "PunycodeEncodeError::Overflow",
)
The code is Ok(
    "?",
)
The code is Ok(
    "len_plus_one\n            .checked_mul(u32::from(char::MAX) - INITIAL_N)\n            .ok_or(PunycodeEncodeError::Overflow)?",
)
LangItem path: idna/src/punycode.rs:385:50: 385:51 (#234)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "len_plus_one\n            .checked_mul(u32::from(char::MAX) - INITIAL_N)\n            .ok_or(PunycodeEncodeError::Overflow)?",
)
The code is Ok(
    "if basic_length > 0 {\n        output.write_char('-')?;\n    }",
)
The code is Ok(
    "basic_length > 0",
)
The code is Ok(
    "basic_length",
)
The code is Ok(
    "0",
)
The code is Ok(
    "output.write_char('-')?",
)
into Match call
The code is Ok(
    "output.write_char('-')?",
)
LangItem path: idna/src/punycode.rs:389:9: 389:32 (#236)
The code is Ok(
    "output.write_char('-')?",
)
The code is Ok(
    "output.write_char('-')",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:119 ~ idna[bc6b]::punycode::encode_into).199),
    call_expr_span: idna/src/punycode.rs:389:9: 389:31 (#0),
    caller: Some(
        DefId(0:119 ~ idna[bc6b]::punycode::encode_into),
    ),
    caller_span: None,
    callee: DefId(1:10605 ~ core[f118]::fmt::Write::write_char),
    callee_span: idna/src/punycode.rs:389:9: 389:31 (#0),
    callee_path: "core::fmt::Write::write_char",
    constraint_depth: 1,
}
The code is Ok(
    "output",
)
The code is Ok(
    "'-'",
)
The code is Ok(
    "?",
)
The code is Ok(
    "output.write_char('-')?",
)
LangItem path: idna/src/punycode.rs:389:31: 389:32 (#237)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "output.write_char('-')?",
)
The code is Ok(
    "INITIAL_N",
)
The code is Ok(
    "0u32",
)
The code is Ok(
    "INITIAL_BIAS",
)
The code is Ok(
    "basic_length",
)
The code is Ok(
    "while processed < input_length {\n        // All code points < code_point have been handled already.\n        // Find the next larger one.\n        let min_code_point = input\n            .clone()\n            .map(|c| c as u32)\n            .filter(|&c| c >= code_point)\n            .min()\n            .unwrap();\n        // Increase delta to advance the decoder’s <code_point,i> state to <min_code_point,0>\n        if C::EXTERNAL_CALLER {\n            let product = (min_code_point - code_point)\n                .checked_mul(processed + 1)\n                .ok_or(PunycodeEncodeError::Overflow)?;\n            delta = delta\n                .checked_add(product)\n                .ok_or(PunycodeEncodeError::Overflow)?;\n        } else {\n            delta += (min_code_point - code_point) * (processed + 1);\n        }\n        code_point = min_code_point;\n        for c in input.clone() {\n            let c = c as u32;\n            if c < code_point {\n                if C::EXTERNAL_CALLER {\n                    delta = delta.checked_add(1).ok_or(PunycodeEncodeError::Overflow)?;\n                } else {\n                    delta += 1;\n                }\n            }\n            if c == code_point {\n                // Represent delta as a generalized variable-length integer:\n                let mut q = delta;\n                let mut k = BASE;\n                loop {\n                    let t = if k <= bias {\n                        T_MIN\n                    } else if k >= bias + T_MAX {\n                        T_MAX\n                    } else {\n                        k - bias\n                    };\n                    if q < t {\n                        break;\n                    }\n                    let value = t + ((q - t) % (BASE - t));\n                    output.write_char(value_to_digit(value))?;\n                    q = (q - t) / (BASE - t);\n                    k += BASE;\n                }\n                output.write_char(value_to_digit(q))?;\n                bias = adapt(delta, processed + 1, processed == basic_length);\n                delta = 0;\n                processed += 1;\n            }\n        }\n        delta += 1;\n        code_point += 1;\n    }",
)
The code is Ok(
    "while processed < input_length {\n        // All code points < code_point have been handled already.\n        // Find the next larger one.\n        let min_code_point = input\n            .clone()\n            .map(|c| c as u32)\n            .filter(|&c| c >= code_point)\n            .min()\n            .unwrap();\n        // Increase delta to advance the decoder’s <code_point,i> state to <min_code_point,0>\n        if C::EXTERNAL_CALLER {\n            let product = (min_code_point - code_point)\n                .checked_mul(processed + 1)\n                .ok_or(PunycodeEncodeError::Overflow)?;\n            delta = delta\n                .checked_add(product)\n                .ok_or(PunycodeEncodeError::Overflow)?;\n        } else {\n            delta += (min_code_point - code_point) * (processed + 1);\n        }\n        code_point = min_code_point;\n        for c in input.clone() {\n            let c = c as u32;\n            if c < code_point {\n                if C::EXTERNAL_CALLER {\n                    delta = delta.checked_add(1).ok_or(PunycodeEncodeError::Overflow)?;\n                } else {\n                    delta += 1;\n                }\n            }\n            if c == code_point {\n                // Represent delta as a generalized variable-length integer:\n                let mut q = delta;\n                let mut k = BASE;\n                loop {\n                    let t = if k <= bias {\n                        T_MIN\n                    } else if k >= bias + T_MAX {\n                        T_MAX\n                    } else {\n                        k - bias\n                    };\n                    if q < t {\n                        break;\n                    }\n                    let value = t + ((q - t) % (BASE - t));\n                    output.write_char(value_to_digit(value))?;\n                    q = (q - t) / (BASE - t);\n                    k += BASE;\n                }\n                output.write_char(value_to_digit(q))?;\n                bias = adapt(delta, processed + 1, processed == basic_length);\n                delta = 0;\n                processed += 1;\n            }\n        }\n        delta += 1;\n        code_point += 1;\n    }",
)
The code is Ok(
    "processed < input_length",
)
The code is Ok(
    "processed",
)
The code is Ok(
    "input_length",
)
The code is Ok(
    "input\n            .clone()\n            .map(|c| c as u32)\n            .filter(|&c| c >= code_point)\n            .min()\n            .unwrap()",
)
The code is Ok(
    "input\n            .clone()\n            .map(|c| c as u32)\n            .filter(|&c| c >= code_point)\n            .min()",
)
The code is Ok(
    "input\n            .clone()\n            .map(|c| c as u32)\n            .filter(|&c| c >= code_point)",
)
The code is Ok(
    "input\n            .clone()\n            .map(|c| c as u32)",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:119 ~ idna[bc6b]::punycode::encode_into).258),
    call_expr_span: idna/src/punycode.rs:398:30: 400:31 (#0),
    caller: Some(
        DefId(0:119 ~ idna[bc6b]::punycode::encode_into),
    ),
    caller_span: None,
    callee: DefId(1:8518 ~ core[f118]::iter::traits::iterator::Iterator::map),
    callee_span: idna/src/punycode.rs:398:30: 400:31 (#0),
    callee_path: "core::iter::Iterator::map",
    constraint_depth: 1,
}
The code is Ok(
    "input\n            .clone()",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:119 ~ idna[bc6b]::punycode::encode_into).260),
    call_expr_span: idna/src/punycode.rs:398:30: 399:21 (#0),
    caller: Some(
        DefId(0:119 ~ idna[bc6b]::punycode::encode_into),
    ),
    caller_span: None,
    callee: DefId(1:2809 ~ core[f118]::clone::Clone::clone),
    callee_span: idna/src/punycode.rs:398:30: 399:21 (#0),
    callee_path: "core::clone::Clone::clone",
    constraint_depth: 1,
}
The code is Ok(
    "input",
)
The code is Ok(
    "|c| c as u32",
)
The code is Ok(
    "c as u32",
)
The code is Ok(
    "c",
)
The code is Ok(
    "|&c| c >= code_point",
)
The code is Ok(
    "c >= code_point",
)
The code is Ok(
    "c",
)
The code is Ok(
    "code_point",
)
The code is Ok(
    "if C::EXTERNAL_CALLER {\n            let product = (min_code_point - code_point)\n                .checked_mul(processed + 1)\n                .ok_or(PunycodeEncodeError::Overflow)?;\n            delta = delta\n                .checked_add(product)\n                .ok_or(PunycodeEncodeError::Overflow)?;\n        } else {\n            delta += (min_code_point - code_point) * (processed + 1);\n        }",
)
The code is Ok(
    "C::EXTERNAL_CALLER",
)
The code is Ok(
    "(min_code_point - code_point)\n                .checked_mul(processed + 1)\n                .ok_or(PunycodeEncodeError::Overflow)?",
)
into Match call
The code is Ok(
    "(min_code_point - code_point)\n                .checked_mul(processed + 1)\n                .ok_or(PunycodeEncodeError::Overflow)?",
)
LangItem path: idna/src/punycode.rs:406:27: 408:55 (#241)
The code is Ok(
    "(min_code_point - code_point)\n                .checked_mul(processed + 1)\n                .ok_or(PunycodeEncodeError::Overflow)?",
)
The code is Ok(
    "(min_code_point - code_point)\n                .checked_mul(processed + 1)\n                .ok_or(PunycodeEncodeError::Overflow)",
)
The code is Ok(
    "(min_code_point - code_point)\n                .checked_mul(processed + 1)",
)
The code is Ok(
    "(min_code_point - code_point)",
)
The code is Ok(
    "min_code_point",
)
The code is Ok(
    "code_point",
)
The code is Ok(
    "processed + 1",
)
The code is Ok(
    "processed",
)
The code is Ok(
    "1",
)
The code is Ok(
    "PunycodeEncodeError::Overflow",
)
The code is Ok(
    "?",
)
The code is Ok(
    "(min_code_point - code_point)\n                .checked_mul(processed + 1)\n                .ok_or(PunycodeEncodeError::Overflow)?",
)
LangItem path: idna/src/punycode.rs:408:54: 408:55 (#242)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "(min_code_point - code_point)\n                .checked_mul(processed + 1)\n                .ok_or(PunycodeEncodeError::Overflow)?",
)
The code is Ok(
    "delta = delta\n                .checked_add(product)\n                .ok_or(PunycodeEncodeError::Overflow)?",
)
The code is Ok(
    "delta\n                .checked_add(product)\n                .ok_or(PunycodeEncodeError::Overflow)?",
)
into Match call
The code is Ok(
    "delta\n                .checked_add(product)\n                .ok_or(PunycodeEncodeError::Overflow)?",
)
LangItem path: idna/src/punycode.rs:409:21: 411:55 (#243)
The code is Ok(
    "delta\n                .checked_add(product)\n                .ok_or(PunycodeEncodeError::Overflow)?",
)
The code is Ok(
    "delta\n                .checked_add(product)\n                .ok_or(PunycodeEncodeError::Overflow)",
)
The code is Ok(
    "delta\n                .checked_add(product)",
)
The code is Ok(
    "delta",
)
The code is Ok(
    "product",
)
The code is Ok(
    "PunycodeEncodeError::Overflow",
)
The code is Ok(
    "?",
)
The code is Ok(
    "delta\n                .checked_add(product)\n                .ok_or(PunycodeEncodeError::Overflow)?",
)
LangItem path: idna/src/punycode.rs:411:54: 411:55 (#244)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "delta\n                .checked_add(product)\n                .ok_or(PunycodeEncodeError::Overflow)?",
)
The code is Ok(
    "delta",
)
The code is Ok(
    "delta += (min_code_point - code_point) * (processed + 1)",
)
The code is Ok(
    "(min_code_point - code_point) * (processed + 1)",
)
The code is Ok(
    "(min_code_point - code_point)",
)
The code is Ok(
    "min_code_point",
)
The code is Ok(
    "code_point",
)
The code is Ok(
    "(processed + 1)",
)
The code is Ok(
    "processed",
)
The code is Ok(
    "1",
)
The code is Ok(
    "delta",
)
The code is Ok(
    "code_point = min_code_point",
)
The code is Ok(
    "min_code_point",
)
The code is Ok(
    "code_point",
)
The code is Ok(
    "for c in input.clone() {\n            let c = c as u32;\n            if c < code_point {\n                if C::EXTERNAL_CALLER {\n                    delta = delta.checked_add(1).ok_or(PunycodeEncodeError::Overflow)?;\n                } else {\n                    delta += 1;\n                }\n            }\n            if c == code_point {\n                // Represent delta as a generalized variable-length integer:\n                let mut q = delta;\n                let mut k = BASE;\n                loop {\n                    let t = if k <= bias {\n                        T_MIN\n                    } else if k >= bias + T_MAX {\n                        T_MAX\n                    } else {\n                        k - bias\n                    };\n                    if q < t {\n                        break;\n                    }\n                    let value = t + ((q - t) % (BASE - t));\n                    output.write_char(value_to_digit(value))?;\n                    q = (q - t) / (BASE - t);\n                    k += BASE;\n                }\n                output.write_char(value_to_digit(q))?;\n                bias = adapt(delta, processed + 1, processed == basic_length);\n                delta = 0;\n                processed += 1;\n            }\n        }",
)
The code is Ok(
    "for c in input.clone() {\n            let c = c as u32;\n            if c < code_point {\n                if C::EXTERNAL_CALLER {\n                    delta = delta.checked_add(1).ok_or(PunycodeEncodeError::Overflow)?;\n                } else {\n                    delta += 1;\n                }\n            }\n            if c == code_point {\n                // Represent delta as a generalized variable-length integer:\n                let mut q = delta;\n                let mut k = BASE;\n                loop {\n                    let t = if k <= bias {\n                        T_MIN\n                    } else if k >= bias + T_MAX {\n                        T_MAX\n                    } else {\n                        k - bias\n                    };\n                    if q < t {\n                        break;\n                    }\n                    let value = t + ((q - t) % (BASE - t));\n                    output.write_char(value_to_digit(value))?;\n                    q = (q - t) / (BASE - t);\n                    k += BASE;\n                }\n                output.write_char(value_to_digit(q))?;\n                bias = adapt(delta, processed + 1, processed == basic_length);\n                delta = 0;\n                processed += 1;\n            }\n        }",
)
into Match call
The code is Ok(
    "input.clone()",
)
LangItem path: idna/src/punycode.rs:416:18: 416:31 (#246)
The code is Ok(
    "input.clone()",
)
The code is Ok(
    "input.clone()",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:119 ~ idna[bc6b]::punycode::encode_into).386),
    call_expr_span: idna/src/punycode.rs:416:18: 416:31 (#0),
    caller: Some(
        DefId(0:119 ~ idna[bc6b]::punycode::encode_into),
    ),
    caller_span: None,
    callee: DefId(1:2809 ~ core[f118]::clone::Clone::clone),
    callee_span: idna/src/punycode.rs:416:18: 416:31 (#0),
    callee_path: "core::clone::Clone::clone",
    constraint_depth: 2,
}
The code is Ok(
    "input",
)
The code is Ok(
    "for c in input.clone() {\n            let c = c as u32;\n            if c < code_point {\n                if C::EXTERNAL_CALLER {\n                    delta = delta.checked_add(1).ok_or(PunycodeEncodeError::Overflow)?;\n                } else {\n                    delta += 1;\n                }\n            }\n            if c == code_point {\n                // Represent delta as a generalized variable-length integer:\n                let mut q = delta;\n                let mut k = BASE;\n                loop {\n                    let t = if k <= bias {\n                        T_MIN\n                    } else if k >= bias + T_MAX {\n                        T_MAX\n                    } else {\n                        k - bias\n                    };\n                    if q < t {\n                        break;\n                    }\n                    let value = t + ((q - t) % (BASE - t));\n                    output.write_char(value_to_digit(value))?;\n                    q = (q - t) / (BASE - t);\n                    k += BASE;\n                }\n                output.write_char(value_to_digit(q))?;\n                bias = adapt(delta, processed + 1, processed == basic_length);\n                delta = 0;\n                processed += 1;\n            }\n        }",
)
The code is Ok(
    "input.clone()",
)
into Match call
is inner Match
The code is Ok(
    "input.clone()",
)
LangItem path: idna/src/punycode.rs:416:18: 416:31 (#246)
The code is Ok(
    "input.clone()",
)
The code is Ok(
    "input.clone()",
)
The code is Ok(
    "input.clone()",
)
The code is Ok(
    "for c in input.clone() {\n            let c = c as u32;\n            if c < code_point {\n                if C::EXTERNAL_CALLER {\n                    delta = delta.checked_add(1).ok_or(PunycodeEncodeError::Overflow)?;\n                } else {\n                    delta += 1;\n                }\n            }\n            if c == code_point {\n                // Represent delta as a generalized variable-length integer:\n                let mut q = delta;\n                let mut k = BASE;\n                loop {\n                    let t = if k <= bias {\n                        T_MIN\n                    } else if k >= bias + T_MAX {\n                        T_MAX\n                    } else {\n                        k - bias\n                    };\n                    if q < t {\n                        break;\n                    }\n                    let value = t + ((q - t) % (BASE - t));\n                    output.write_char(value_to_digit(value))?;\n                    q = (q - t) / (BASE - t);\n                    k += BASE;\n                }\n                output.write_char(value_to_digit(q))?;\n                bias = adapt(delta, processed + 1, processed == basic_length);\n                delta = 0;\n                processed += 1;\n            }\n        }",
)
The code is Ok(
    "{\n            let c = c as u32;\n            if c < code_point {\n                if C::EXTERNAL_CALLER {\n                    delta = delta.checked_add(1).ok_or(PunycodeEncodeError::Overflow)?;\n                } else {\n                    delta += 1;\n                }\n            }\n            if c == code_point {\n                // Represent delta as a generalized variable-length integer:\n                let mut q = delta;\n                let mut k = BASE;\n                loop {\n                    let t = if k <= bias {\n                        T_MIN\n                    } else if k >= bias + T_MAX {\n                        T_MAX\n                    } else {\n                        k - bias\n                    };\n                    if q < t {\n                        break;\n                    }\n                    let value = t + ((q - t) % (BASE - t));\n                    output.write_char(value_to_digit(value))?;\n                    q = (q - t) / (BASE - t);\n                    k += BASE;\n                }\n                output.write_char(value_to_digit(q))?;\n                bias = adapt(delta, processed + 1, processed == basic_length);\n                delta = 0;\n                processed += 1;\n            }\n        }",
)
The code is Ok(
    "c as u32",
)
The code is Ok(
    "c",
)
The code is Ok(
    "if c < code_point {\n                if C::EXTERNAL_CALLER {\n                    delta = delta.checked_add(1).ok_or(PunycodeEncodeError::Overflow)?;\n                } else {\n                    delta += 1;\n                }\n            }",
)
The code is Ok(
    "c < code_point",
)
The code is Ok(
    "c",
)
The code is Ok(
    "code_point",
)
The code is Ok(
    "if C::EXTERNAL_CALLER {\n                    delta = delta.checked_add(1).ok_or(PunycodeEncodeError::Overflow)?;\n                } else {\n                    delta += 1;\n                }",
)
The code is Ok(
    "C::EXTERNAL_CALLER",
)
The code is Ok(
    "delta = delta.checked_add(1).ok_or(PunycodeEncodeError::Overflow)?",
)
The code is Ok(
    "delta.checked_add(1).ok_or(PunycodeEncodeError::Overflow)?",
)
into Match call
The code is Ok(
    "delta.checked_add(1).ok_or(PunycodeEncodeError::Overflow)?",
)
LangItem path: idna/src/punycode.rs:420:29: 420:87 (#250)
The code is Ok(
    "delta.checked_add(1).ok_or(PunycodeEncodeError::Overflow)?",
)
The code is Ok(
    "delta.checked_add(1).ok_or(PunycodeEncodeError::Overflow)",
)
The code is Ok(
    "delta.checked_add(1)",
)
The code is Ok(
    "delta",
)
The code is Ok(
    "1",
)
The code is Ok(
    "PunycodeEncodeError::Overflow",
)
The code is Ok(
    "?",
)
The code is Ok(
    "delta.checked_add(1).ok_or(PunycodeEncodeError::Overflow)?",
)
LangItem path: idna/src/punycode.rs:420:86: 420:87 (#251)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "delta.checked_add(1).ok_or(PunycodeEncodeError::Overflow)?",
)
The code is Ok(
    "delta",
)
The code is Ok(
    "delta += 1",
)
The code is Ok(
    "1",
)
The code is Ok(
    "delta",
)
The code is Ok(
    "if c == code_point {\n                // Represent delta as a generalized variable-length integer:\n                let mut q = delta;\n                let mut k = BASE;\n                loop {\n                    let t = if k <= bias {\n                        T_MIN\n                    } else if k >= bias + T_MAX {\n                        T_MAX\n                    } else {\n                        k - bias\n                    };\n                    if q < t {\n                        break;\n                    }\n                    let value = t + ((q - t) % (BASE - t));\n                    output.write_char(value_to_digit(value))?;\n                    q = (q - t) / (BASE - t);\n                    k += BASE;\n                }\n                output.write_char(value_to_digit(q))?;\n                bias = adapt(delta, processed + 1, processed == basic_length);\n                delta = 0;\n                processed += 1;\n            }",
)
The code is Ok(
    "c == code_point",
)
The code is Ok(
    "c",
)
The code is Ok(
    "code_point",
)
The code is Ok(
    "delta",
)
The code is Ok(
    "BASE",
)
The code is Ok(
    "loop {\n                    let t = if k <= bias {\n                        T_MIN\n                    } else if k >= bias + T_MAX {\n                        T_MAX\n                    } else {\n                        k - bias\n                    };\n                    if q < t {\n                        break;\n                    }\n                    let value = t + ((q - t) % (BASE - t));\n                    output.write_char(value_to_digit(value))?;\n                    q = (q - t) / (BASE - t);\n                    k += BASE;\n                }",
)
The code is Ok(
    "if k <= bias {\n                        T_MIN\n                    } else if k >= bias + T_MAX {\n                        T_MAX\n                    } else {\n                        k - bias\n                    }",
)
The code is Ok(
    "k <= bias",
)
The code is Ok(
    "k",
)
The code is Ok(
    "bias",
)
The code is Ok(
    "T_MIN",
)
The code is Ok(
    "k >= bias + T_MAX",
)
The code is Ok(
    "k >= bias + T_MAX",
)
The code is Ok(
    "k",
)
The code is Ok(
    "bias + T_MAX",
)
The code is Ok(
    "bias",
)
The code is Ok(
    "T_MAX",
)
The code is Ok(
    "{\n                        T_MAX\n                    }",
)
The code is Ok(
    "T_MAX",
)
The code is Ok(
    "{\n                        k - bias\n                    }",
)
The code is Ok(
    "k - bias",
)
The code is Ok(
    "k",
)
The code is Ok(
    "bias",
)
The code is Ok(
    "if q < t {\n                        break;\n                    }",
)
The code is Ok(
    "q < t",
)
The code is Ok(
    "q",
)
The code is Ok(
    "t",
)
The code is Ok(
    "break",
)
The code is Ok(
    "t + ((q - t) % (BASE - t))",
)
The code is Ok(
    "t",
)
The code is Ok(
    "((q - t) % (BASE - t))",
)
The code is Ok(
    "(q - t)",
)
The code is Ok(
    "q",
)
The code is Ok(
    "t",
)
The code is Ok(
    "(BASE - t)",
)
The code is Ok(
    "BASE",
)
The code is Ok(
    "t",
)
The code is Ok(
    "output.write_char(value_to_digit(value))?",
)
into Match call
The code is Ok(
    "output.write_char(value_to_digit(value))?",
)
LangItem path: idna/src/punycode.rs:441:21: 441:62 (#256)
The code is Ok(
    "output.write_char(value_to_digit(value))?",
)
The code is Ok(
    "output.write_char(value_to_digit(value))",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:119 ~ idna[bc6b]::punycode::encode_into).545),
    call_expr_span: idna/src/punycode.rs:441:21: 441:61 (#0),
    caller: Some(
        DefId(0:119 ~ idna[bc6b]::punycode::encode_into),
    ),
    caller_span: None,
    callee: DefId(1:10605 ~ core[f118]::fmt::Write::write_char),
    callee_span: idna/src/punycode.rs:441:21: 441:61 (#0),
    callee_path: "core::fmt::Write::write_char",
    constraint_depth: 3,
}
The code is Ok(
    "output",
)
The code is Ok(
    "value_to_digit(value)",
)
resolved new call Call { call_expr: HirId(DefId(0:119 ~ idna[bc6b]::punycode::encode_into).549), call_expr_span: idna/src/punycode.rs:441:39: 441:60 (#0), caller: Some(DefId(0:119 ~ idna[bc6b]::punycode::encode_into)), caller_span: None, callee: DefId(0:125 ~ idna[bc6b]::punycode::value_to_digit), callee_span: idna/src/punycode.rs:441:39: 441:53 (#0), callee_path: "punycode::value_to_digit", constraint_depth: 3 }
The code is Ok(
    "value_to_digit",
)
The code is Ok(
    "value",
)
The code is Ok(
    "?",
)
The code is Ok(
    "output.write_char(value_to_digit(value))?",
)
LangItem path: idna/src/punycode.rs:441:61: 441:62 (#257)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "output.write_char(value_to_digit(value))?",
)
The code is Ok(
    "q = (q - t) / (BASE - t)",
)
The code is Ok(
    "(q - t) / (BASE - t)",
)
The code is Ok(
    "(q - t)",
)
The code is Ok(
    "q",
)
The code is Ok(
    "t",
)
The code is Ok(
    "(BASE - t)",
)
The code is Ok(
    "BASE",
)
The code is Ok(
    "t",
)
The code is Ok(
    "q",
)
The code is Ok(
    "k += BASE",
)
The code is Ok(
    "BASE",
)
The code is Ok(
    "k",
)
The code is Ok(
    "output.write_char(value_to_digit(q))?",
)
into Match call
The code is Ok(
    "output.write_char(value_to_digit(q))?",
)
LangItem path: idna/src/punycode.rs:445:17: 445:54 (#258)
The code is Ok(
    "output.write_char(value_to_digit(q))?",
)
The code is Ok(
    "output.write_char(value_to_digit(q))",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:119 ~ idna[bc6b]::punycode::encode_into).596),
    call_expr_span: idna/src/punycode.rs:445:17: 445:53 (#0),
    caller: Some(
        DefId(0:119 ~ idna[bc6b]::punycode::encode_into),
    ),
    caller_span: None,
    callee: DefId(1:10605 ~ core[f118]::fmt::Write::write_char),
    callee_span: idna/src/punycode.rs:445:17: 445:53 (#0),
    callee_path: "core::fmt::Write::write_char",
    constraint_depth: 3,
}
The code is Ok(
    "output",
)
The code is Ok(
    "value_to_digit(q)",
)
resolved new call Call { call_expr: HirId(DefId(0:119 ~ idna[bc6b]::punycode::encode_into).600), call_expr_span: idna/src/punycode.rs:445:35: 445:52 (#0), caller: Some(DefId(0:119 ~ idna[bc6b]::punycode::encode_into)), caller_span: None, callee: DefId(0:125 ~ idna[bc6b]::punycode::value_to_digit), callee_span: idna/src/punycode.rs:445:35: 445:49 (#0), callee_path: "punycode::value_to_digit", constraint_depth: 3 }
The code is Ok(
    "value_to_digit",
)
The code is Ok(
    "q",
)
The code is Ok(
    "?",
)
The code is Ok(
    "output.write_char(value_to_digit(q))?",
)
LangItem path: idna/src/punycode.rs:445:53: 445:54 (#259)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "output.write_char(value_to_digit(q))?",
)
The code is Ok(
    "bias = adapt(delta, processed + 1, processed == basic_length)",
)
The code is Ok(
    "adapt(delta, processed + 1, processed == basic_length)",
)
resolved new call Call { call_expr: HirId(DefId(0:119 ~ idna[bc6b]::punycode::encode_into).626), call_expr_span: idna/src/punycode.rs:446:24: 446:78 (#0), caller: Some(DefId(0:119 ~ idna[bc6b]::punycode::encode_into)), caller_span: None, callee: DefId(0:49 ~ idna[bc6b]::punycode::adapt), callee_span: idna/src/punycode.rs:446:24: 446:29 (#0), callee_path: "punycode::adapt", constraint_depth: 3 }
The code is Ok(
    "adapt",
)
The code is Ok(
    "delta",
)
The code is Ok(
    "processed + 1",
)
The code is Ok(
    "processed",
)
The code is Ok(
    "1",
)
The code is Ok(
    "processed == basic_length",
)
The code is Ok(
    "processed",
)
The code is Ok(
    "basic_length",
)
The code is Ok(
    "bias",
)
The code is Ok(
    "delta = 0",
)
The code is Ok(
    "0",
)
The code is Ok(
    "delta",
)
The code is Ok(
    "processed += 1",
)
The code is Ok(
    "1",
)
The code is Ok(
    "processed",
)
The code is Ok(
    "delta += 1",
)
The code is Ok(
    "1",
)
The code is Ok(
    "delta",
)
The code is Ok(
    "code_point += 1",
)
The code is Ok(
    "1",
)
The code is Ok(
    "code_point",
)
The code is Ok(
    "while processed < input_length {\n        // All code points < code_point have been handled already.\n        // Find the next larger one.\n        let min_code_point = input\n            .clone()\n            .map(|c| c as u32)\n            .filter(|&c| c >= code_point)\n            .min()\n            .unwrap();\n        // Increase delta to advance the decoder’s <code_point,i> state to <min_code_point,0>\n        if C::EXTERNAL_CALLER {\n            let product = (min_code_point - code_point)\n                .checked_mul(processed + 1)\n                .ok_or(PunycodeEncodeError::Overflow)?;\n            delta = delta\n                .checked_add(product)\n                .ok_or(PunycodeEncodeError::Overflow)?;\n        } else {\n            delta += (min_code_point - code_point) * (processed + 1);\n        }\n        code_point = min_code_point;\n        for c in input.clone() {\n            let c = c as u32;\n            if c < code_point {\n                if C::EXTERNAL_CALLER {\n                    delta = delta.checked_add(1).ok_or(PunycodeEncodeError::Overflow)?;\n                } else {\n                    delta += 1;\n                }\n            }\n            if c == code_point {\n                // Represent delta as a generalized variable-length integer:\n                let mut q = delta;\n                let mut k = BASE;\n                loop {\n                    let t = if k <= bias {\n                        T_MIN\n                    } else if k >= bias + T_MAX {\n                        T_MAX\n                    } else {\n                        k - bias\n                    };\n                    if q < t {\n                        break;\n                    }\n                    let value = t + ((q - t) % (BASE - t));\n                    output.write_char(value_to_digit(value))?;\n                    q = (q - t) / (BASE - t);\n                    k += BASE;\n                }\n                output.write_char(value_to_digit(q))?;\n                bias = adapt(delta, processed + 1, processed == basic_length);\n                delta = 0;\n                processed += 1;\n            }\n        }\n        delta += 1;\n        code_point += 1;\n    }",
)
The code is Ok(
    "Ok(())",
)
resolved new call Call { call_expr: HirId(DefId(0:119 ~ idna[bc6b]::punycode::encode_into).690), call_expr_span: idna/src/punycode.rs:454:5: 454:11 (#0), caller: Some(DefId(0:119 ~ idna[bc6b]::punycode::encode_into)), caller_span: None, callee: DefId(1:45569 ~ core[f118]::result::Result::Ok::{constructor#0}), callee_span: idna/src/punycode.rs:454:5: 454:7 (#0), callee_path: "core::prelude::v1::Ok", constraint_depth: 0 }
The code is Ok(
    "Ok",
)
The code is Ok(
    "()",
)
The code is Ok(
    "{\n    match value {\n        0..=25 => (value as u8 + b'a') as char,       // a..z\n        26..=35 => (value as u8 - 26 + b'0') as char, // 0..9\n        _ => panic!(),\n    }\n}",
)
The code is Ok(
    "match value {\n        0..=25 => (value as u8 + b'a') as char,       // a..z\n        26..=35 => (value as u8 - 26 + b'0') as char, // 0..9\n        _ => panic!(),\n    }",
)
The code is Ok(
    "value",
)
The code is Ok(
    "0",
)
The code is Ok(
    "25",
)
The code is Ok(
    "(value as u8 + b'a') as char",
)
The code is Ok(
    "(value as u8 + b'a')",
)
The code is Ok(
    "value as u8",
)
The code is Ok(
    "value",
)
The code is Ok(
    "b'a'",
)
The code is Ok(
    "26",
)
The code is Ok(
    "35",
)
The code is Ok(
    "(value as u8 - 26 + b'0') as char",
)
The code is Ok(
    "(value as u8 - 26 + b'0')",
)
The code is Ok(
    "value as u8 - 26",
)
The code is Ok(
    "value as u8",
)
The code is Ok(
    "value",
)
The code is Ok(
    "26",
)
The code is Ok(
    "b'0'",
)
The code is Ok(
    "$crate::panicking::panic(\"explicit panic\")",
)
resolved new call Call { call_expr: HirId(DefId(0:125 ~ idna[bc6b]::punycode::value_to_digit).38), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:26:9: 26:51 (#32), caller: Some(DefId(0:125 ~ idna[bc6b]::punycode::value_to_digit)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:26:9: 26:33 (#32), callee_path: "core::panicking::panic", constraint_depth: 1 }
The code is Ok(
    "$crate::panicking::panic",
)
The code is Ok(
    "\"explicit panic\"",
)
The code is Ok(
    "2000",
)
The code is Ok(
    "1000",
)
The code is Ok(
    "{\n    let mut accu = 0u128;\n    let mut b = 0u8;\n    while b < 128 {\n        if (b >= b'A') && (b <= b'Z') {\n            accu |= 1u128 << b;\n        }\n        b += 1;\n    }\n    accu\n}",
)
The code is Ok(
    "0u128",
)
The code is Ok(
    "0u8",
)
The code is Ok(
    "while b < 128 {\n        if (b >= b'A') && (b <= b'Z') {\n            accu |= 1u128 << b;\n        }\n        b += 1;\n    }",
)
The code is Ok(
    "while b < 128 {\n        if (b >= b'A') && (b <= b'Z') {\n            accu |= 1u128 << b;\n        }\n        b += 1;\n    }",
)
The code is Ok(
    "b < 128",
)
The code is Ok(
    "b",
)
The code is Ok(
    "128",
)
The code is Ok(
    "if (b >= b'A') && (b <= b'Z') {\n            accu |= 1u128 << b;\n        }",
)
The code is Ok(
    "(b >= b'A') && (b <= b'Z')",
)
The code is Ok(
    "(b >= b'A')",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'A'",
)
The code is Ok(
    "(b <= b'Z')",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'Z'",
)
The code is Ok(
    "accu |= 1u128 << b",
)
The code is Ok(
    "1u128 << b",
)
The code is Ok(
    "1u128",
)
The code is Ok(
    "b",
)
The code is Ok(
    "accu",
)
The code is Ok(
    "b += 1",
)
The code is Ok(
    "1",
)
The code is Ok(
    "b",
)
The code is Ok(
    "while b < 128 {\n        if (b >= b'A') && (b <= b'Z') {\n            accu |= 1u128 << b;\n        }\n        b += 1;\n    }",
)
The code is Ok(
    "accu",
)
The code is Ok(
    "upper_case_mask()",
)
resolved new call Call { call_expr: HirId(DefId(0:138 ~ idna[bc6b]::uts46::UPPER_CASE_MASK).3), call_expr_span: idna/src/uts46.rs:69:31: 69:48 (#0), caller: None, caller_span: None, callee: DefId(0:137 ~ idna[bc6b]::uts46::upper_case_mask), callee_span: idna/src/uts46.rs:69:31: 69:46 (#0), callee_path: "uts46::upper_case_mask", constraint_depth: 0 }
The code is Ok(
    "upper_case_mask",
)
The code is Ok(
    "{\n    let mut accu = 0u128;\n    let mut b = 0u8;\n    while b < 128 {\n        if (b <= b' ') || (b == 0x7F) {\n            accu |= 1u128 << b;\n        }\n        b += 1;\n    }\n    accu\n}",
)
The code is Ok(
    "0u128",
)
The code is Ok(
    "0u8",
)
The code is Ok(
    "while b < 128 {\n        if (b <= b' ') || (b == 0x7F) {\n            accu |= 1u128 << b;\n        }\n        b += 1;\n    }",
)
The code is Ok(
    "while b < 128 {\n        if (b <= b' ') || (b == 0x7F) {\n            accu |= 1u128 << b;\n        }\n        b += 1;\n    }",
)
The code is Ok(
    "b < 128",
)
The code is Ok(
    "b",
)
The code is Ok(
    "128",
)
The code is Ok(
    "if (b <= b' ') || (b == 0x7F) {\n            accu |= 1u128 << b;\n        }",
)
The code is Ok(
    "(b <= b' ') || (b == 0x7F)",
)
The code is Ok(
    "(b <= b' ')",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b' '",
)
The code is Ok(
    "(b == 0x7F)",
)
The code is Ok(
    "b",
)
The code is Ok(
    "0x7F",
)
The code is Ok(
    "accu |= 1u128 << b",
)
The code is Ok(
    "1u128 << b",
)
The code is Ok(
    "1u128",
)
The code is Ok(
    "b",
)
The code is Ok(
    "accu",
)
The code is Ok(
    "b += 1",
)
The code is Ok(
    "1",
)
The code is Ok(
    "b",
)
The code is Ok(
    "while b < 128 {\n        if (b <= b' ') || (b == 0x7F) {\n            accu |= 1u128 << b;\n        }\n        b += 1;\n    }",
)
The code is Ok(
    "accu",
)
The code is Ok(
    "glyphless_mask()",
)
resolved new call Call { call_expr: HirId(DefId(0:140 ~ idna[bc6b]::uts46::GLYPHLESS_MASK).3), call_expr_span: idna/src/uts46.rs:85:30: 85:46 (#0), caller: None, caller_span: None, callee: DefId(0:139 ~ idna[bc6b]::uts46::glyphless_mask), callee_span: idna/src/uts46.rs:85:30: 85:44 (#0), callee_path: "uts46::glyphless_mask", constraint_depth: 0 }
The code is Ok(
    "glyphless_mask",
)
The code is Ok(
    "1 << b'.'",
)
The code is Ok(
    "1",
)
The code is Ok(
    "b'.'",
)
The code is Ok(
    "{\n    let mut accu = 0u128;\n    let mut b = 0u8;\n    while b < 128 {\n        if !((b >= b'a' && b <= b'z') || (b >= b'0' && b <= b'9') || b == b'-' || b == b'.') {\n            accu |= 1u128 << b;\n        }\n        b += 1;\n    }\n    accu\n}",
)
The code is Ok(
    "0u128",
)
The code is Ok(
    "0u8",
)
The code is Ok(
    "while b < 128 {\n        if !((b >= b'a' && b <= b'z') || (b >= b'0' && b <= b'9') || b == b'-' || b == b'.') {\n            accu |= 1u128 << b;\n        }\n        b += 1;\n    }",
)
The code is Ok(
    "while b < 128 {\n        if !((b >= b'a' && b <= b'z') || (b >= b'0' && b <= b'9') || b == b'-' || b == b'.') {\n            accu |= 1u128 << b;\n        }\n        b += 1;\n    }",
)
The code is Ok(
    "b < 128",
)
The code is Ok(
    "b",
)
The code is Ok(
    "128",
)
The code is Ok(
    "if !((b >= b'a' && b <= b'z') || (b >= b'0' && b <= b'9') || b == b'-' || b == b'.') {\n            accu |= 1u128 << b;\n        }",
)
The code is Ok(
    "!((b >= b'a' && b <= b'z') || (b >= b'0' && b <= b'9') || b == b'-' || b == b'.')",
)
The code is Ok(
    "((b >= b'a' && b <= b'z') || (b >= b'0' && b <= b'9') || b == b'-' || b == b'.')",
)
The code is Ok(
    "(b >= b'a' && b <= b'z') || (b >= b'0' && b <= b'9') || b == b'-'",
)
The code is Ok(
    "(b >= b'a' && b <= b'z') || (b >= b'0' && b <= b'9')",
)
The code is Ok(
    "(b >= b'a' && b <= b'z')",
)
The code is Ok(
    "b >= b'a'",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'a'",
)
The code is Ok(
    "b <= b'z'",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'z'",
)
The code is Ok(
    "(b >= b'0' && b <= b'9')",
)
The code is Ok(
    "b >= b'0'",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'0'",
)
The code is Ok(
    "b <= b'9'",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'9'",
)
The code is Ok(
    "b == b'-'",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'-'",
)
The code is Ok(
    "b == b'.'",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'.'",
)
The code is Ok(
    "accu |= 1u128 << b",
)
The code is Ok(
    "1u128 << b",
)
The code is Ok(
    "1u128",
)
The code is Ok(
    "b",
)
The code is Ok(
    "accu",
)
The code is Ok(
    "b += 1",
)
The code is Ok(
    "1",
)
The code is Ok(
    "b",
)
The code is Ok(
    "while b < 128 {\n        if !((b >= b'a' && b <= b'z') || (b >= b'0' && b <= b'9') || b == b'-' || b == b'.') {\n            accu |= 1u128 << b;\n        }\n        b += 1;\n    }",
)
The code is Ok(
    "accu",
)
The code is Ok(
    "((b'-' as u32) << 24) | ((b'-' as u32) << 16) | ((b'N' as u32) << 8) | b'X' as u32",
)
The code is Ok(
    "((b'-' as u32) << 24) | ((b'-' as u32) << 16) | ((b'N' as u32) << 8)",
)
The code is Ok(
    "((b'-' as u32) << 24) | ((b'-' as u32) << 16)",
)
The code is Ok(
    "((b'-' as u32) << 24)",
)
The code is Ok(
    "(b'-' as u32)",
)
The code is Ok(
    "b'-'",
)
The code is Ok(
    "24",
)
The code is Ok(
    "((b'-' as u32) << 16)",
)
The code is Ok(
    "(b'-' as u32)",
)
The code is Ok(
    "b'-'",
)
The code is Ok(
    "16",
)
The code is Ok(
    "((b'N' as u32) << 8)",
)
The code is Ok(
    "(b'N' as u32)",
)
The code is Ok(
    "b'N'",
)
The code is Ok(
    "8",
)
The code is Ok(
    "b'X' as u32",
)
The code is Ok(
    "b'X'",
)
The code is Ok(
    "(0xFF << 24) | (0xFF << 16) | (0xDF << 8) | 0xDF",
)
The code is Ok(
    "(0xFF << 24) | (0xFF << 16) | (0xDF << 8)",
)
The code is Ok(
    "(0xFF << 24) | (0xFF << 16)",
)
The code is Ok(
    "(0xFF << 24)",
)
The code is Ok(
    "0xFF",
)
The code is Ok(
    "24",
)
The code is Ok(
    "(0xFF << 16)",
)
The code is Ok(
    "0xFF",
)
The code is Ok(
    "16",
)
The code is Ok(
    "(0xDF << 8)",
)
The code is Ok(
    "0xDF",
)
The code is Ok(
    "8",
)
The code is Ok(
    "0xDF",
)
The code is Ok(
    "{\n    sink.write_str(\"xn--\")?;\n    crate::punycode::encode_into::<_, _, InternalCaller>(label.iter().copied(), sink)?;\n    Ok(())\n}",
)
The code is Ok(
    "sink.write_str(\"xn--\")?",
)
into Match call
The code is Ok(
    "sink.write_str(\"xn--\")?",
)
LangItem path: idna/src/uts46.rs:112:5: 112:28 (#269)
The code is Ok(
    "sink.write_str(\"xn--\")?",
)
The code is Ok(
    "sink.write_str(\"xn--\")",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:145 ~ idna[bc6b]::uts46::write_punycode_label).6),
    call_expr_span: idna/src/uts46.rs:112:5: 112:27 (#0),
    caller: Some(
        DefId(0:145 ~ idna[bc6b]::uts46::write_punycode_label),
    ),
    caller_span: None,
    callee: DefId(1:10604 ~ core[f118]::fmt::Write::write_str),
    callee_span: idna/src/uts46.rs:112:5: 112:27 (#0),
    callee_path: "core::fmt::Write::write_str",
    constraint_depth: 0,
}
The code is Ok(
    "sink",
)
The code is Ok(
    "\"xn--\"",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(\"xn--\")?",
)
LangItem path: idna/src/uts46.rs:112:27: 112:28 (#270)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(\"xn--\")?",
)
The code is Ok(
    "crate::punycode::encode_into::<_, _, InternalCaller>(label.iter().copied(), sink)?",
)
into Match call
The code is Ok(
    "crate::punycode::encode_into::<_, _, InternalCaller>(label.iter().copied(), sink)?",
)
LangItem path: idna/src/uts46.rs:113:5: 113:87 (#271)
The code is Ok(
    "crate::punycode::encode_into::<_, _, InternalCaller>(label.iter().copied(), sink)?",
)
The code is Ok(
    "crate::punycode::encode_into::<_, _, InternalCaller>(label.iter().copied(), sink)",
)
resolved new call Call { call_expr: HirId(DefId(0:145 ~ idna[bc6b]::uts46::write_punycode_label).30), call_expr_span: idna/src/uts46.rs:113:5: 113:86 (#0), caller: Some(DefId(0:145 ~ idna[bc6b]::uts46::write_punycode_label)), caller_span: None, callee: DefId(0:119 ~ idna[bc6b]::punycode::encode_into), callee_span: idna/src/uts46.rs:113:5: 113:57 (#0), callee_path: "punycode::encode_into", constraint_depth: 0 }
The code is Ok(
    "crate::punycode::encode_into::<_, _, InternalCaller>",
)
The code is Ok(
    "label.iter().copied()",
)
The code is Ok(
    "label.iter()",
)
The code is Ok(
    "label",
)
The code is Ok(
    "sink",
)
The code is Ok(
    "?",
)
The code is Ok(
    "crate::punycode::encode_into::<_, _, InternalCaller>(label.iter().copied(), sink)?",
)
LangItem path: idna/src/uts46.rs:113:86: 113:87 (#272)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "crate::punycode::encode_into::<_, _, InternalCaller>(label.iter().copied(), sink)?",
)
The code is Ok(
    "Ok(())",
)
resolved new call Call { call_expr: HirId(DefId(0:145 ~ idna[bc6b]::uts46::write_punycode_label).65), call_expr_span: idna/src/uts46.rs:114:5: 114:11 (#0), caller: Some(DefId(0:145 ~ idna[bc6b]::uts46::write_punycode_label)), caller_span: None, callee: DefId(1:45569 ~ core[f118]::result::Result::Ok::{constructor#0}), callee_span: idna/src/uts46.rs:114:5: 114:7 (#0), callee_path: "core::prelude::v1::Ok", constraint_depth: 0 }
The code is Ok(
    "Ok",
)
The code is Ok(
    "()",
)
The code is Ok(
    "{\n    if slice.len() < 4 {\n        return false;\n    }\n    // Sadly, the optimizer doesn't figure out that more idiomatic code\n    // should compile to masking on 32-bit value.\n    let a = slice[0];\n    let b = slice[1];\n    let c = slice[2];\n    let d = slice[3];\n    let u = (u32::from(d) << 24) | (u32::from(c) << 16) | (u32::from(b) << 8) | u32::from(a);\n    (u & PUNYCODE_PREFIX_MASK) == PUNYCODE_PREFIX\n}",
)
The code is Ok(
    "if slice.len() < 4 {\n        return false;\n    }",
)
The code is Ok(
    "slice.len() < 4",
)
The code is Ok(
    "slice.len()",
)
The code is Ok(
    "slice",
)
The code is Ok(
    "4",
)
The code is Ok(
    "return false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "slice[0]",
)
The code is Ok(
    "slice",
)
The code is Ok(
    "0",
)
The code is Ok(
    "slice[1]",
)
The code is Ok(
    "slice",
)
The code is Ok(
    "1",
)
The code is Ok(
    "slice[2]",
)
The code is Ok(
    "slice",
)
The code is Ok(
    "2",
)
The code is Ok(
    "slice[3]",
)
The code is Ok(
    "slice",
)
The code is Ok(
    "3",
)
The code is Ok(
    "(u32::from(d) << 24) | (u32::from(c) << 16) | (u32::from(b) << 8) | u32::from(a)",
)
The code is Ok(
    "(u32::from(d) << 24) | (u32::from(c) << 16) | (u32::from(b) << 8)",
)
The code is Ok(
    "(u32::from(d) << 24) | (u32::from(c) << 16)",
)
The code is Ok(
    "(u32::from(d) << 24)",
)
The code is Ok(
    "u32::from(d)",
)
The code is Ok(
    "u32::from",
)
The code is Ok(
    "d",
)
The code is Ok(
    "24",
)
The code is Ok(
    "(u32::from(c) << 16)",
)
The code is Ok(
    "u32::from(c)",
)
The code is Ok(
    "u32::from",
)
The code is Ok(
    "c",
)
The code is Ok(
    "16",
)
The code is Ok(
    "(u32::from(b) << 8)",
)
The code is Ok(
    "u32::from(b)",
)
The code is Ok(
    "u32::from",
)
The code is Ok(
    "b",
)
The code is Ok(
    "8",
)
The code is Ok(
    "u32::from(a)",
)
The code is Ok(
    "u32::from",
)
The code is Ok(
    "a",
)
The code is Ok(
    "(u & PUNYCODE_PREFIX_MASK) == PUNYCODE_PREFIX",
)
The code is Ok(
    "(u & PUNYCODE_PREFIX_MASK)",
)
The code is Ok(
    "u",
)
The code is Ok(
    "PUNYCODE_PREFIX_MASK",
)
The code is Ok(
    "PUNYCODE_PREFIX",
)
The code is Ok(
    "{\n    u.wrapping_sub(start) <= (end - start)\n}",
)
The code is Ok(
    "u.wrapping_sub(start) <= (end - start)",
)
The code is Ok(
    "u.wrapping_sub(start)",
)
The code is Ok(
    "u",
)
The code is Ok(
    "start",
)
The code is Ok(
    "(end - start)",
)
The code is Ok(
    "end",
)
The code is Ok(
    "start",
)
The code is Ok(
    "{\n    u32::from(c).wrapping_sub(u32::from(start)) <= (u32::from(end) - u32::from(start))\n}",
)
The code is Ok(
    "u32::from(c).wrapping_sub(u32::from(start)) <= (u32::from(end) - u32::from(start))",
)
The code is Ok(
    "u32::from(c).wrapping_sub(u32::from(start))",
)
The code is Ok(
    "u32::from(c)",
)
The code is Ok(
    "u32::from",
)
The code is Ok(
    "c",
)
The code is Ok(
    "u32::from(start)",
)
The code is Ok(
    "u32::from",
)
The code is Ok(
    "start",
)
The code is Ok(
    "(u32::from(end) - u32::from(start))",
)
The code is Ok(
    "u32::from(end)",
)
The code is Ok(
    "u32::from",
)
The code is Ok(
    "end",
)
The code is Ok(
    "u32::from(start)",
)
The code is Ok(
    "u32::from",
)
The code is Ok(
    "start",
)
The code is Ok(
    "{\n    // XXX if we aren't performing _CheckHyphens_, this could\n    // check for \"xn--\" and pass through YouTube CDN node names.\n    if label.len() >= 4 && label[2] == b'-' && label[3] == b'-' {\n        return false;\n    }\n    if let Some((&first, tail)) = label.split_first() {\n        // We need to check the first and last character\n        // more strictly in case this turns out to be a\n        // label in a bidi domain name. This has the side\n        // effect that this function only accepts labels\n        // that also conform to the STD3 rules.\n        //\n        // XXX: If we are in the fail-fast mode (i.e. we don't need\n        // to be able to overwrite anything with U+FFFD), we could\n        // merely record that we've seen a digit here and error out\n        // if we later discover that the domain name is a bidi\n        // domain name.\n        if !in_inclusive_range8(first, b'a', b'z') {\n            return false;\n        }\n        for &b in tail {\n            // If we used LDH_MASK, we'd have to check\n            // the bytes for the ASCII range anyhow.\n            if in_inclusive_range8(b, b'a', b'z') {\n                continue;\n            }\n            if in_inclusive_range8(b, b'0', b'9') {\n                continue;\n            }\n            if b == b'-' {\n                continue;\n            }\n            return false;\n        }\n        label.last() != Some(&b'-')\n    } else {\n        // empty\n        true\n    }\n}",
)
The code is Ok(
    "if label.len() >= 4 && label[2] == b'-' && label[3] == b'-' {\n        return false;\n    }",
)
The code is Ok(
    "label.len() >= 4 && label[2] == b'-' && label[3] == b'-'",
)
The code is Ok(
    "label.len() >= 4 && label[2] == b'-'",
)
The code is Ok(
    "label.len() >= 4",
)
The code is Ok(
    "label.len()",
)
The code is Ok(
    "label",
)
The code is Ok(
    "4",
)
The code is Ok(
    "label[2] == b'-'",
)
The code is Ok(
    "label[2]",
)
The code is Ok(
    "label",
)
The code is Ok(
    "2",
)
The code is Ok(
    "b'-'",
)
The code is Ok(
    "label[3] == b'-'",
)
The code is Ok(
    "label[3]",
)
The code is Ok(
    "label",
)
The code is Ok(
    "3",
)
The code is Ok(
    "b'-'",
)
The code is Ok(
    "return false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "if let Some((&first, tail)) = label.split_first() {\n        // We need to check the first and last character\n        // more strictly in case this turns out to be a\n        // label in a bidi domain name. This has the side\n        // effect that this function only accepts labels\n        // that also conform to the STD3 rules.\n        //\n        // XXX: If we are in the fail-fast mode (i.e. we don't need\n        // to be able to overwrite anything with U+FFFD), we could\n        // merely record that we've seen a digit here and error out\n        // if we later discover that the domain name is a bidi\n        // domain name.\n        if !in_inclusive_range8(first, b'a', b'z') {\n            return false;\n        }\n        for &b in tail {\n            // If we used LDH_MASK, we'd have to check\n            // the bytes for the ASCII range anyhow.\n            if in_inclusive_range8(b, b'a', b'z') {\n                continue;\n            }\n            if in_inclusive_range8(b, b'0', b'9') {\n                continue;\n            }\n            if b == b'-' {\n                continue;\n            }\n            return false;\n        }\n        label.last() != Some(&b'-')\n    } else {\n        // empty\n        true\n    }",
)
The code is Ok(
    "label.split_first()",
)
The code is Ok(
    "label",
)
The code is Ok(
    "if !in_inclusive_range8(first, b'a', b'z') {\n            return false;\n        }",
)
The code is Ok(
    "!in_inclusive_range8(first, b'a', b'z')",
)
The code is Ok(
    "in_inclusive_range8(first, b'a', b'z')",
)
resolved new call Call { call_expr: HirId(DefId(0:150 ~ idna[bc6b]::uts46::is_passthrough_ascii_label).45), call_expr_span: idna/src/uts46.rs:161:13: 161:51 (#0), caller: Some(DefId(0:150 ~ idna[bc6b]::uts46::is_passthrough_ascii_label)), caller_span: None, callee: DefId(0:148 ~ idna[bc6b]::uts46::in_inclusive_range8), callee_span: idna/src/uts46.rs:161:13: 161:32 (#0), callee_path: "uts46::in_inclusive_range8", constraint_depth: 1 }
The code is Ok(
    "in_inclusive_range8",
)
The code is Ok(
    "first",
)
The code is Ok(
    "b'a'",
)
The code is Ok(
    "b'z'",
)
The code is Ok(
    "return false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "for &b in tail {\n            // If we used LDH_MASK, we'd have to check\n            // the bytes for the ASCII range anyhow.\n            if in_inclusive_range8(b, b'a', b'z') {\n                continue;\n            }\n            if in_inclusive_range8(b, b'0', b'9') {\n                continue;\n            }\n            if b == b'-' {\n                continue;\n            }\n            return false;\n        }",
)
The code is Ok(
    "for &b in tail {\n            // If we used LDH_MASK, we'd have to check\n            // the bytes for the ASCII range anyhow.\n            if in_inclusive_range8(b, b'a', b'z') {\n                continue;\n            }\n            if in_inclusive_range8(b, b'0', b'9') {\n                continue;\n            }\n            if b == b'-' {\n                continue;\n            }\n            return false;\n        }",
)
into Match call
The code is Ok(
    "tail",
)
LangItem path: idna/src/uts46.rs:164:19: 164:23 (#277)
The code is Ok(
    "tail",
)
The code is Ok(
    "tail",
)
The code is Ok(
    "for &b in tail {\n            // If we used LDH_MASK, we'd have to check\n            // the bytes for the ASCII range anyhow.\n            if in_inclusive_range8(b, b'a', b'z') {\n                continue;\n            }\n            if in_inclusive_range8(b, b'0', b'9') {\n                continue;\n            }\n            if b == b'-' {\n                continue;\n            }\n            return false;\n        }",
)
The code is Ok(
    "tail",
)
into Match call
is inner Match
The code is Ok(
    "tail",
)
LangItem path: idna/src/uts46.rs:164:19: 164:23 (#277)
The code is Ok(
    "tail",
)
The code is Ok(
    "tail",
)
The code is Ok(
    "tail",
)
The code is Ok(
    "for &b in tail {\n            // If we used LDH_MASK, we'd have to check\n            // the bytes for the ASCII range anyhow.\n            if in_inclusive_range8(b, b'a', b'z') {\n                continue;\n            }\n            if in_inclusive_range8(b, b'0', b'9') {\n                continue;\n            }\n            if b == b'-' {\n                continue;\n            }\n            return false;\n        }",
)
The code is Ok(
    "{\n            // If we used LDH_MASK, we'd have to check\n            // the bytes for the ASCII range anyhow.\n            if in_inclusive_range8(b, b'a', b'z') {\n                continue;\n            }\n            if in_inclusive_range8(b, b'0', b'9') {\n                continue;\n            }\n            if b == b'-' {\n                continue;\n            }\n            return false;\n        }",
)
The code is Ok(
    "if in_inclusive_range8(b, b'a', b'z') {\n                continue;\n            }",
)
The code is Ok(
    "in_inclusive_range8(b, b'a', b'z')",
)
resolved new call Call { call_expr: HirId(DefId(0:150 ~ idna[bc6b]::uts46::is_passthrough_ascii_label).70), call_expr_span: idna/src/uts46.rs:167:16: 167:50 (#0), caller: Some(DefId(0:150 ~ idna[bc6b]::uts46::is_passthrough_ascii_label)), caller_span: None, callee: DefId(0:148 ~ idna[bc6b]::uts46::in_inclusive_range8), callee_span: idna/src/uts46.rs:167:16: 167:35 (#0), callee_path: "uts46::in_inclusive_range8", constraint_depth: 2 }
The code is Ok(
    "in_inclusive_range8",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'a'",
)
The code is Ok(
    "b'z'",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "if in_inclusive_range8(b, b'0', b'9') {\n                continue;\n            }",
)
The code is Ok(
    "in_inclusive_range8(b, b'0', b'9')",
)
resolved new call Call { call_expr: HirId(DefId(0:150 ~ idna[bc6b]::uts46::is_passthrough_ascii_label).84), call_expr_span: idna/src/uts46.rs:170:16: 170:50 (#0), caller: Some(DefId(0:150 ~ idna[bc6b]::uts46::is_passthrough_ascii_label)), caller_span: None, callee: DefId(0:148 ~ idna[bc6b]::uts46::in_inclusive_range8), callee_span: idna/src/uts46.rs:170:16: 170:35 (#0), callee_path: "uts46::in_inclusive_range8", constraint_depth: 2 }
The code is Ok(
    "in_inclusive_range8",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'0'",
)
The code is Ok(
    "b'9'",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "if b == b'-' {\n                continue;\n            }",
)
The code is Ok(
    "b == b'-'",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'-'",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "return false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "label.last() != Some(&b'-')",
)
The code is Ok(
    "label.last()",
)
The code is Ok(
    "label",
)
The code is Ok(
    "Some(&b'-')",
)
resolved new call Call { call_expr: HirId(DefId(0:150 ~ idna[bc6b]::uts46::is_passthrough_ascii_label).134), call_expr_span: idna/src/uts46.rs:178:25: 178:36 (#0), caller: Some(DefId(0:150 ~ idna[bc6b]::uts46::is_passthrough_ascii_label)), caller_span: None, callee: DefId(1:45302 ~ core[f118]::option::Option::Some::{constructor#0}), callee_span: idna/src/uts46.rs:178:25: 178:29 (#0), callee_path: "core::prelude::v1::Some", constraint_depth: 1 }
The code is Ok(
    "Some",
)
The code is Ok(
    "&b'-'",
)
The code is Ok(
    "b'-'",
)
The code is Ok(
    "true",
)
The code is Ok(
    "{\n    if let Some(pos) = label.iter().position(|b| !b.is_ascii()) {\n        if pos == 0 {\n            // First is non-ASCII\n            (&[], label)\n        } else {\n            // Leave one ASCII character in the suffix\n            // in case it's a letter that a combining\n            // character combines with.\n            let (head, tail) = label.split_at(pos - 1);\n            (head, tail)\n        }\n    } else {\n        // All ASCII\n        (label, &[])\n    }\n}",
)
The code is Ok(
    "if let Some(pos) = label.iter().position(|b| !b.is_ascii()) {\n        if pos == 0 {\n            // First is non-ASCII\n            (&[], label)\n        } else {\n            // Leave one ASCII character in the suffix\n            // in case it's a letter that a combining\n            // character combines with.\n            let (head, tail) = label.split_at(pos - 1);\n            (head, tail)\n        }\n    } else {\n        // All ASCII\n        (label, &[])\n    }",
)
The code is Ok(
    "label.iter().position(|b| !b.is_ascii())",
)
The code is Ok(
    "label.iter()",
)
The code is Ok(
    "label",
)
The code is Ok(
    "|b| !b.is_ascii()",
)
The code is Ok(
    "!b.is_ascii()",
)
The code is Ok(
    "b.is_ascii()",
)
The code is Ok(
    "b",
)
The code is Ok(
    "if pos == 0 {\n            // First is non-ASCII\n            (&[], label)\n        } else {\n            // Leave one ASCII character in the suffix\n            // in case it's a letter that a combining\n            // character combines with.\n            let (head, tail) = label.split_at(pos - 1);\n            (head, tail)\n        }",
)
The code is Ok(
    "pos == 0",
)
The code is Ok(
    "pos",
)
The code is Ok(
    "0",
)
The code is Ok(
    "(&[], label)",
)
The code is Ok(
    "&[]",
)
The code is Ok(
    "[]",
)
The code is Ok(
    "label",
)
The code is Ok(
    "label.split_at(pos - 1)",
)
The code is Ok(
    "label",
)
The code is Ok(
    "pos - 1",
)
The code is Ok(
    "pos",
)
The code is Ok(
    "1",
)
The code is Ok(
    "(head, tail)",
)
The code is Ok(
    "head",
)
The code is Ok(
    "tail",
)
The code is Ok(
    "(label, &[])",
)
The code is Ok(
    "label",
)
The code is Ok(
    "&[]",
)
The code is Ok(
    "[]",
)
The code is Ok(
    "{\n    if let Some(shifted) = 1u128.checked_shl(u32::from(c)) {\n        if (deny_list & shifted) == 0 {\n            c\n        } else {\n            '\\u{FFFD}'\n        }\n    } else {\n        c\n    }\n}",
)
The code is Ok(
    "if let Some(shifted) = 1u128.checked_shl(u32::from(c)) {\n        if (deny_list & shifted) == 0 {\n            c\n        } else {\n            '\\u{FFFD}'\n        }\n    } else {\n        c\n    }",
)
The code is Ok(
    "1u128.checked_shl(u32::from(c))",
)
The code is Ok(
    "1u128",
)
The code is Ok(
    "u32::from(c)",
)
The code is Ok(
    "u32::from",
)
The code is Ok(
    "c",
)
The code is Ok(
    "if (deny_list & shifted) == 0 {\n            c\n        } else {\n            '\\u{FFFD}'\n        }",
)
The code is Ok(
    "(deny_list & shifted) == 0",
)
The code is Ok(
    "(deny_list & shifted)",
)
The code is Ok(
    "deny_list",
)
The code is Ok(
    "shifted",
)
The code is Ok(
    "0",
)
The code is Ok(
    "c",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "c",
)
The code is Ok(
    "{\n    if (deny_list & (1u128 << b)) == 0 {\n        return char::from(b);\n    }\n    if in_inclusive_range8(b, b'A', b'Z') {\n        return char::from(b + 0x20);\n    }\n    '\\u{FFFD}'\n}",
)
The code is Ok(
    "if (deny_list & (1u128 << b)) == 0 {\n        return char::from(b);\n    }",
)
The code is Ok(
    "(deny_list & (1u128 << b)) == 0",
)
The code is Ok(
    "(deny_list & (1u128 << b))",
)
The code is Ok(
    "deny_list",
)
The code is Ok(
    "(1u128 << b)",
)
The code is Ok(
    "1u128",
)
The code is Ok(
    "b",
)
The code is Ok(
    "0",
)
The code is Ok(
    "return char::from(b)",
)
The code is Ok(
    "char::from(b)",
)
The code is Ok(
    "char::from",
)
The code is Ok(
    "b",
)
The code is Ok(
    "if in_inclusive_range8(b, b'A', b'Z') {\n        return char::from(b + 0x20);\n    }",
)
The code is Ok(
    "in_inclusive_range8(b, b'A', b'Z')",
)
resolved new call Call { call_expr: HirId(DefId(0:154 ~ idna[bc6b]::uts46::apply_ascii_deny_list_to_potentially_upper_case_ascii).29), call_expr_span: idna/src/uts46.rs:224:8: 224:42 (#0), caller: Some(DefId(0:154 ~ idna[bc6b]::uts46::apply_ascii_deny_list_to_potentially_upper_case_ascii)), caller_span: None, callee: DefId(0:148 ~ idna[bc6b]::uts46::in_inclusive_range8), callee_span: idna/src/uts46.rs:224:8: 224:27 (#0), callee_path: "uts46::in_inclusive_range8", constraint_depth: 0 }
The code is Ok(
    "in_inclusive_range8",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'A'",
)
The code is Ok(
    "b'Z'",
)
The code is Ok(
    "return char::from(b + 0x20)",
)
The code is Ok(
    "char::from(b + 0x20)",
)
The code is Ok(
    "char::from",
)
The code is Ok(
    "b + 0x20",
)
The code is Ok(
    "b",
)
The code is Ok(
    "0x20",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "{\n    for c in label.iter() {\n        if !c.is_ascii() {\n            return false;\n        }\n    }\n    true\n}",
)
The code is Ok(
    "for c in label.iter() {\n        if !c.is_ascii() {\n            return false;\n        }\n    }",
)
The code is Ok(
    "for c in label.iter() {\n        if !c.is_ascii() {\n            return false;\n        }\n    }",
)
into Match call
The code is Ok(
    "label.iter()",
)
LangItem path: idna/src/uts46.rs:232:14: 232:26 (#287)
The code is Ok(
    "label.iter()",
)
The code is Ok(
    "label.iter()",
)
The code is Ok(
    "label",
)
The code is Ok(
    "for c in label.iter() {\n        if !c.is_ascii() {\n            return false;\n        }\n    }",
)
The code is Ok(
    "label.iter()",
)
into Match call
is inner Match
The code is Ok(
    "label.iter()",
)
LangItem path: idna/src/uts46.rs:232:14: 232:26 (#287)
The code is Ok(
    "label.iter()",
)
The code is Ok(
    "label.iter()",
)
The code is Ok(
    "label.iter()",
)
The code is Ok(
    "for c in label.iter() {\n        if !c.is_ascii() {\n            return false;\n        }\n    }",
)
The code is Ok(
    "{\n        if !c.is_ascii() {\n            return false;\n        }\n    }",
)
The code is Ok(
    "if !c.is_ascii() {\n            return false;\n        }",
)
The code is Ok(
    "!c.is_ascii()",
)
The code is Ok(
    "c.is_ascii()",
)
The code is Ok(
    "c",
)
The code is Ok(
    "return false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "{\n    let mut iter = label.iter().copied();\n    loop {\n        if let Some(c) = iter.next() {\n            if c.is_ascii() {\n                continue;\n            }\n            if c == '\\u{FFFD}' {\n                return PunycodeClassification::Error;\n            }\n            for c in iter {\n                if c == '\\u{FFFD}' {\n                    return PunycodeClassification::Error;\n                }\n            }\n            return PunycodeClassification::Unicode;\n        }\n        return PunycodeClassification::Ascii;\n    }\n}",
)
The code is Ok(
    "label.iter().copied()",
)
The code is Ok(
    "label.iter()",
)
The code is Ok(
    "label",
)
The code is Ok(
    "loop {\n        if let Some(c) = iter.next() {\n            if c.is_ascii() {\n                continue;\n            }\n            if c == '\\u{FFFD}' {\n                return PunycodeClassification::Error;\n            }\n            for c in iter {\n                if c == '\\u{FFFD}' {\n                    return PunycodeClassification::Error;\n                }\n            }\n            return PunycodeClassification::Unicode;\n        }\n        return PunycodeClassification::Ascii;\n    }",
)
The code is Ok(
    "if let Some(c) = iter.next() {\n            if c.is_ascii() {\n                continue;\n            }\n            if c == '\\u{FFFD}' {\n                return PunycodeClassification::Error;\n            }\n            for c in iter {\n                if c == '\\u{FFFD}' {\n                    return PunycodeClassification::Error;\n                }\n            }\n            return PunycodeClassification::Unicode;\n        }",
)
The code is Ok(
    "iter.next()",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "if c.is_ascii() {\n                continue;\n            }",
)
The code is Ok(
    "c.is_ascii()",
)
The code is Ok(
    "c",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "if c == '\\u{FFFD}' {\n                return PunycodeClassification::Error;\n            }",
)
The code is Ok(
    "c == '\\u{FFFD}'",
)
The code is Ok(
    "c",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "return PunycodeClassification::Error",
)
The code is Ok(
    "PunycodeClassification::Error",
)
The code is Ok(
    "for c in iter {\n                if c == '\\u{FFFD}' {\n                    return PunycodeClassification::Error;\n                }\n            }",
)
The code is Ok(
    "for c in iter {\n                if c == '\\u{FFFD}' {\n                    return PunycodeClassification::Error;\n                }\n            }",
)
into Match call
The code is Ok(
    "iter",
)
LangItem path: idna/src/uts46.rs:258:22: 258:26 (#293)
The code is Ok(
    "iter",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "for c in iter {\n                if c == '\\u{FFFD}' {\n                    return PunycodeClassification::Error;\n                }\n            }",
)
The code is Ok(
    "iter",
)
into Match call
is inner Match
The code is Ok(
    "iter",
)
LangItem path: idna/src/uts46.rs:258:22: 258:26 (#293)
The code is Ok(
    "iter",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "for c in iter {\n                if c == '\\u{FFFD}' {\n                    return PunycodeClassification::Error;\n                }\n            }",
)
The code is Ok(
    "{\n                if c == '\\u{FFFD}' {\n                    return PunycodeClassification::Error;\n                }\n            }",
)
The code is Ok(
    "if c == '\\u{FFFD}' {\n                    return PunycodeClassification::Error;\n                }",
)
The code is Ok(
    "c == '\\u{FFFD}'",
)
The code is Ok(
    "c",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "return PunycodeClassification::Error",
)
The code is Ok(
    "PunycodeClassification::Error",
)
The code is Ok(
    "return PunycodeClassification::Unicode",
)
The code is Ok(
    "PunycodeClassification::Unicode",
)
The code is Ok(
    "return PunycodeClassification::Ascii",
)
The code is Ok(
    "PunycodeClassification::Ascii",
)
The code is Ok(
    "{\n    let bytes = domain_name.as_bytes();\n    debug_assert!(bytes.is_ascii());\n    let domain_name_without_trailing_dot = if let Some(without) = bytes.strip_suffix(b\".\") {\n        if !allow_trailing_dot {\n            return false;\n        }\n        without\n    } else {\n        bytes\n    };\n    if domain_name_without_trailing_dot.len() > 253 {\n        return false;\n    }\n    for label in domain_name_without_trailing_dot.split(|b| *b == b'.') {\n        if label.is_empty() {\n            return false;\n        }\n        if label.len() > 63 {\n            return false;\n        }\n    }\n    true\n}",
)
The code is Ok(
    "domain_name.as_bytes()",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "if $crate::cfg!(debug_assertions) {\n            $crate::assert!($($arg)*);\n        }",
)
The code is Ok(
    "$crate::cfg!(debug_assertions)",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "bytes.is_ascii()",
)
The code is Ok(
    "bytes",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
resolved new call Call { call_expr: HirId(DefId(0:166 ~ idna[bc6b]::uts46::verify_dns_length).22), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:335:13: 335:38 (#98), caller: Some(DefId(0:166 ~ idna[bc6b]::uts46::verify_dns_length)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:335:13: 335:13 (#98), callee_path: "core::panicking::panic", constraint_depth: 1 }
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "",
)
The code is Ok(
    "if let Some(without) = bytes.strip_suffix(b\".\") {\n        if !allow_trailing_dot {\n            return false;\n        }\n        without\n    } else {\n        bytes\n    }",
)
The code is Ok(
    "bytes.strip_suffix(b\".\")",
)
The code is Ok(
    "bytes",
)
The code is Ok(
    "b\".\"",
)
The code is Ok(
    "if !allow_trailing_dot {\n            return false;\n        }",
)
The code is Ok(
    "!allow_trailing_dot",
)
The code is Ok(
    "allow_trailing_dot",
)
The code is Ok(
    "return false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "without",
)
The code is Ok(
    "bytes",
)
The code is Ok(
    "if domain_name_without_trailing_dot.len() > 253 {\n        return false;\n    }",
)
The code is Ok(
    "domain_name_without_trailing_dot.len() > 253",
)
The code is Ok(
    "domain_name_without_trailing_dot.len()",
)
The code is Ok(
    "domain_name_without_trailing_dot",
)
The code is Ok(
    "253",
)
The code is Ok(
    "return false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "for label in domain_name_without_trailing_dot.split(|b| *b == b'.') {\n        if label.is_empty() {\n            return false;\n        }\n        if label.len() > 63 {\n            return false;\n        }\n    }",
)
The code is Ok(
    "for label in domain_name_without_trailing_dot.split(|b| *b == b'.') {\n        if label.is_empty() {\n            return false;\n        }\n        if label.len() > 63 {\n            return false;\n        }\n    }",
)
into Match call
The code is Ok(
    "domain_name_without_trailing_dot.split(|b| *b == b'.')",
)
LangItem path: idna/src/uts46.rs:477:18: 477:72 (#313)
The code is Ok(
    "domain_name_without_trailing_dot.split(|b| *b == b'.')",
)
The code is Ok(
    "domain_name_without_trailing_dot.split(|b| *b == b'.')",
)
The code is Ok(
    "domain_name_without_trailing_dot",
)
The code is Ok(
    "|b| *b == b'.'",
)
The code is Ok(
    "*b == b'.'",
)
The code is Ok(
    "*b",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'.'",
)
The code is Ok(
    "for label in domain_name_without_trailing_dot.split(|b| *b == b'.') {\n        if label.is_empty() {\n            return false;\n        }\n        if label.len() > 63 {\n            return false;\n        }\n    }",
)
The code is Ok(
    "domain_name_without_trailing_dot.split(|b| *b == b'.')",
)
into Match call
is inner Match
The code is Ok(
    "domain_name_without_trailing_dot.split(|b| *b == b'.')",
)
LangItem path: idna/src/uts46.rs:477:18: 477:72 (#313)
The code is Ok(
    "domain_name_without_trailing_dot.split(|b| *b == b'.')",
)
The code is Ok(
    "domain_name_without_trailing_dot.split(|b| *b == b'.')",
)
The code is Ok(
    "domain_name_without_trailing_dot.split(|b| *b == b'.')",
)
The code is Ok(
    "for label in domain_name_without_trailing_dot.split(|b| *b == b'.') {\n        if label.is_empty() {\n            return false;\n        }\n        if label.len() > 63 {\n            return false;\n        }\n    }",
)
The code is Ok(
    "{\n        if label.is_empty() {\n            return false;\n        }\n        if label.len() > 63 {\n            return false;\n        }\n    }",
)
The code is Ok(
    "if label.is_empty() {\n            return false;\n        }",
)
The code is Ok(
    "label.is_empty()",
)
The code is Ok(
    "label",
)
The code is Ok(
    "return false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "if label.len() > 63 {\n            return false;\n        }",
)
The code is Ok(
    "label.len() > 63",
)
The code is Ok(
    "label.len()",
)
The code is Ok(
    "label",
)
The code is Ok(
    "63",
)
The code is Ok(
    "return false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "{\n    if let Some(first) = mut_label.first_mut() {\n        if *first == '-' {\n            if fail_fast {\n                return true;\n            }\n            *had_errors = true;\n            *first = '\\u{FFFD}';\n        }\n    }\n    if let Some(last) = mut_label.last_mut() {\n        if *last == '-' {\n            if fail_fast {\n                return true;\n            }\n            *had_errors = true;\n            *last = '\\u{FFFD}';\n        }\n    }\n    if allow_third_fourth {\n        return false;\n    }\n    if mut_label.len() >= 4 && mut_label[2] == '-' && mut_label[3] == '-' {\n        if fail_fast {\n            return true;\n        }\n        *had_errors = true;\n        mut_label[2] = '\\u{FFFD}';\n        mut_label[3] = '\\u{FFFD}';\n    }\n    false\n}",
)
The code is Ok(
    "if let Some(first) = mut_label.first_mut() {\n        if *first == '-' {\n            if fail_fast {\n                return true;\n            }\n            *had_errors = true;\n            *first = '\\u{FFFD}';\n        }\n    }",
)
The code is Ok(
    "mut_label.first_mut()",
)
The code is Ok(
    "mut_label",
)
The code is Ok(
    "if *first == '-' {\n            if fail_fast {\n                return true;\n            }\n            *had_errors = true;\n            *first = '\\u{FFFD}';\n        }",
)
The code is Ok(
    "*first == '-'",
)
The code is Ok(
    "*first",
)
The code is Ok(
    "first",
)
The code is Ok(
    "'-'",
)
The code is Ok(
    "if fail_fast {\n                return true;\n            }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "*had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "*had_errors",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "*first = '\\u{FFFD}'",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "*first",
)
The code is Ok(
    "first",
)
The code is Ok(
    "if let Some(last) = mut_label.last_mut() {\n        if *last == '-' {\n            if fail_fast {\n                return true;\n            }\n            *had_errors = true;\n            *last = '\\u{FFFD}';\n        }\n    }",
)
The code is Ok(
    "mut_label.last_mut()",
)
The code is Ok(
    "mut_label",
)
The code is Ok(
    "if *last == '-' {\n            if fail_fast {\n                return true;\n            }\n            *had_errors = true;\n            *last = '\\u{FFFD}';\n        }",
)
The code is Ok(
    "*last == '-'",
)
The code is Ok(
    "*last",
)
The code is Ok(
    "last",
)
The code is Ok(
    "'-'",
)
The code is Ok(
    "if fail_fast {\n                return true;\n            }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "*had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "*had_errors",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "*last = '\\u{FFFD}'",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "*last",
)
The code is Ok(
    "last",
)
The code is Ok(
    "if allow_third_fourth {\n        return false;\n    }",
)
The code is Ok(
    "allow_third_fourth",
)
The code is Ok(
    "return false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "if mut_label.len() >= 4 && mut_label[2] == '-' && mut_label[3] == '-' {\n        if fail_fast {\n            return true;\n        }\n        *had_errors = true;\n        mut_label[2] = '\\u{FFFD}';\n        mut_label[3] = '\\u{FFFD}';\n    }",
)
The code is Ok(
    "mut_label.len() >= 4 && mut_label[2] == '-' && mut_label[3] == '-'",
)
The code is Ok(
    "mut_label.len() >= 4 && mut_label[2] == '-'",
)
The code is Ok(
    "mut_label.len() >= 4",
)
The code is Ok(
    "mut_label.len()",
)
The code is Ok(
    "mut_label",
)
The code is Ok(
    "4",
)
The code is Ok(
    "mut_label[2] == '-'",
)
The code is Ok(
    "mut_label[2]",
)
The code is Ok(
    "mut_label",
)
The code is Ok(
    "2",
)
The code is Ok(
    "'-'",
)
The code is Ok(
    "mut_label[3] == '-'",
)
The code is Ok(
    "mut_label[3]",
)
The code is Ok(
    "mut_label",
)
The code is Ok(
    "3",
)
The code is Ok(
    "'-'",
)
The code is Ok(
    "if fail_fast {\n            return true;\n        }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "*had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "*had_errors",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "mut_label[2] = '\\u{FFFD}'",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "mut_label[2]",
)
The code is Ok(
    "mut_label",
)
The code is Ok(
    "2",
)
The code is Ok(
    "mut_label[3] = '\\u{FFFD}'",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "mut_label[3]",
)
The code is Ok(
    "mut_label",
)
The code is Ok(
    "3",
)
The code is Ok(
    "false",
)
The code is Ok(
    "{\n    Uts46::new().to_ascii(\n        domain,\n        ascii_deny_list,\n        uts46::Hyphens::Allow,\n        uts46::DnsLength::Ignore,\n    )\n}",
)
The code is Ok(
    "Uts46::new().to_ascii(\n        domain,\n        ascii_deny_list,\n        uts46::Hyphens::Allow,\n        uts46::DnsLength::Ignore,\n    )",
)
The code is Ok(
    "Uts46::new()",
)
The code is Ok(
    "Uts46::new",
)
The code is Ok(
    "domain",
)
The code is Ok(
    "ascii_deny_list",
)
The code is Ok(
    "uts46::Hyphens::Allow",
)
The code is Ok(
    "uts46::DnsLength::Ignore",
)
The code is Ok(
    "{\n    domain_to_ascii_cow(domain.as_bytes(), AsciiDenyList::EMPTY).map(|cow| cow.into_owned())\n}",
)
The code is Ok(
    "domain_to_ascii_cow(domain.as_bytes(), AsciiDenyList::EMPTY).map(|cow| cow.into_owned())",
)
The code is Ok(
    "domain_to_ascii_cow(domain.as_bytes(), AsciiDenyList::EMPTY)",
)
resolved new call Call { call_expr: HirId(DefId(0:228 ~ idna[bc6b]::domain_to_ascii).5), call_expr_span: idna/src/lib.rs:129:5: 129:65 (#0), caller: Some(DefId(0:228 ~ idna[bc6b]::domain_to_ascii)), caller_span: None, callee: DefId(0:227 ~ idna[bc6b]::domain_to_ascii_cow), callee_span: idna/src/lib.rs:129:5: 129:24 (#0), callee_path: "domain_to_ascii_cow", constraint_depth: 0 }
The code is Ok(
    "domain_to_ascii_cow",
)
The code is Ok(
    "domain.as_bytes()",
)
The code is Ok(
    "domain",
)
The code is Ok(
    "AsciiDenyList::EMPTY",
)
The code is Ok(
    "|cow| cow.into_owned()",
)
The code is Ok(
    "cow.into_owned()",
)
The code is Ok(
    "cow",
)
The code is Ok(
    "{\n    Uts46::new()\n        .to_ascii(\n            domain.as_bytes(),\n            uts46::AsciiDenyList::STD3,\n            uts46::Hyphens::Check,\n            uts46::DnsLength::Verify,\n        )\n        .map(|cow| cow.into_owned())\n}",
)
The code is Ok(
    "Uts46::new()\n        .to_ascii(\n            domain.as_bytes(),\n            uts46::AsciiDenyList::STD3,\n            uts46::Hyphens::Check,\n            uts46::DnsLength::Verify,\n        )\n        .map(|cow| cow.into_owned())",
)
The code is Ok(
    "Uts46::new()\n        .to_ascii(\n            domain.as_bytes(),\n            uts46::AsciiDenyList::STD3,\n            uts46::Hyphens::Check,\n            uts46::DnsLength::Verify,\n        )",
)
The code is Ok(
    "Uts46::new()",
)
The code is Ok(
    "Uts46::new",
)
The code is Ok(
    "domain.as_bytes()",
)
The code is Ok(
    "domain",
)
The code is Ok(
    "uts46::AsciiDenyList::STD3",
)
The code is Ok(
    "uts46::Hyphens::Check",
)
The code is Ok(
    "uts46::DnsLength::Verify",
)
The code is Ok(
    "|cow| cow.into_owned()",
)
The code is Ok(
    "cow.into_owned()",
)
The code is Ok(
    "cow",
)
The code is Ok(
    "{\n    let (cow, result) = Uts46::new().to_unicode(\n        domain.as_bytes(),\n        uts46::AsciiDenyList::EMPTY,\n        uts46::Hyphens::Allow,\n    );\n    (cow.into_owned(), result)\n}",
)
The code is Ok(
    "Uts46::new().to_unicode(\n        domain.as_bytes(),\n        uts46::AsciiDenyList::EMPTY,\n        uts46::Hyphens::Allow,\n    )",
)
The code is Ok(
    "Uts46::new()",
)
The code is Ok(
    "Uts46::new",
)
The code is Ok(
    "domain.as_bytes()",
)
The code is Ok(
    "domain",
)
The code is Ok(
    "uts46::AsciiDenyList::EMPTY",
)
The code is Ok(
    "uts46::Hyphens::Allow",
)
The code is Ok(
    "(cow.into_owned(), result)",
)
The code is Ok(
    "cow.into_owned()",
)
The code is Ok(
    "cow",
)
The code is Ok(
    "result",
)
The code is Ok(
    "{\n        Self { config }\n    }",
)
The code is Ok(
    "Self { config }",
)
The code is Ok(
    "config",
)
The code is Ok(
    "{\n        let mapped = map_transitional(domain, self.config.transitional_processing);\n        match Uts46::new().process(\n            mapped.as_bytes(),\n            self.config.deny_list(),\n            self.config.hyphens(),\n            ErrorPolicy::FailFast, // Old code did not appear to expect the output to be useful in the error case.\n            |_, _, _| false,\n            out,\n            None,\n        ) {\n            Ok(ProcessingSuccess::Passthrough) => {\n                if self.config.verify_dns_length && !verify_dns_length(&mapped, true) {\n                    return Err(crate::Errors::default());\n                }\n                out.push_str(&mapped);\n                Ok(())\n            }\n            Ok(ProcessingSuccess::WroteToSink) => {\n                if self.config.verify_dns_length && !verify_dns_length(out, true) {\n                    return Err(crate::Errors::default());\n                }\n                Ok(())\n            }\n            Err(ProcessingError::ValidityError) => Err(crate::Errors::default()),\n            Err(ProcessingError::SinkError) => unreachable!(),\n        }\n    }",
)
The code is Ok(
    "map_transitional(domain, self.config.transitional_processing)",
)
resolved new call Call { call_expr: HirId(DefId(0:18 ~ idna[bc6b]::deprecated::{impl#0}::to_ascii).8), call_expr_span: idna/src/deprecated.rs:79:22: 79:83 (#0), caller: Some(DefId(0:18 ~ idna[bc6b]::deprecated::{impl#0}::to_ascii)), caller_span: None, callee: DefId(0:15 ~ idna[bc6b]::deprecated::map_transitional), callee_span: idna/src/deprecated.rs:79:22: 79:38 (#0), callee_path: "deprecated::map_transitional", constraint_depth: 0 }
The code is Ok(
    "map_transitional",
)
The code is Ok(
    "domain",
)
The code is Ok(
    "self.config.transitional_processing",
)
The code is Ok(
    "self.config",
)
The code is Ok(
    "self",
)
The code is Ok(
    "match Uts46::new().process(\n            mapped.as_bytes(),\n            self.config.deny_list(),\n            self.config.hyphens(),\n            ErrorPolicy::FailFast, // Old code did not appear to expect the output to be useful in the error case.\n            |_, _, _| false,\n            out,\n            None,\n        ) {\n            Ok(ProcessingSuccess::Passthrough) => {\n                if self.config.verify_dns_length && !verify_dns_length(&mapped, true) {\n                    return Err(crate::Errors::default());\n                }\n                out.push_str(&mapped);\n                Ok(())\n            }\n            Ok(ProcessingSuccess::WroteToSink) => {\n                if self.config.verify_dns_length && !verify_dns_length(out, true) {\n                    return Err(crate::Errors::default());\n                }\n                Ok(())\n            }\n            Err(ProcessingError::ValidityError) => Err(crate::Errors::default()),\n            Err(ProcessingError::SinkError) => unreachable!(),\n        }",
)
The code is Ok(
    "Uts46::new().process(\n            mapped.as_bytes(),\n            self.config.deny_list(),\n            self.config.hyphens(),\n            ErrorPolicy::FailFast, // Old code did not appear to expect the output to be useful in the error case.\n            |_, _, _| false,\n            out,\n            None,\n        )",
)
The code is Ok(
    "Uts46::new()",
)
The code is Ok(
    "Uts46::new",
)
The code is Ok(
    "mapped.as_bytes()",
)
The code is Ok(
    "mapped",
)
The code is Ok(
    "self.config.deny_list()",
)
The code is Ok(
    "self.config",
)
The code is Ok(
    "self",
)
The code is Ok(
    "self.config.hyphens()",
)
The code is Ok(
    "self.config",
)
The code is Ok(
    "self",
)
The code is Ok(
    "ErrorPolicy::FailFast",
)
The code is Ok(
    "|_, _, _| false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "out",
)
The code is Ok(
    "None",
)
The code is Ok(
    "{\n                if self.config.verify_dns_length && !verify_dns_length(&mapped, true) {\n                    return Err(crate::Errors::default());\n                }\n                out.push_str(&mapped);\n                Ok(())\n            }",
)
The code is Ok(
    "if self.config.verify_dns_length && !verify_dns_length(&mapped, true) {\n                    return Err(crate::Errors::default());\n                }",
)
The code is Ok(
    "self.config.verify_dns_length && !verify_dns_length(&mapped, true)",
)
The code is Ok(
    "self.config.verify_dns_length",
)
The code is Ok(
    "self.config",
)
The code is Ok(
    "self",
)
The code is Ok(
    "!verify_dns_length(&mapped, true)",
)
The code is Ok(
    "verify_dns_length(&mapped, true)",
)
resolved new call Call { call_expr: HirId(DefId(0:18 ~ idna[bc6b]::deprecated::{impl#0}::to_ascii).73), call_expr_span: idna/src/deprecated.rs:90:54: 90:86 (#0), caller: Some(DefId(0:18 ~ idna[bc6b]::deprecated::{impl#0}::to_ascii)), caller_span: None, callee: DefId(0:166 ~ idna[bc6b]::uts46::verify_dns_length), callee_span: idna/src/deprecated.rs:90:54: 90:71 (#0), callee_path: "uts46::verify_dns_length", constraint_depth: 2 }
The code is Ok(
    "verify_dns_length",
)
The code is Ok(
    "&mapped",
)
The code is Ok(
    "mapped",
)
The code is Ok(
    "true",
)
The code is Ok(
    "return Err(crate::Errors::default())",
)
The code is Ok(
    "Err(crate::Errors::default())",
)
resolved new call Call { call_expr: HirId(DefId(0:18 ~ idna[bc6b]::deprecated::{impl#0}::to_ascii).82), call_expr_span: idna/src/deprecated.rs:91:28: 91:57 (#0), caller: Some(DefId(0:18 ~ idna[bc6b]::deprecated::{impl#0}::to_ascii)), caller_span: None, callee: DefId(1:45572 ~ core[f118]::result::Result::Err::{constructor#0}), callee_span: idna/src/deprecated.rs:91:28: 91:31 (#0), callee_path: "core::prelude::v1::Err", constraint_depth: 3 }
The code is Ok(
    "Err",
)
The code is Ok(
    "crate::Errors::default()",
)
The code is Ok(
    "crate::Errors::default",
)
The code is Ok(
    "out.push_str(&mapped)",
)
The code is Ok(
    "out",
)
The code is Ok(
    "&mapped",
)
The code is Ok(
    "mapped",
)
The code is Ok(
    "Ok(())",
)
resolved new call Call { call_expr: HirId(DefId(0:18 ~ idna[bc6b]::deprecated::{impl#0}::to_ascii).103), call_expr_span: idna/src/deprecated.rs:94:17: 94:23 (#0), caller: Some(DefId(0:18 ~ idna[bc6b]::deprecated::{impl#0}::to_ascii)), caller_span: None, callee: DefId(1:45569 ~ core[f118]::result::Result::Ok::{constructor#0}), callee_span: idna/src/deprecated.rs:94:17: 94:19 (#0), callee_path: "core::prelude::v1::Ok", constraint_depth: 1 }
The code is Ok(
    "Ok",
)
The code is Ok(
    "()",
)
The code is Ok(
    "{\n                if self.config.verify_dns_length && !verify_dns_length(out, true) {\n                    return Err(crate::Errors::default());\n                }\n                Ok(())\n            }",
)
The code is Ok(
    "if self.config.verify_dns_length && !verify_dns_length(out, true) {\n                    return Err(crate::Errors::default());\n                }",
)
The code is Ok(
    "self.config.verify_dns_length && !verify_dns_length(out, true)",
)
The code is Ok(
    "self.config.verify_dns_length",
)
The code is Ok(
    "self.config",
)
The code is Ok(
    "self",
)
The code is Ok(
    "!verify_dns_length(out, true)",
)
The code is Ok(
    "verify_dns_length(out, true)",
)
resolved new call Call { call_expr: HirId(DefId(0:18 ~ idna[bc6b]::deprecated::{impl#0}::to_ascii).122), call_expr_span: idna/src/deprecated.rs:97:54: 97:82 (#0), caller: Some(DefId(0:18 ~ idna[bc6b]::deprecated::{impl#0}::to_ascii)), caller_span: None, callee: DefId(0:166 ~ idna[bc6b]::uts46::verify_dns_length), callee_span: idna/src/deprecated.rs:97:54: 97:71 (#0), callee_path: "uts46::verify_dns_length", constraint_depth: 2 }
The code is Ok(
    "verify_dns_length",
)
The code is Ok(
    "out",
)
The code is Ok(
    "true",
)
The code is Ok(
    "return Err(crate::Errors::default())",
)
The code is Ok(
    "Err(crate::Errors::default())",
)
resolved new call Call { call_expr: HirId(DefId(0:18 ~ idna[bc6b]::deprecated::{impl#0}::to_ascii).130), call_expr_span: idna/src/deprecated.rs:98:28: 98:57 (#0), caller: Some(DefId(0:18 ~ idna[bc6b]::deprecated::{impl#0}::to_ascii)), caller_span: None, callee: DefId(1:45572 ~ core[f118]::result::Result::Err::{constructor#0}), callee_span: idna/src/deprecated.rs:98:28: 98:31 (#0), callee_path: "core::prelude::v1::Err", constraint_depth: 3 }
The code is Ok(
    "Err",
)
The code is Ok(
    "crate::Errors::default()",
)
The code is Ok(
    "crate::Errors::default",
)
The code is Ok(
    "Ok(())",
)
resolved new call Call { call_expr: HirId(DefId(0:18 ~ idna[bc6b]::deprecated::{impl#0}::to_ascii).143), call_expr_span: idna/src/deprecated.rs:100:17: 100:23 (#0), caller: Some(DefId(0:18 ~ idna[bc6b]::deprecated::{impl#0}::to_ascii)), caller_span: None, callee: DefId(1:45569 ~ core[f118]::result::Result::Ok::{constructor#0}), callee_span: idna/src/deprecated.rs:100:17: 100:19 (#0), callee_path: "core::prelude::v1::Ok", constraint_depth: 1 }
The code is Ok(
    "Ok",
)
The code is Ok(
    "()",
)
The code is Ok(
    "Err(crate::Errors::default())",
)
resolved new call Call { call_expr: HirId(DefId(0:18 ~ idna[bc6b]::deprecated::{impl#0}::to_ascii).154), call_expr_span: idna/src/deprecated.rs:102:52: 102:81 (#0), caller: Some(DefId(0:18 ~ idna[bc6b]::deprecated::{impl#0}::to_ascii)), caller_span: None, callee: DefId(1:45572 ~ core[f118]::result::Result::Err::{constructor#0}), callee_span: idna/src/deprecated.rs:102:52: 102:55 (#0), callee_path: "core::prelude::v1::Err", constraint_depth: 1 }
The code is Ok(
    "Err",
)
The code is Ok(
    "crate::Errors::default()",
)
The code is Ok(
    "crate::Errors::default",
)
The code is Ok(
    "$crate::panicking::panic(\"internal error: entered unreachable code\")",
)
resolved new call Call { call_expr: HirId(DefId(0:18 ~ idna[bc6b]::deprecated::{impl#0}::to_ascii).169), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:118:9: 118:77 (#10), caller: Some(DefId(0:18 ~ idna[bc6b]::deprecated::{impl#0}::to_ascii)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:118:9: 118:33 (#10), callee_path: "core::panicking::panic", constraint_depth: 1 }
The code is Ok(
    "$crate::panicking::panic",
)
The code is Ok(
    "\"internal error: entered unreachable code\"",
)
The code is Ok(
    "{\n        let mapped = map_transitional(domain, self.config.transitional_processing);\n        match Uts46::new().process(\n            mapped.as_bytes(),\n            self.config.deny_list(),\n            self.config.hyphens(),\n            ErrorPolicy::MarkErrors,\n            |_, _, _| true,\n            out,\n            None,\n        ) {\n            Ok(ProcessingSuccess::Passthrough) => {\n                out.push_str(&mapped);\n                Ok(())\n            }\n            Ok(ProcessingSuccess::WroteToSink) => Ok(()),\n            Err(ProcessingError::ValidityError) => Err(crate::Errors::default()),\n            Err(ProcessingError::SinkError) => unreachable!(),\n        }\n    }",
)
The code is Ok(
    "map_transitional(domain, self.config.transitional_processing)",
)
resolved new call Call { call_expr: HirId(DefId(0:20 ~ idna[bc6b]::deprecated::{impl#0}::to_unicode).8), call_expr_span: idna/src/deprecated.rs:110:22: 110:83 (#0), caller: Some(DefId(0:20 ~ idna[bc6b]::deprecated::{impl#0}::to_unicode)), caller_span: None, callee: DefId(0:15 ~ idna[bc6b]::deprecated::map_transitional), callee_span: idna/src/deprecated.rs:110:22: 110:38 (#0), callee_path: "deprecated::map_transitional", constraint_depth: 0 }
The code is Ok(
    "map_transitional",
)
The code is Ok(
    "domain",
)
The code is Ok(
    "self.config.transitional_processing",
)
The code is Ok(
    "self.config",
)
The code is Ok(
    "self",
)
The code is Ok(
    "match Uts46::new().process(\n            mapped.as_bytes(),\n            self.config.deny_list(),\n            self.config.hyphens(),\n            ErrorPolicy::MarkErrors,\n            |_, _, _| true,\n            out,\n            None,\n        ) {\n            Ok(ProcessingSuccess::Passthrough) => {\n                out.push_str(&mapped);\n                Ok(())\n            }\n            Ok(ProcessingSuccess::WroteToSink) => Ok(()),\n            Err(ProcessingError::ValidityError) => Err(crate::Errors::default()),\n            Err(ProcessingError::SinkError) => unreachable!(),\n        }",
)
The code is Ok(
    "Uts46::new().process(\n            mapped.as_bytes(),\n            self.config.deny_list(),\n            self.config.hyphens(),\n            ErrorPolicy::MarkErrors,\n            |_, _, _| true,\n            out,\n            None,\n        )",
)
The code is Ok(
    "Uts46::new()",
)
The code is Ok(
    "Uts46::new",
)
The code is Ok(
    "mapped.as_bytes()",
)
The code is Ok(
    "mapped",
)
The code is Ok(
    "self.config.deny_list()",
)
The code is Ok(
    "self.config",
)
The code is Ok(
    "self",
)
The code is Ok(
    "self.config.hyphens()",
)
The code is Ok(
    "self.config",
)
The code is Ok(
    "self",
)
The code is Ok(
    "ErrorPolicy::MarkErrors",
)
The code is Ok(
    "|_, _, _| true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "out",
)
The code is Ok(
    "None",
)
The code is Ok(
    "{\n                out.push_str(&mapped);\n                Ok(())\n            }",
)
The code is Ok(
    "out.push_str(&mapped)",
)
The code is Ok(
    "out",
)
The code is Ok(
    "&mapped",
)
The code is Ok(
    "mapped",
)
The code is Ok(
    "Ok(())",
)
resolved new call Call { call_expr: HirId(DefId(0:20 ~ idna[bc6b]::deprecated::{impl#0}::to_unicode).74), call_expr_span: idna/src/deprecated.rs:122:17: 122:23 (#0), caller: Some(DefId(0:20 ~ idna[bc6b]::deprecated::{impl#0}::to_unicode)), caller_span: None, callee: DefId(1:45569 ~ core[f118]::result::Result::Ok::{constructor#0}), callee_span: idna/src/deprecated.rs:122:17: 122:19 (#0), callee_path: "core::prelude::v1::Ok", constraint_depth: 1 }
The code is Ok(
    "Ok",
)
The code is Ok(
    "()",
)
The code is Ok(
    "Ok(())",
)
resolved new call Call { call_expr: HirId(DefId(0:20 ~ idna[bc6b]::deprecated::{impl#0}::to_unicode).85), call_expr_span: idna/src/deprecated.rs:124:51: 124:57 (#0), caller: Some(DefId(0:20 ~ idna[bc6b]::deprecated::{impl#0}::to_unicode)), caller_span: None, callee: DefId(1:45569 ~ core[f118]::result::Result::Ok::{constructor#0}), callee_span: idna/src/deprecated.rs:124:51: 124:53 (#0), callee_path: "core::prelude::v1::Ok", constraint_depth: 1 }
The code is Ok(
    "Ok",
)
The code is Ok(
    "()",
)
The code is Ok(
    "Err(crate::Errors::default())",
)
resolved new call Call { call_expr: HirId(DefId(0:20 ~ idna[bc6b]::deprecated::{impl#0}::to_unicode).95), call_expr_span: idna/src/deprecated.rs:125:52: 125:81 (#0), caller: Some(DefId(0:20 ~ idna[bc6b]::deprecated::{impl#0}::to_unicode)), caller_span: None, callee: DefId(1:45572 ~ core[f118]::result::Result::Err::{constructor#0}), callee_span: idna/src/deprecated.rs:125:52: 125:55 (#0), callee_path: "core::prelude::v1::Err", constraint_depth: 1 }
The code is Ok(
    "Err",
)
The code is Ok(
    "crate::Errors::default()",
)
The code is Ok(
    "crate::Errors::default",
)
The code is Ok(
    "$crate::panicking::panic(\"internal error: entered unreachable code\")",
)
resolved new call Call { call_expr: HirId(DefId(0:20 ~ idna[bc6b]::deprecated::{impl#0}::to_unicode).110), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:118:9: 118:77 (#13), caller: Some(DefId(0:20 ~ idna[bc6b]::deprecated::{impl#0}::to_unicode)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:118:9: 118:33 (#13), callee_path: "core::panicking::panic", constraint_depth: 1 }
The code is Ok(
    "$crate::panicking::panic",
)
The code is Ok(
    "\"internal error: entered unreachable code\"",
)
The code is Ok(
    "{\n        Config {\n            use_std3_ascii_rules: false,\n            transitional_processing: false,\n            check_hyphens: false,\n            // Only use for to_ascii, not to_unicode\n            verify_dns_length: false,\n        }\n    }",
)
The code is Ok(
    "Config {\n            use_std3_ascii_rules: false,\n            transitional_processing: false,\n            check_hyphens: false,\n            // Only use for to_ascii, not to_unicode\n            verify_dns_length: false,\n        }",
)
The code is Ok(
    "false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "{\n        self.use_std3_ascii_rules = value;\n        self\n    }",
)
The code is Ok(
    "self.use_std3_ascii_rules = value",
)
The code is Ok(
    "value",
)
The code is Ok(
    "self.use_std3_ascii_rules",
)
The code is Ok(
    "self",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        self.transitional_processing = value;\n        self\n    }",
)
The code is Ok(
    "self.transitional_processing = value",
)
The code is Ok(
    "value",
)
The code is Ok(
    "self.transitional_processing",
)
The code is Ok(
    "self",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        self.verify_dns_length = value;\n        self\n    }",
)
The code is Ok(
    "self.verify_dns_length = value",
)
The code is Ok(
    "value",
)
The code is Ok(
    "self.verify_dns_length",
)
The code is Ok(
    "self",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        self.check_hyphens = value;\n        self\n    }",
)
The code is Ok(
    "self.check_hyphens = value",
)
The code is Ok(
    "value",
)
The code is Ok(
    "self.check_hyphens",
)
The code is Ok(
    "self",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        assert!(!value, \"IDNA 2008 rules are no longer supported\");\n        self\n    }",
)
The code is Ok(
    "assert!(!value, \"IDNA 2008 rules are no longer supported\")",
)
The code is Ok(
    "assert!(!value, \"IDNA 2008 rules are no longer supported\")",
)
The code is Ok(
    "!value",
)
The code is Ok(
    "value",
)
The code is Ok(
    "$crate::panicking::panic($msg)",
)
resolved new call Call { call_expr: HirId(DefId(0:29 ~ idna[bc6b]::deprecated::{impl#2}::use_idna_2008_rules).11), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:29:9: 29:39 (#20), caller: Some(DefId(0:29 ~ idna[bc6b]::deprecated::{impl#2}::use_idna_2008_rules)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:29:9: 29:33 (#20), callee_path: "core::panicking::panic", constraint_depth: 1 }
The code is Ok(
    "$crate::panicking::panic",
)
The code is Ok(
    "\"IDNA 2008 rules are no longer supported\"",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        if self.use_std3_ascii_rules {\n            AsciiDenyList::STD3\n        } else {\n            AsciiDenyList::EMPTY\n        }\n    }",
)
The code is Ok(
    "if self.use_std3_ascii_rules {\n            AsciiDenyList::STD3\n        } else {\n            AsciiDenyList::EMPTY\n        }",
)
The code is Ok(
    "self.use_std3_ascii_rules",
)
The code is Ok(
    "self",
)
The code is Ok(
    "AsciiDenyList::STD3",
)
The code is Ok(
    "AsciiDenyList::EMPTY",
)
The code is Ok(
    "{\n        if self.check_hyphens {\n            Hyphens::CheckFirstLast\n        } else {\n            Hyphens::Allow\n        }\n    }",
)
The code is Ok(
    "if self.check_hyphens {\n            Hyphens::CheckFirstLast\n        } else {\n            Hyphens::Allow\n        }",
)
The code is Ok(
    "self.check_hyphens",
)
The code is Ok(
    "self",
)
The code is Ok(
    "Hyphens::CheckFirstLast",
)
The code is Ok(
    "Hyphens::Allow",
)
The code is Ok(
    "{\n        let mut result = String::with_capacity(domain.len());\n        let mut codec = Idna::new(self);\n        codec.to_ascii(domain, &mut result).map(|()| result)\n    }",
)
The code is Ok(
    "String::with_capacity(domain.len())",
)
The code is Ok(
    "String::with_capacity",
)
The code is Ok(
    "domain.len()",
)
The code is Ok(
    "domain",
)
The code is Ok(
    "Idna::new(self)",
)
The code is Ok(
    "Idna::new",
)
The code is Ok(
    "self",
)
The code is Ok(
    "codec.to_ascii(domain, &mut result).map(|()| result)",
)
The code is Ok(
    "codec.to_ascii(domain, &mut result)",
)
The code is Ok(
    "codec",
)
The code is Ok(
    "domain",
)
The code is Ok(
    "&mut result",
)
The code is Ok(
    "result",
)
The code is Ok(
    "|()| result",
)
The code is Ok(
    "result",
)
The code is Ok(
    "{\n        let mut codec = Idna::new(self);\n        let mut out = String::with_capacity(domain.len());\n        let result = codec.to_unicode(domain, &mut out);\n        (out, result)\n    }",
)
The code is Ok(
    "Idna::new(self)",
)
The code is Ok(
    "Idna::new",
)
The code is Ok(
    "self",
)
The code is Ok(
    "String::with_capacity(domain.len())",
)
The code is Ok(
    "String::with_capacity",
)
The code is Ok(
    "domain.len()",
)
The code is Ok(
    "domain",
)
The code is Ok(
    "codec.to_unicode(domain, &mut out)",
)
The code is Ok(
    "codec",
)
The code is Ok(
    "domain",
)
The code is Ok(
    "&mut out",
)
The code is Ok(
    "out",
)
The code is Ok(
    "(out, result)",
)
The code is Ok(
    "out",
)
The code is Ok(
    "result",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "{\n        *self == b'-'\n    }",
)
The code is Ok(
    "*self == b'-'",
)
The code is Ok(
    "*self",
)
The code is Ok(
    "self",
)
The code is Ok(
    "b'-'",
)
The code is Ok(
    "{\n        *self < 0x80\n    }",
)
The code is Ok(
    "*self < 0x80",
)
The code is Ok(
    "*self",
)
The code is Ok(
    "self",
)
The code is Ok(
    "0x80",
)
The code is Ok(
    "{\n        let byte = *self;\n        Some(match byte {\n            byte @ b'0'..=b'9' => byte - b'0' + 26,\n            byte @ b'A'..=b'Z' => byte - b'A',\n            byte @ b'a'..=b'z' => byte - b'a',\n            _ => return None,\n        } as u32)\n    }",
)
The code is Ok(
    "*self",
)
The code is Ok(
    "self",
)
The code is Ok(
    "Some(match byte {\n            byte @ b'0'..=b'9' => byte - b'0' + 26,\n            byte @ b'A'..=b'Z' => byte - b'A',\n            byte @ b'a'..=b'z' => byte - b'a',\n            _ => return None,\n        } as u32)",
)
resolved new call Call { call_expr: HirId(DefId(0:71 ~ idna[bc6b]::punycode::{impl#2}::digit).9), call_expr_span: idna/src/punycode.rs:117:9: 122:18 (#0), caller: Some(DefId(0:71 ~ idna[bc6b]::punycode::{impl#2}::digit)), caller_span: None, callee: DefId(1:45302 ~ core[f118]::option::Option::Some::{constructor#0}), callee_span: idna/src/punycode.rs:117:9: 117:13 (#0), callee_path: "core::prelude::v1::Some", constraint_depth: 0 }
The code is Ok(
    "Some",
)
The code is Ok(
    "match byte {\n            byte @ b'0'..=b'9' => byte - b'0' + 26,\n            byte @ b'A'..=b'Z' => byte - b'A',\n            byte @ b'a'..=b'z' => byte - b'a',\n            _ => return None,\n        } as u32",
)
The code is Ok(
    "match byte {\n            byte @ b'0'..=b'9' => byte - b'0' + 26,\n            byte @ b'A'..=b'Z' => byte - b'A',\n            byte @ b'a'..=b'z' => byte - b'a',\n            _ => return None,\n        }",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "b'0'",
)
The code is Ok(
    "b'9'",
)
The code is Ok(
    "byte - b'0' + 26",
)
The code is Ok(
    "byte - b'0'",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "b'0'",
)
The code is Ok(
    "26",
)
The code is Ok(
    "b'A'",
)
The code is Ok(
    "b'Z'",
)
The code is Ok(
    "byte - b'A'",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "b'A'",
)
The code is Ok(
    "b'a'",
)
The code is Ok(
    "b'z'",
)
The code is Ok(
    "byte - b'a'",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "b'a'",
)
The code is Ok(
    "return None",
)
The code is Ok(
    "None",
)
The code is Ok(
    "{\n        char::from(*self)\n    }",
)
The code is Ok(
    "char::from(*self)",
)
The code is Ok(
    "char::from",
)
The code is Ok(
    "*self",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        char::from(self.to_ascii_lowercase())\n    }",
)
The code is Ok(
    "char::from(self.to_ascii_lowercase())",
)
The code is Ok(
    "char::from",
)
The code is Ok(
    "self.to_ascii_lowercase()",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        *self == '-'\n    }",
)
The code is Ok(
    "*self == '-'",
)
The code is Ok(
    "*self",
)
The code is Ok(
    "self",
)
The code is Ok(
    "'-'",
)
The code is Ok(
    "{\n        debug_assert!(false); // Unused\n        true\n    }",
)
The code is Ok(
    "if $crate::cfg!(debug_assertions) {\n            $crate::assert!($($arg)*);\n        }",
)
The code is Ok(
    "$crate::cfg!(debug_assertions)",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "false",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
resolved new call Call { call_expr: HirId(DefId(0:76 ~ idna[bc6b]::punycode::{impl#3}::is_ascii).10), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:335:13: 335:38 (#23), caller: Some(DefId(0:76 ~ idna[bc6b]::punycode::{impl#3}::is_ascii)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:335:13: 335:13 (#23), callee_path: "core::panicking::panic", constraint_depth: 1 }
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "",
)
The code is Ok(
    "true",
)
The code is Ok(
    "{\n        let byte = *self;\n        Some(match byte {\n            byte @ '0'..='9' => u32::from(byte) - u32::from('0') + 26,\n            // byte @ 'A'..='Z' => u32::from(byte) - u32::from('A'), // XXX not needed if no public input\n            byte @ 'a'..='z' => u32::from(byte) - u32::from('a'),\n            _ => return None,\n        })\n    }",
)
The code is Ok(
    "*self",
)
The code is Ok(
    "self",
)
The code is Ok(
    "Some(match byte {\n            byte @ '0'..='9' => u32::from(byte) - u32::from('0') + 26,\n            // byte @ 'A'..='Z' => u32::from(byte) - u32::from('A'), // XXX not needed if no public input\n            byte @ 'a'..='z' => u32::from(byte) - u32::from('a'),\n            _ => return None,\n        })",
)
resolved new call Call { call_expr: HirId(DefId(0:77 ~ idna[bc6b]::punycode::{impl#3}::digit).9), call_expr_span: idna/src/punycode.rs:142:9: 147:11 (#0), caller: Some(DefId(0:77 ~ idna[bc6b]::punycode::{impl#3}::digit)), caller_span: None, callee: DefId(1:45302 ~ core[f118]::option::Option::Some::{constructor#0}), callee_span: idna/src/punycode.rs:142:9: 142:13 (#0), callee_path: "core::prelude::v1::Some", constraint_depth: 0 }
The code is Ok(
    "Some",
)
The code is Ok(
    "match byte {\n            byte @ '0'..='9' => u32::from(byte) - u32::from('0') + 26,\n            // byte @ 'A'..='Z' => u32::from(byte) - u32::from('A'), // XXX not needed if no public input\n            byte @ 'a'..='z' => u32::from(byte) - u32::from('a'),\n            _ => return None,\n        }",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "'0'",
)
The code is Ok(
    "'9'",
)
The code is Ok(
    "u32::from(byte) - u32::from('0') + 26",
)
The code is Ok(
    "u32::from(byte) - u32::from('0')",
)
The code is Ok(
    "u32::from(byte)",
)
The code is Ok(
    "u32::from",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "u32::from('0')",
)
The code is Ok(
    "u32::from",
)
The code is Ok(
    "'0'",
)
The code is Ok(
    "26",
)
The code is Ok(
    "'a'",
)
The code is Ok(
    "'z'",
)
The code is Ok(
    "u32::from(byte) - u32::from('a')",
)
The code is Ok(
    "u32::from(byte)",
)
The code is Ok(
    "u32::from",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "u32::from('a')",
)
The code is Ok(
    "u32::from",
)
The code is Ok(
    "'a'",
)
The code is Ok(
    "return None",
)
The code is Ok(
    "None",
)
The code is Ok(
    "{\n        debug_assert!(false); // Unused\n        *self\n    }",
)
The code is Ok(
    "if $crate::cfg!(debug_assertions) {\n            $crate::assert!($($arg)*);\n        }",
)
The code is Ok(
    "$crate::cfg!(debug_assertions)",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "false",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
resolved new call Call { call_expr: HirId(DefId(0:78 ~ idna[bc6b]::punycode::{impl#3}::char).10), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:335:13: 335:38 (#27), caller: Some(DefId(0:78 ~ idna[bc6b]::punycode::{impl#3}::char)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:335:13: 335:13 (#27), callee_path: "core::panicking::panic", constraint_depth: 1 }
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "",
)
The code is Ok(
    "*self",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        // No need to actually lower-case!\n        *self\n    }",
)
The code is Ok(
    "*self",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        self.insertions.clear();\n        // Handle \"basic\" (ASCII) code points.\n        // They are encoded as-is before the last delimiter, if any.\n        let (base, input) = if let Some(position) = input.iter().rposition(|c| c.is_delimiter()) {\n            (\n                &input[..position],\n                if position > 0 {\n                    &input[position + 1..]\n                } else {\n                    input\n                },\n            )\n        } else {\n            (&input[..0], input)\n        };\n\n        if C::EXTERNAL_CALLER && !base.iter().all(|c| c.is_ascii()) {\n            return Err(());\n        }\n\n        let base_len = base.len();\n        let mut length = base_len as u32;\n        let mut code_point = INITIAL_N;\n        let mut bias = INITIAL_BIAS;\n        let mut i = 0u32;\n        let mut iter = input.iter();\n        loop {\n            let previous_i = i;\n            let mut weight = 1;\n            let mut k = BASE;\n            let mut byte = match iter.next() {\n                None => break,\n                Some(byte) => byte,\n            };\n\n            // Decode a generalized variable-length integer into delta,\n            // which gets added to i.\n            loop {\n                let digit = if let Some(digit) = byte.digit() {\n                    digit\n                } else {\n                    return Err(());\n                };\n                let product = digit.checked_mul(weight).ok_or(())?;\n                i = i.checked_add(product).ok_or(())?;\n                let t = if k <= bias {\n                    T_MIN\n                } else if k >= bias + T_MAX {\n                    T_MAX\n                } else {\n                    k - bias\n                };\n                if digit < t {\n                    break;\n                }\n                weight = weight.checked_mul(BASE - t).ok_or(())?;\n                k += BASE;\n                byte = match iter.next() {\n                    None => return Err(()), // End of input before the end of this delta\n                    Some(byte) => byte,\n                };\n            }\n\n            bias = adapt(i - previous_i, length + 1, previous_i == 0);\n\n            // i was supposed to wrap around from length+1 to 0,\n            // incrementing code_point each time.\n            code_point = code_point.checked_add(i / (length + 1)).ok_or(())?;\n            i %= length + 1;\n            let c = match char::from_u32(code_point) {\n                Some(c) => c,\n                None => return Err(()),\n            };\n\n            // Move earlier insertions farther out in the string\n            for (idx, _) in &mut self.insertions {\n                if *idx >= i as usize {\n                    *idx += 1;\n                }\n            }\n            self.insertions.push((i as usize, c));\n            length += 1;\n            i += 1;\n        }\n\n        self.insertions.sort_by_key(|(i, _)| *i);\n        Ok(Decode {\n            base: base.iter(),\n            insertions: &self.insertions,\n            inserted: 0,\n            position: 0,\n            len: base_len + self.insertions.len(),\n            phantom: PhantomData::<C>,\n        })\n    }",
)
The code is Ok(
    "self.insertions.clear()",
)
The code is Ok(
    "self.insertions",
)
The code is Ok(
    "self",
)
The code is Ok(
    "if let Some(position) = input.iter().rposition(|c| c.is_delimiter()) {\n            (\n                &input[..position],\n                if position > 0 {\n                    &input[position + 1..]\n                } else {\n                    input\n                },\n            )\n        } else {\n            (&input[..0], input)\n        }",
)
The code is Ok(
    "input.iter().rposition(|c| c.is_delimiter())",
)
The code is Ok(
    "input.iter()",
)
The code is Ok(
    "input",
)
The code is Ok(
    "|c| c.is_delimiter()",
)
The code is Ok(
    "c.is_delimiter()",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:81 ~ idna[bc6b]::punycode::{impl#4}::decode).26),
    call_expr_span: idna/src/punycode.rs:173:80: 173:96 (#0),
    caller: Some(
        DefId(0:81 ~ idna[bc6b]::punycode::{impl#4}::decode),
    ),
    caller_span: None,
    callee: DefId(0:63 ~ idna[bc6b]::punycode::PunycodeCodeUnit::is_delimiter),
    callee_span: idna/src/punycode.rs:173:80: 173:96 (#0),
    callee_path: "punycode::PunycodeCodeUnit::is_delimiter",
    constraint_depth: 0,
}
The code is Ok(
    "c",
)
The code is Ok(
    "(\n                &input[..position],\n                if position > 0 {\n                    &input[position + 1..]\n                } else {\n                    input\n                },\n            )",
)
The code is Ok(
    "&input[..position]",
)
The code is Ok(
    "input[..position]",
)
The code is Ok(
    "input",
)
The code is Ok(
    "..position",
)
The code is Ok(
    "position",
)
The code is Ok(
    "if position > 0 {\n                    &input[position + 1..]\n                } else {\n                    input\n                }",
)
The code is Ok(
    "position > 0",
)
The code is Ok(
    "position",
)
The code is Ok(
    "0",
)
The code is Ok(
    "&input[position + 1..]",
)
The code is Ok(
    "input[position + 1..]",
)
The code is Ok(
    "input",
)
The code is Ok(
    "position + 1..",
)
The code is Ok(
    "position + 1",
)
The code is Ok(
    "position",
)
The code is Ok(
    "1",
)
The code is Ok(
    "input",
)
The code is Ok(
    "(&input[..0], input)",
)
The code is Ok(
    "&input[..0]",
)
The code is Ok(
    "input[..0]",
)
The code is Ok(
    "input",
)
The code is Ok(
    "..0",
)
The code is Ok(
    "0",
)
The code is Ok(
    "input",
)
The code is Ok(
    "if C::EXTERNAL_CALLER && !base.iter().all(|c| c.is_ascii()) {\n            return Err(());\n        }",
)
The code is Ok(
    "C::EXTERNAL_CALLER && !base.iter().all(|c| c.is_ascii())",
)
The code is Ok(
    "C::EXTERNAL_CALLER",
)
The code is Ok(
    "!base.iter().all(|c| c.is_ascii())",
)
The code is Ok(
    "base.iter().all(|c| c.is_ascii())",
)
The code is Ok(
    "base.iter()",
)
The code is Ok(
    "base",
)
The code is Ok(
    "|c| c.is_ascii()",
)
The code is Ok(
    "c.is_ascii()",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:81 ~ idna[bc6b]::punycode::{impl#4}::decode).96),
    call_expr_span: idna/src/punycode.rs:186:55: 186:67 (#0),
    caller: Some(
        DefId(0:81 ~ idna[bc6b]::punycode::{impl#4}::decode),
    ),
    caller_span: None,
    callee: DefId(0:64 ~ idna[bc6b]::punycode::PunycodeCodeUnit::is_ascii),
    callee_span: idna/src/punycode.rs:186:55: 186:67 (#0),
    callee_path: "punycode::PunycodeCodeUnit::is_ascii",
    constraint_depth: 1,
}
The code is Ok(
    "c",
)
The code is Ok(
    "return Err(())",
)
The code is Ok(
    "Err(())",
)
resolved new call Call { call_expr: HirId(DefId(0:81 ~ idna[bc6b]::punycode::{impl#4}::decode).103), call_expr_span: idna/src/punycode.rs:187:20: 187:27 (#0), caller: Some(DefId(0:81 ~ idna[bc6b]::punycode::{impl#4}::decode)), caller_span: None, callee: DefId(1:45572 ~ core[f118]::result::Result::Err::{constructor#0}), callee_span: idna/src/punycode.rs:187:20: 187:23 (#0), callee_path: "core::prelude::v1::Err", constraint_depth: 2 }
The code is Ok(
    "Err",
)
The code is Ok(
    "()",
)
The code is Ok(
    "base.len()",
)
The code is Ok(
    "base",
)
The code is Ok(
    "base_len as u32",
)
The code is Ok(
    "base_len",
)
The code is Ok(
    "INITIAL_N",
)
The code is Ok(
    "INITIAL_BIAS",
)
The code is Ok(
    "0u32",
)
The code is Ok(
    "input.iter()",
)
The code is Ok(
    "input",
)
The code is Ok(
    "loop {\n            let previous_i = i;\n            let mut weight = 1;\n            let mut k = BASE;\n            let mut byte = match iter.next() {\n                None => break,\n                Some(byte) => byte,\n            };\n\n            // Decode a generalized variable-length integer into delta,\n            // which gets added to i.\n            loop {\n                let digit = if let Some(digit) = byte.digit() {\n                    digit\n                } else {\n                    return Err(());\n                };\n                let product = digit.checked_mul(weight).ok_or(())?;\n                i = i.checked_add(product).ok_or(())?;\n                let t = if k <= bias {\n                    T_MIN\n                } else if k >= bias + T_MAX {\n                    T_MAX\n                } else {\n                    k - bias\n                };\n                if digit < t {\n                    break;\n                }\n                weight = weight.checked_mul(BASE - t).ok_or(())?;\n                k += BASE;\n                byte = match iter.next() {\n                    None => return Err(()), // End of input before the end of this delta\n                    Some(byte) => byte,\n                };\n            }\n\n            bias = adapt(i - previous_i, length + 1, previous_i == 0);\n\n            // i was supposed to wrap around from length+1 to 0,\n            // incrementing code_point each time.\n            code_point = code_point.checked_add(i / (length + 1)).ok_or(())?;\n            i %= length + 1;\n            let c = match char::from_u32(code_point) {\n                Some(c) => c,\n                None => return Err(()),\n            };\n\n            // Move earlier insertions farther out in the string\n            for (idx, _) in &mut self.insertions {\n                if *idx >= i as usize {\n                    *idx += 1;\n                }\n            }\n            self.insertions.push((i as usize, c));\n            length += 1;\n            i += 1;\n        }",
)
The code is Ok(
    "i",
)
The code is Ok(
    "1",
)
The code is Ok(
    "BASE",
)
The code is Ok(
    "match iter.next() {\n                None => break,\n                Some(byte) => byte,\n            }",
)
The code is Ok(
    "iter.next()",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "break",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "loop {\n                let digit = if let Some(digit) = byte.digit() {\n                    digit\n                } else {\n                    return Err(());\n                };\n                let product = digit.checked_mul(weight).ok_or(())?;\n                i = i.checked_add(product).ok_or(())?;\n                let t = if k <= bias {\n                    T_MIN\n                } else if k >= bias + T_MAX {\n                    T_MAX\n                } else {\n                    k - bias\n                };\n                if digit < t {\n                    break;\n                }\n                weight = weight.checked_mul(BASE - t).ok_or(())?;\n                k += BASE;\n                byte = match iter.next() {\n                    None => return Err(()), // End of input before the end of this delta\n                    Some(byte) => byte,\n                };\n            }",
)
The code is Ok(
    "if let Some(digit) = byte.digit() {\n                    digit\n                } else {\n                    return Err(());\n                }",
)
The code is Ok(
    "byte.digit()",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:81 ~ idna[bc6b]::punycode::{impl#4}::decode).187),
    call_expr_span: idna/src/punycode.rs:208:50: 208:62 (#0),
    caller: Some(
        DefId(0:81 ~ idna[bc6b]::punycode::{impl#4}::decode),
    ),
    caller_span: None,
    callee: DefId(0:65 ~ idna[bc6b]::punycode::PunycodeCodeUnit::digit),
    callee_span: idna/src/punycode.rs:208:50: 208:62 (#0),
    callee_path: "punycode::PunycodeCodeUnit::digit",
    constraint_depth: 0,
}
The code is Ok(
    "byte",
)
The code is Ok(
    "digit",
)
The code is Ok(
    "return Err(())",
)
The code is Ok(
    "Err(())",
)
resolved new call Call { call_expr: HirId(DefId(0:81 ~ idna[bc6b]::punycode::{impl#4}::decode).197), call_expr_span: idna/src/punycode.rs:211:28: 211:35 (#0), caller: Some(DefId(0:81 ~ idna[bc6b]::punycode::{impl#4}::decode)), caller_span: None, callee: DefId(1:45572 ~ core[f118]::result::Result::Err::{constructor#0}), callee_span: idna/src/punycode.rs:211:28: 211:31 (#0), callee_path: "core::prelude::v1::Err", constraint_depth: 1 }
The code is Ok(
    "Err",
)
The code is Ok(
    "()",
)
The code is Ok(
    "digit.checked_mul(weight).ok_or(())?",
)
into Match call
The code is Ok(
    "digit.checked_mul(weight).ok_or(())?",
)
LangItem path: idna/src/punycode.rs:213:31: 213:67 (#203)
The code is Ok(
    "digit.checked_mul(weight).ok_or(())?",
)
The code is Ok(
    "digit.checked_mul(weight).ok_or(())",
)
The code is Ok(
    "digit.checked_mul(weight)",
)
The code is Ok(
    "digit",
)
The code is Ok(
    "weight",
)
The code is Ok(
    "()",
)
The code is Ok(
    "?",
)
The code is Ok(
    "digit.checked_mul(weight).ok_or(())?",
)
LangItem path: idna/src/punycode.rs:213:66: 213:67 (#204)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "digit.checked_mul(weight).ok_or(())?",
)
The code is Ok(
    "i = i.checked_add(product).ok_or(())?",
)
The code is Ok(
    "i.checked_add(product).ok_or(())?",
)
into Match call
The code is Ok(
    "i.checked_add(product).ok_or(())?",
)
LangItem path: idna/src/punycode.rs:214:21: 214:54 (#205)
The code is Ok(
    "i.checked_add(product).ok_or(())?",
)
The code is Ok(
    "i.checked_add(product).ok_or(())",
)
The code is Ok(
    "i.checked_add(product)",
)
The code is Ok(
    "i",
)
The code is Ok(
    "product",
)
The code is Ok(
    "()",
)
The code is Ok(
    "?",
)
The code is Ok(
    "i.checked_add(product).ok_or(())?",
)
LangItem path: idna/src/punycode.rs:214:53: 214:54 (#206)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "i.checked_add(product).ok_or(())?",
)
The code is Ok(
    "i",
)
The code is Ok(
    "if k <= bias {\n                    T_MIN\n                } else if k >= bias + T_MAX {\n                    T_MAX\n                } else {\n                    k - bias\n                }",
)
The code is Ok(
    "k <= bias",
)
The code is Ok(
    "k",
)
The code is Ok(
    "bias",
)
The code is Ok(
    "T_MIN",
)
The code is Ok(
    "k >= bias + T_MAX",
)
The code is Ok(
    "k >= bias + T_MAX",
)
The code is Ok(
    "k",
)
The code is Ok(
    "bias + T_MAX",
)
The code is Ok(
    "bias",
)
The code is Ok(
    "T_MAX",
)
The code is Ok(
    "{\n                    T_MAX\n                }",
)
The code is Ok(
    "T_MAX",
)
The code is Ok(
    "{\n                    k - bias\n                }",
)
The code is Ok(
    "k - bias",
)
The code is Ok(
    "k",
)
The code is Ok(
    "bias",
)
The code is Ok(
    "if digit < t {\n                    break;\n                }",
)
The code is Ok(
    "digit < t",
)
The code is Ok(
    "digit",
)
The code is Ok(
    "t",
)
The code is Ok(
    "break",
)
The code is Ok(
    "weight = weight.checked_mul(BASE - t).ok_or(())?",
)
The code is Ok(
    "weight.checked_mul(BASE - t).ok_or(())?",
)
into Match call
The code is Ok(
    "weight.checked_mul(BASE - t).ok_or(())?",
)
LangItem path: idna/src/punycode.rs:225:26: 225:65 (#210)
The code is Ok(
    "weight.checked_mul(BASE - t).ok_or(())?",
)
The code is Ok(
    "weight.checked_mul(BASE - t).ok_or(())",
)
The code is Ok(
    "weight.checked_mul(BASE - t)",
)
The code is Ok(
    "weight",
)
The code is Ok(
    "BASE - t",
)
The code is Ok(
    "BASE",
)
The code is Ok(
    "t",
)
The code is Ok(
    "()",
)
The code is Ok(
    "?",
)
The code is Ok(
    "weight.checked_mul(BASE - t).ok_or(())?",
)
LangItem path: idna/src/punycode.rs:225:64: 225:65 (#211)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "weight.checked_mul(BASE - t).ok_or(())?",
)
The code is Ok(
    "weight",
)
The code is Ok(
    "k += BASE",
)
The code is Ok(
    "BASE",
)
The code is Ok(
    "k",
)
The code is Ok(
    "byte = match iter.next() {\n                    None => return Err(()), // End of input before the end of this delta\n                    Some(byte) => byte,\n                }",
)
The code is Ok(
    "match iter.next() {\n                    None => return Err(()), // End of input before the end of this delta\n                    Some(byte) => byte,\n                }",
)
The code is Ok(
    "iter.next()",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "return Err(())",
)
The code is Ok(
    "Err(())",
)
resolved new call Call { call_expr: HirId(DefId(0:81 ~ idna[bc6b]::punycode::{impl#4}::decode).365), call_expr_span: idna/src/punycode.rs:228:36: 228:43 (#0), caller: Some(DefId(0:81 ~ idna[bc6b]::punycode::{impl#4}::decode)), caller_span: None, callee: DefId(1:45572 ~ core[f118]::result::Result::Err::{constructor#0}), callee_span: idna/src/punycode.rs:228:36: 228:39 (#0), callee_path: "core::prelude::v1::Err", constraint_depth: 1 }
The code is Ok(
    "Err",
)
The code is Ok(
    "()",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "bias = adapt(i - previous_i, length + 1, previous_i == 0)",
)
The code is Ok(
    "adapt(i - previous_i, length + 1, previous_i == 0)",
)
resolved new call Call { call_expr: HirId(DefId(0:81 ~ idna[bc6b]::punycode::{impl#4}::decode).381), call_expr_span: idna/src/punycode.rs:233:20: 233:70 (#0), caller: Some(DefId(0:81 ~ idna[bc6b]::punycode::{impl#4}::decode)), caller_span: None, callee: DefId(0:49 ~ idna[bc6b]::punycode::adapt), callee_span: idna/src/punycode.rs:233:20: 233:25 (#0), callee_path: "punycode::adapt", constraint_depth: 0 }
The code is Ok(
    "adapt",
)
The code is Ok(
    "i - previous_i",
)
The code is Ok(
    "i",
)
The code is Ok(
    "previous_i",
)
The code is Ok(
    "length + 1",
)
The code is Ok(
    "length",
)
The code is Ok(
    "1",
)
The code is Ok(
    "previous_i == 0",
)
The code is Ok(
    "previous_i",
)
The code is Ok(
    "0",
)
The code is Ok(
    "bias",
)
The code is Ok(
    "code_point = code_point.checked_add(i / (length + 1)).ok_or(())?",
)
The code is Ok(
    "code_point.checked_add(i / (length + 1)).ok_or(())?",
)
into Match call
The code is Ok(
    "code_point.checked_add(i / (length + 1)).ok_or(())?",
)
LangItem path: idna/src/punycode.rs:237:26: 237:77 (#212)
The code is Ok(
    "code_point.checked_add(i / (length + 1)).ok_or(())?",
)
The code is Ok(
    "code_point.checked_add(i / (length + 1)).ok_or(())",
)
The code is Ok(
    "code_point.checked_add(i / (length + 1))",
)
The code is Ok(
    "code_point",
)
The code is Ok(
    "i / (length + 1)",
)
The code is Ok(
    "i",
)
The code is Ok(
    "(length + 1)",
)
The code is Ok(
    "length",
)
The code is Ok(
    "1",
)
The code is Ok(
    "()",
)
The code is Ok(
    "?",
)
The code is Ok(
    "code_point.checked_add(i / (length + 1)).ok_or(())?",
)
LangItem path: idna/src/punycode.rs:237:76: 237:77 (#213)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "code_point.checked_add(i / (length + 1)).ok_or(())?",
)
The code is Ok(
    "code_point",
)
The code is Ok(
    "i %= length + 1",
)
The code is Ok(
    "length + 1",
)
The code is Ok(
    "length",
)
The code is Ok(
    "1",
)
The code is Ok(
    "i",
)
The code is Ok(
    "match char::from_u32(code_point) {\n                Some(c) => c,\n                None => return Err(()),\n            }",
)
into Match call
The code is Ok(
    "char::from_u32(code_point)",
)
resolved new call Call { call_expr: HirId(DefId(0:81 ~ idna[bc6b]::punycode::{impl#4}::decode).444), call_expr_span: idna/src/punycode.rs:239:27: 239:53 (#0), caller: Some(DefId(0:81 ~ idna[bc6b]::punycode::{impl#4}::decode)), caller_span: None, callee: DefId(1:5138 ~ core[f118]::char::from_u32), callee_span: idna/src/punycode.rs:239:27: 239:41 (#0), callee_path: "core::char::from_u32", constraint_depth: 1 }
The code is Ok(
    "char::from_u32",
)
The code is Ok(
    "code_point",
)
The code is Ok(
    "c",
)
The code is Ok(
    "return Err(())",
)
The code is Ok(
    "Err(())",
)
resolved new call Call { call_expr: HirId(DefId(0:81 ~ idna[bc6b]::punycode::{impl#4}::decode).460), call_expr_span: idna/src/punycode.rs:241:32: 241:39 (#0), caller: Some(DefId(0:81 ~ idna[bc6b]::punycode::{impl#4}::decode)), caller_span: None, callee: DefId(1:45572 ~ core[f118]::result::Result::Err::{constructor#0}), callee_span: idna/src/punycode.rs:241:32: 241:35 (#0), callee_path: "core::prelude::v1::Err", constraint_depth: 1 }
The code is Ok(
    "Err",
)
The code is Ok(
    "()",
)
The code is Ok(
    "for (idx, _) in &mut self.insertions {\n                if *idx >= i as usize {\n                    *idx += 1;\n                }\n            }",
)
The code is Ok(
    "for (idx, _) in &mut self.insertions {\n                if *idx >= i as usize {\n                    *idx += 1;\n                }\n            }",
)
into Match call
The code is Ok(
    "&mut self.insertions",
)
LangItem path: idna/src/punycode.rs:245:29: 245:49 (#215)
The code is Ok(
    "&mut self.insertions",
)
The code is Ok(
    "&mut self.insertions",
)
The code is Ok(
    "self.insertions",
)
The code is Ok(
    "self",
)
The code is Ok(
    "for (idx, _) in &mut self.insertions {\n                if *idx >= i as usize {\n                    *idx += 1;\n                }\n            }",
)
The code is Ok(
    "&mut self.insertions",
)
into Match call
is inner Match
The code is Ok(
    "&mut self.insertions",
)
LangItem path: idna/src/punycode.rs:245:29: 245:49 (#215)
The code is Ok(
    "&mut self.insertions",
)
The code is Ok(
    "&mut self.insertions",
)
The code is Ok(
    "&mut self.insertions",
)
The code is Ok(
    "for (idx, _) in &mut self.insertions {\n                if *idx >= i as usize {\n                    *idx += 1;\n                }\n            }",
)
The code is Ok(
    "{\n                if *idx >= i as usize {\n                    *idx += 1;\n                }\n            }",
)
The code is Ok(
    "if *idx >= i as usize {\n                    *idx += 1;\n                }",
)
The code is Ok(
    "*idx >= i as usize",
)
The code is Ok(
    "*idx",
)
The code is Ok(
    "idx",
)
The code is Ok(
    "i as usize",
)
The code is Ok(
    "i",
)
The code is Ok(
    "*idx += 1",
)
The code is Ok(
    "1",
)
The code is Ok(
    "*idx",
)
The code is Ok(
    "idx",
)
The code is Ok(
    "self.insertions.push((i as usize, c))",
)
The code is Ok(
    "self.insertions",
)
The code is Ok(
    "self",
)
The code is Ok(
    "(i as usize, c)",
)
The code is Ok(
    "i as usize",
)
The code is Ok(
    "i",
)
The code is Ok(
    "c",
)
The code is Ok(
    "length += 1",
)
The code is Ok(
    "1",
)
The code is Ok(
    "length",
)
The code is Ok(
    "i += 1",
)
The code is Ok(
    "1",
)
The code is Ok(
    "i",
)
The code is Ok(
    "self.insertions.sort_by_key(|(i, _)| *i)",
)
The code is Ok(
    "self.insertions",
)
The code is Ok(
    "self",
)
The code is Ok(
    "|(i, _)| *i",
)
The code is Ok(
    "*i",
)
The code is Ok(
    "i",
)
The code is Ok(
    "Ok(Decode {\n            base: base.iter(),\n            insertions: &self.insertions,\n            inserted: 0,\n            position: 0,\n            len: base_len + self.insertions.len(),\n            phantom: PhantomData::<C>,\n        })",
)
resolved new call Call { call_expr: HirId(DefId(0:81 ~ idna[bc6b]::punycode::{impl#4}::decode).557), call_expr_span: idna/src/punycode.rs:256:9: 263:11 (#0), caller: Some(DefId(0:81 ~ idna[bc6b]::punycode::{impl#4}::decode)), caller_span: None, callee: DefId(1:45569 ~ core[f118]::result::Result::Ok::{constructor#0}), callee_span: idna/src/punycode.rs:256:9: 256:11 (#0), callee_path: "core::prelude::v1::Ok", constraint_depth: 0 }
The code is Ok(
    "Ok",
)
The code is Ok(
    "Decode {\n            base: base.iter(),\n            insertions: &self.insertions,\n            inserted: 0,\n            position: 0,\n            len: base_len + self.insertions.len(),\n            phantom: PhantomData::<C>,\n        }",
)
The code is Ok(
    "base.iter()",
)
The code is Ok(
    "base",
)
The code is Ok(
    "&self.insertions",
)
The code is Ok(
    "self.insertions",
)
The code is Ok(
    "self",
)
The code is Ok(
    "0",
)
The code is Ok(
    "0",
)
The code is Ok(
    "base_len + self.insertions.len()",
)
The code is Ok(
    "base_len",
)
The code is Ok(
    "self.insertions.len()",
)
The code is Ok(
    "self.insertions",
)
The code is Ok(
    "self",
)
The code is Ok(
    "PhantomData::<C>",
)
The code is Ok(
    "{\n        loop {\n            match self.insertions.get(self.inserted) {\n                Some((pos, c)) if *pos == self.position => {\n                    self.inserted += 1;\n                    self.position += 1;\n                    return Some(*c);\n                }\n                _ => {}\n            }\n            if let Some(c) = self.base.next() {\n                self.position += 1;\n                return Some(if C::EXTERNAL_CALLER {\n                    c.char()\n                } else {\n                    c.char_ascii_lower_case()\n                });\n            } else if self.inserted >= self.insertions.len() {\n                return None;\n            }\n        }\n    }",
)
The code is Ok(
    "loop {\n            match self.insertions.get(self.inserted) {\n                Some((pos, c)) if *pos == self.position => {\n                    self.inserted += 1;\n                    self.position += 1;\n                    return Some(*c);\n                }\n                _ => {}\n            }\n            if let Some(c) = self.base.next() {\n                self.position += 1;\n                return Some(if C::EXTERNAL_CALLER {\n                    c.char()\n                } else {\n                    c.char_ascii_lower_case()\n                });\n            } else if self.inserted >= self.insertions.len() {\n                return None;\n            }\n        }",
)
The code is Ok(
    "match self.insertions.get(self.inserted) {\n                Some((pos, c)) if *pos == self.position => {\n                    self.inserted += 1;\n                    self.position += 1;\n                    return Some(*c);\n                }\n                _ => {}\n            }",
)
The code is Ok(
    "self.insertions.get(self.inserted)",
)
The code is Ok(
    "self.insertions",
)
The code is Ok(
    "self",
)
The code is Ok(
    "self.inserted",
)
The code is Ok(
    "self",
)
The code is Ok(
    "*pos == self.position",
)
The code is Ok(
    "*pos",
)
The code is Ok(
    "pos",
)
The code is Ok(
    "self.position",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n                    self.inserted += 1;\n                    self.position += 1;\n                    return Some(*c);\n                }",
)
The code is Ok(
    "self.inserted += 1",
)
The code is Ok(
    "1",
)
The code is Ok(
    "self.inserted",
)
The code is Ok(
    "self",
)
The code is Ok(
    "self.position += 1",
)
The code is Ok(
    "1",
)
The code is Ok(
    "self.position",
)
The code is Ok(
    "self",
)
The code is Ok(
    "return Some(*c)",
)
The code is Ok(
    "Some(*c)",
)
resolved new call Call { call_expr: HirId(DefId(0:102 ~ idna[bc6b]::punycode::{impl#5}::next).40), call_expr_span: idna/src/punycode.rs:289:28: 289:36 (#0), caller: Some(DefId(0:102 ~ idna[bc6b]::punycode::{impl#5}::next)), caller_span: None, callee: DefId(1:45302 ~ core[f118]::option::Option::Some::{constructor#0}), callee_span: idna/src/punycode.rs:289:28: 289:32 (#0), callee_path: "core::prelude::v1::Some", constraint_depth: 1 }
The code is Ok(
    "Some",
)
The code is Ok(
    "*c",
)
The code is Ok(
    "c",
)
The code is Ok(
    "{}",
)
The code is Ok(
    "if let Some(c) = self.base.next() {\n                self.position += 1;\n                return Some(if C::EXTERNAL_CALLER {\n                    c.char()\n                } else {\n                    c.char_ascii_lower_case()\n                });\n            } else if self.inserted >= self.insertions.len() {\n                return None;\n            }",
)
The code is Ok(
    "self.base.next()",
)
The code is Ok(
    "self.base",
)
The code is Ok(
    "self",
)
The code is Ok(
    "self.position += 1",
)
The code is Ok(
    "1",
)
The code is Ok(
    "self.position",
)
The code is Ok(
    "self",
)
The code is Ok(
    "return Some(if C::EXTERNAL_CALLER {\n                    c.char()\n                } else {\n                    c.char_ascii_lower_case()\n                })",
)
The code is Ok(
    "Some(if C::EXTERNAL_CALLER {\n                    c.char()\n                } else {\n                    c.char_ascii_lower_case()\n                })",
)
resolved new call Call { call_expr: HirId(DefId(0:102 ~ idna[bc6b]::punycode::{impl#5}::next).70), call_expr_span: idna/src/punycode.rs:295:24: 299:19 (#0), caller: Some(DefId(0:102 ~ idna[bc6b]::punycode::{impl#5}::next)), caller_span: None, callee: DefId(1:45302 ~ core[f118]::option::Option::Some::{constructor#0}), callee_span: idna/src/punycode.rs:295:24: 295:28 (#0), callee_path: "core::prelude::v1::Some", constraint_depth: 1 }
The code is Ok(
    "Some",
)
The code is Ok(
    "if C::EXTERNAL_CALLER {\n                    c.char()\n                } else {\n                    c.char_ascii_lower_case()\n                }",
)
The code is Ok(
    "C::EXTERNAL_CALLER",
)
The code is Ok(
    "c.char()",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:102 ~ idna[bc6b]::punycode::{impl#5}::next).79),
    call_expr_span: idna/src/punycode.rs:296:21: 296:29 (#0),
    caller: Some(
        DefId(0:102 ~ idna[bc6b]::punycode::{impl#5}::next),
    ),
    caller_span: None,
    callee: DefId(0:66 ~ idna[bc6b]::punycode::PunycodeCodeUnit::char),
    callee_span: idna/src/punycode.rs:296:21: 296:29 (#0),
    callee_path: "punycode::PunycodeCodeUnit::char",
    constraint_depth: 2,
}
The code is Ok(
    "c",
)
The code is Ok(
    "c.char_ascii_lower_case()",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:102 ~ idna[bc6b]::punycode::{impl#5}::next).86),
    call_expr_span: idna/src/punycode.rs:298:21: 298:46 (#0),
    caller: Some(
        DefId(0:102 ~ idna[bc6b]::punycode::{impl#5}::next),
    ),
    caller_span: None,
    callee: DefId(0:67 ~ idna[bc6b]::punycode::PunycodeCodeUnit::char_ascii_lower_case),
    callee_span: idna/src/punycode.rs:298:21: 298:46 (#0),
    callee_path: "punycode::PunycodeCodeUnit::char_ascii_lower_case",
    constraint_depth: 2,
}
The code is Ok(
    "c",
)
The code is Ok(
    "self.inserted >= self.insertions.len()",
)
The code is Ok(
    "self.inserted >= self.insertions.len()",
)
The code is Ok(
    "self.inserted",
)
The code is Ok(
    "self",
)
The code is Ok(
    "self.insertions.len()",
)
The code is Ok(
    "self.insertions",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n                return None;\n            }",
)
The code is Ok(
    "return None",
)
The code is Ok(
    "None",
)
The code is Ok(
    "{\n        let len = self.len - self.position;\n        (len, Some(len))\n    }",
)
The code is Ok(
    "self.len - self.position",
)
The code is Ok(
    "self.len",
)
The code is Ok(
    "self",
)
The code is Ok(
    "self.position",
)
The code is Ok(
    "self",
)
The code is Ok(
    "(len, Some(len))",
)
The code is Ok(
    "len",
)
The code is Ok(
    "Some(len)",
)
resolved new call Call { call_expr: HirId(DefId(0:103 ~ idna[bc6b]::punycode::{impl#5}::size_hint).16), call_expr_span: idna/src/punycode.rs:308:15: 308:24 (#0), caller: Some(DefId(0:103 ~ idna[bc6b]::punycode::{impl#5}::size_hint)), caller_span: None, callee: DefId(1:45302 ~ core[f118]::option::Option::Some::{constructor#0}), callee_span: idna/src/punycode.rs:308:15: 308:19 (#0), callee_path: "core::prelude::v1::Some", constraint_depth: 0 }
The code is Ok(
    "Some",
)
The code is Ok(
    "len",
)
The code is Ok(
    "{\n        self.len - self.position\n    }",
)
The code is Ok(
    "self.len - self.position",
)
The code is Ok(
    "self.len",
)
The code is Ok(
    "self",
)
The code is Ok(
    "self.position",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        PunycodeEncodeError::Sink\n    }",
)
The code is Ok(
    "PunycodeEncodeError::Sink",
)
The code is Ok(
    "{\n        let mut bits = UPPER_CASE_MASK;\n        if deny_glyphless {\n            bits |= GLYPHLESS_MASK;\n        }\n        let mut i = 0;\n        let bytes = deny_list.as_bytes();\n        while i < bytes.len() {\n            let b = bytes[i];\n            assert!(b < 0x80, \"ASCII deny list must be ASCII.\");\n            // assert_ne not yet available in const context.\n            assert!(b != b'.', \"ASCII deny list must not contain the dot.\");\n            assert!(b != b'-', \"ASCII deny list must not contain the hyphen.\");\n            assert!(\n                !((b >= b'0') && (b <= b'9')),\n                \"ASCII deny list must not contain digits.\"\n            );\n            assert!(\n                !((b >= b'a') && (b <= b'z')),\n                \"ASCII deny list must not contain letters.\"\n            );\n            assert!(\n                !((b >= b'A') && (b <= b'Z')),\n                \"ASCII deny list must not contain letters.\"\n            );\n            bits |= 1u128 << b;\n            i += 1;\n        }\n        AsciiDenyList { bits }\n    }",
)
The code is Ok(
    "UPPER_CASE_MASK",
)
The code is Ok(
    "if deny_glyphless {\n            bits |= GLYPHLESS_MASK;\n        }",
)
The code is Ok(
    "deny_glyphless",
)
The code is Ok(
    "bits |= GLYPHLESS_MASK",
)
The code is Ok(
    "GLYPHLESS_MASK",
)
The code is Ok(
    "bits",
)
The code is Ok(
    "0",
)
The code is Ok(
    "deny_list.as_bytes()",
)
The code is Ok(
    "deny_list",
)
The code is Ok(
    "while i < bytes.len() {\n            let b = bytes[i];\n            assert!(b < 0x80, \"ASCII deny list must be ASCII.\");\n            // assert_ne not yet available in const context.\n            assert!(b != b'.', \"ASCII deny list must not contain the dot.\");\n            assert!(b != b'-', \"ASCII deny list must not contain the hyphen.\");\n            assert!(\n                !((b >= b'0') && (b <= b'9')),\n                \"ASCII deny list must not contain digits.\"\n            );\n            assert!(\n                !((b >= b'a') && (b <= b'z')),\n                \"ASCII deny list must not contain letters.\"\n            );\n            assert!(\n                !((b >= b'A') && (b <= b'Z')),\n                \"ASCII deny list must not contain letters.\"\n            );\n            bits |= 1u128 << b;\n            i += 1;\n        }",
)
The code is Ok(
    "while i < bytes.len() {\n            let b = bytes[i];\n            assert!(b < 0x80, \"ASCII deny list must be ASCII.\");\n            // assert_ne not yet available in const context.\n            assert!(b != b'.', \"ASCII deny list must not contain the dot.\");\n            assert!(b != b'-', \"ASCII deny list must not contain the hyphen.\");\n            assert!(\n                !((b >= b'0') && (b <= b'9')),\n                \"ASCII deny list must not contain digits.\"\n            );\n            assert!(\n                !((b >= b'a') && (b <= b'z')),\n                \"ASCII deny list must not contain letters.\"\n            );\n            assert!(\n                !((b >= b'A') && (b <= b'Z')),\n                \"ASCII deny list must not contain letters.\"\n            );\n            bits |= 1u128 << b;\n            i += 1;\n        }",
)
The code is Ok(
    "i < bytes.len()",
)
The code is Ok(
    "i",
)
The code is Ok(
    "bytes.len()",
)
The code is Ok(
    "bytes",
)
The code is Ok(
    "bytes[i]",
)
The code is Ok(
    "bytes",
)
The code is Ok(
    "i",
)
The code is Ok(
    "assert!(b < 0x80, \"ASCII deny list must be ASCII.\")",
)
The code is Ok(
    "assert!(b < 0x80, \"ASCII deny list must be ASCII.\")",
)
The code is Ok(
    "b < 0x80",
)
The code is Ok(
    "b",
)
The code is Ok(
    "0x80",
)
The code is Ok(
    "$crate::panicking::panic($msg)",
)
resolved new call Call { call_expr: HirId(DefId(0:158 ~ idna[bc6b]::uts46::{impl#0}::new).58), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:29:9: 29:39 (#47), caller: Some(DefId(0:158 ~ idna[bc6b]::uts46::{impl#0}::new)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:29:9: 29:33 (#47), callee_path: "core::panicking::panic", constraint_depth: 2 }
The code is Ok(
    "$crate::panicking::panic",
)
The code is Ok(
    "\"ASCII deny list must be ASCII.\"",
)
The code is Ok(
    "assert!(b != b'.', \"ASCII deny list must not contain the dot.\")",
)
The code is Ok(
    "assert!(b != b'.', \"ASCII deny list must not contain the dot.\")",
)
The code is Ok(
    "b != b'.'",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'.'",
)
The code is Ok(
    "$crate::panicking::panic($msg)",
)
resolved new call Call { call_expr: HirId(DefId(0:158 ~ idna[bc6b]::uts46::{impl#0}::new).74), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:29:9: 29:39 (#51), caller: Some(DefId(0:158 ~ idna[bc6b]::uts46::{impl#0}::new)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:29:9: 29:33 (#51), callee_path: "core::panicking::panic", constraint_depth: 2 }
The code is Ok(
    "$crate::panicking::panic",
)
The code is Ok(
    "\"ASCII deny list must not contain the dot.\"",
)
The code is Ok(
    "assert!(b != b'-', \"ASCII deny list must not contain the hyphen.\")",
)
The code is Ok(
    "assert!(b != b'-', \"ASCII deny list must not contain the hyphen.\")",
)
The code is Ok(
    "b != b'-'",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'-'",
)
The code is Ok(
    "$crate::panicking::panic($msg)",
)
resolved new call Call { call_expr: HirId(DefId(0:158 ~ idna[bc6b]::uts46::{impl#0}::new).90), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:29:9: 29:39 (#55), caller: Some(DefId(0:158 ~ idna[bc6b]::uts46::{impl#0}::new)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:29:9: 29:33 (#55), callee_path: "core::panicking::panic", constraint_depth: 2 }
The code is Ok(
    "$crate::panicking::panic",
)
The code is Ok(
    "\"ASCII deny list must not contain the hyphen.\"",
)
The code is Ok(
    "assert!(\n                !((b >= b'0') && (b <= b'9')),\n                \"ASCII deny list must not contain digits.\"\n            )",
)
The code is Ok(
    "assert!(\n                !((b >= b'0') && (b <= b'9')),\n                \"ASCII deny list must not contain digits.\"\n            )",
)
The code is Ok(
    "!((b >= b'0') && (b <= b'9'))",
)
The code is Ok(
    "((b >= b'0') && (b <= b'9'))",
)
The code is Ok(
    "(b >= b'0')",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'0'",
)
The code is Ok(
    "(b <= b'9')",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'9'",
)
The code is Ok(
    "$crate::panicking::panic($msg)",
)
resolved new call Call { call_expr: HirId(DefId(0:158 ~ idna[bc6b]::uts46::{impl#0}::new).112), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:29:9: 29:39 (#59), caller: Some(DefId(0:158 ~ idna[bc6b]::uts46::{impl#0}::new)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:29:9: 29:33 (#59), callee_path: "core::panicking::panic", constraint_depth: 2 }
The code is Ok(
    "$crate::panicking::panic",
)
The code is Ok(
    "\"ASCII deny list must not contain digits.\"",
)
The code is Ok(
    "assert!(\n                !((b >= b'a') && (b <= b'z')),\n                \"ASCII deny list must not contain letters.\"\n            )",
)
The code is Ok(
    "assert!(\n                !((b >= b'a') && (b <= b'z')),\n                \"ASCII deny list must not contain letters.\"\n            )",
)
The code is Ok(
    "!((b >= b'a') && (b <= b'z'))",
)
The code is Ok(
    "((b >= b'a') && (b <= b'z'))",
)
The code is Ok(
    "(b >= b'a')",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'a'",
)
The code is Ok(
    "(b <= b'z')",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'z'",
)
The code is Ok(
    "$crate::panicking::panic($msg)",
)
resolved new call Call { call_expr: HirId(DefId(0:158 ~ idna[bc6b]::uts46::{impl#0}::new).134), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:29:9: 29:39 (#63), caller: Some(DefId(0:158 ~ idna[bc6b]::uts46::{impl#0}::new)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:29:9: 29:33 (#63), callee_path: "core::panicking::panic", constraint_depth: 2 }
The code is Ok(
    "$crate::panicking::panic",
)
The code is Ok(
    "\"ASCII deny list must not contain letters.\"",
)
The code is Ok(
    "assert!(\n                !((b >= b'A') && (b <= b'Z')),\n                \"ASCII deny list must not contain letters.\"\n            )",
)
The code is Ok(
    "assert!(\n                !((b >= b'A') && (b <= b'Z')),\n                \"ASCII deny list must not contain letters.\"\n            )",
)
The code is Ok(
    "!((b >= b'A') && (b <= b'Z'))",
)
The code is Ok(
    "((b >= b'A') && (b <= b'Z'))",
)
The code is Ok(
    "(b >= b'A')",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'A'",
)
The code is Ok(
    "(b <= b'Z')",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'Z'",
)
The code is Ok(
    "$crate::panicking::panic($msg)",
)
resolved new call Call { call_expr: HirId(DefId(0:158 ~ idna[bc6b]::uts46::{impl#0}::new).156), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:29:9: 29:39 (#67), caller: Some(DefId(0:158 ~ idna[bc6b]::uts46::{impl#0}::new)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:29:9: 29:33 (#67), callee_path: "core::panicking::panic", constraint_depth: 2 }
The code is Ok(
    "$crate::panicking::panic",
)
The code is Ok(
    "\"ASCII deny list must not contain letters.\"",
)
The code is Ok(
    "bits |= 1u128 << b",
)
The code is Ok(
    "1u128 << b",
)
The code is Ok(
    "1u128",
)
The code is Ok(
    "b",
)
The code is Ok(
    "bits",
)
The code is Ok(
    "i += 1",
)
The code is Ok(
    "1",
)
The code is Ok(
    "i",
)
The code is Ok(
    "while i < bytes.len() {\n            let b = bytes[i];\n            assert!(b < 0x80, \"ASCII deny list must be ASCII.\");\n            // assert_ne not yet available in const context.\n            assert!(b != b'.', \"ASCII deny list must not contain the dot.\");\n            assert!(b != b'-', \"ASCII deny list must not contain the hyphen.\");\n            assert!(\n                !((b >= b'0') && (b <= b'9')),\n                \"ASCII deny list must not contain digits.\"\n            );\n            assert!(\n                !((b >= b'a') && (b <= b'z')),\n                \"ASCII deny list must not contain letters.\"\n            );\n            assert!(\n                !((b >= b'A') && (b <= b'Z')),\n                \"ASCII deny list must not contain letters.\"\n            );\n            bits |= 1u128 << b;\n            i += 1;\n        }",
)
The code is Ok(
    "AsciiDenyList { bits }",
)
The code is Ok(
    "bits",
)
The code is Ok(
    "AsciiDenyList::new(false, \"\")",
)
The code is Ok(
    "AsciiDenyList::new",
)
The code is Ok(
    "false",
)
The code is Ok(
    "\"\"",
)
The code is Ok(
    "AsciiDenyList { bits: ldh_mask() }",
)
The code is Ok(
    "ldh_mask()",
)
resolved new call Call { call_expr: HirId(DefId(0:160 ~ idna[bc6b]::uts46::{impl#0}::STD3).6), call_expr_span: idna/src/uts46.rs:342:59: 342:69 (#0), caller: None, caller_span: None, callee: DefId(0:142 ~ idna[bc6b]::uts46::ldh_mask), callee_span: idna/src/uts46.rs:342:59: 342:67 (#0), callee_path: "uts46::ldh_mask", constraint_depth: 0 }
The code is Ok(
    "ldh_mask",
)
The code is Ok(
    "AsciiDenyList::new(true, \"%#/:<>?@[\\\\]^|\")",
)
The code is Ok(
    "AsciiDenyList::new",
)
The code is Ok(
    "true",
)
The code is Ok(
    "\"%#/:<>?@[\\\\]^|\"",
)
The code is Ok(
    "{\n        ProcessingError::SinkError\n    }",
)
The code is Ok(
    "ProcessingError::SinkError",
)
The code is Ok(
    "{\n        unreachable!(\n            \"Punycode overflows should not be possible due to PUNYCODE_ENCODE_MAX_INPUT_LENGTH\"\n        );\n    }",
)
The code is Ok(
    "{\n        $crate::panicking::unreachable_display(&$msg);\n    }",
)
The code is Ok(
    "$crate::panicking::unreachable_display(&$msg)",
)
resolved new call Call { call_expr: HirId(DefId(0:165 ~ idna[bc6b]::uts46::{impl#2}::from).4), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:123:9: 123:54 (#92), caller: Some(DefId(0:165 ~ idna[bc6b]::uts46::{impl#2}::from)), caller_span: None, callee: DefId(1:9580 ~ core[f118]::panicking::unreachable_display), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:123:9: 123:47 (#92), callee_path: "core::panicking::unreachable_display", constraint_depth: 0 }
The code is Ok(
    "$crate::panicking::unreachable_display",
)
The code is Ok(
    "&$msg",
)
The code is Ok(
    "\"Punycode overflows should not be possible due to PUNYCODE_ENCODE_MAX_INPUT_LENGTH\"",
)
The code is Ok(
    "{\n        Self::new()\n    }",
)
The code is Ok(
    "Self::new()",
)
The code is Ok(
    "Self::new",
)
The code is Ok(
    "{\n        Self {\n            data: idna_adapter::Adapter::new(),\n        }\n    }",
)
The code is Ok(
    "Self {\n            data: idna_adapter::Adapter::new(),\n        }",
)
The code is Ok(
    "idna_adapter::Adapter::new()",
)
The code is Ok(
    "idna_adapter::Adapter::new",
)
The code is Ok(
    "{\n        let mut s = String::new();\n        match self.process(\n            domain_name,\n            ascii_deny_list,\n            hyphens,\n            ErrorPolicy::FailFast,\n            |_, _, _| false,\n            &mut s,\n            None,\n        ) {\n            // SAFETY: `ProcessingSuccess::Passthrough` asserts that `domain_name` is ASCII.\n            Ok(ProcessingSuccess::Passthrough) => {\n                let cow = Cow::Borrowed(unsafe { core::str::from_utf8_unchecked(domain_name) });\n                if dns_length != DnsLength::Ignore\n                    && !verify_dns_length(&cow, dns_length == DnsLength::VerifyAllowRootDot)\n                {\n                    Err(crate::Errors::default())\n                } else {\n                    Ok(cow)\n                }\n            }\n            Ok(ProcessingSuccess::WroteToSink) => {\n                let cow: Cow<'_, str> = Cow::Owned(s);\n                if dns_length != DnsLength::Ignore\n                    && !verify_dns_length(&cow, dns_length == DnsLength::VerifyAllowRootDot)\n                {\n                    Err(crate::Errors::default())\n                } else {\n                    Ok(cow)\n                }\n            }\n            Err(ProcessingError::ValidityError) => Err(crate::Errors::default()),\n            Err(ProcessingError::SinkError) => unreachable!(),\n        }\n    }",
)
The code is Ok(
    "String::new()",
)
The code is Ok(
    "String::new",
)
The code is Ok(
    "match self.process(\n            domain_name,\n            ascii_deny_list,\n            hyphens,\n            ErrorPolicy::FailFast,\n            |_, _, _| false,\n            &mut s,\n            None,\n        ) {\n            // SAFETY: `ProcessingSuccess::Passthrough` asserts that `domain_name` is ASCII.\n            Ok(ProcessingSuccess::Passthrough) => {\n                let cow = Cow::Borrowed(unsafe { core::str::from_utf8_unchecked(domain_name) });\n                if dns_length != DnsLength::Ignore\n                    && !verify_dns_length(&cow, dns_length == DnsLength::VerifyAllowRootDot)\n                {\n                    Err(crate::Errors::default())\n                } else {\n                    Ok(cow)\n                }\n            }\n            Ok(ProcessingSuccess::WroteToSink) => {\n                let cow: Cow<'_, str> = Cow::Owned(s);\n                if dns_length != DnsLength::Ignore\n                    && !verify_dns_length(&cow, dns_length == DnsLength::VerifyAllowRootDot)\n                {\n                    Err(crate::Errors::default())\n                } else {\n                    Ok(cow)\n                }\n            }\n            Err(ProcessingError::ValidityError) => Err(crate::Errors::default()),\n            Err(ProcessingError::SinkError) => unreachable!(),\n        }",
)
The code is Ok(
    "self.process(\n            domain_name,\n            ascii_deny_list,\n            hyphens,\n            ErrorPolicy::FailFast,\n            |_, _, _| false,\n            &mut s,\n            None,\n        )",
)
The code is Ok(
    "self",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "ascii_deny_list",
)
The code is Ok(
    "hyphens",
)
The code is Ok(
    "ErrorPolicy::FailFast",
)
The code is Ok(
    "|_, _, _| false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "&mut s",
)
The code is Ok(
    "s",
)
The code is Ok(
    "None",
)
The code is Ok(
    "{\n                let cow = Cow::Borrowed(unsafe { core::str::from_utf8_unchecked(domain_name) });\n                if dns_length != DnsLength::Ignore\n                    && !verify_dns_length(&cow, dns_length == DnsLength::VerifyAllowRootDot)\n                {\n                    Err(crate::Errors::default())\n                } else {\n                    Ok(cow)\n                }\n            }",
)
The code is Ok(
    "Cow::Borrowed(unsafe { core::str::from_utf8_unchecked(domain_name) })",
)
resolved new call Call { call_expr: HirId(DefId(0:174 ~ idna[bc6b]::uts46::{impl#4}::to_ascii).57), call_expr_span: idna/src/uts46.rs:546:27: 546:96 (#0), caller: Some(DefId(0:174 ~ idna[bc6b]::uts46::{impl#4}::to_ascii)), caller_span: None, callee: DefId(5:791 ~ alloc[186e]::borrow::Cow::Borrowed::{constructor#0}), callee_span: idna/src/uts46.rs:546:27: 546:40 (#0), callee_path: "std::borrow::Cow::Borrowed", constraint_depth: 1 }
The code is Ok(
    "Cow::Borrowed",
)
The code is Ok(
    "unsafe { core::str::from_utf8_unchecked(domain_name) }",
)
The code is Ok(
    "core::str::from_utf8_unchecked(domain_name)",
)
resolved new call Call { call_expr: HirId(DefId(0:174 ~ idna[bc6b]::uts46::{impl#4}::to_ascii).62), call_expr_span: idna/src/uts46.rs:546:50: 546:93 (#0), caller: Some(DefId(0:174 ~ idna[bc6b]::uts46::{impl#4}::to_ascii)), caller_span: None, callee: DefId(1:12976 ~ core[f118]::str::converts::from_utf8_unchecked), callee_span: idna/src/uts46.rs:546:50: 546:80 (#0), callee_path: "core::str::from_utf8_unchecked", constraint_depth: 1 }
The code is Ok(
    "core::str::from_utf8_unchecked",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "if dns_length != DnsLength::Ignore\n                    && !verify_dns_length(&cow, dns_length == DnsLength::VerifyAllowRootDot)\n                {\n                    Err(crate::Errors::default())\n                } else {\n                    Ok(cow)\n                }",
)
The code is Ok(
    "dns_length != DnsLength::Ignore\n                    && !verify_dns_length(&cow, dns_length == DnsLength::VerifyAllowRootDot)",
)
The code is Ok(
    "dns_length != DnsLength::Ignore",
)
The code is Ok(
    "dns_length",
)
The code is Ok(
    "DnsLength::Ignore",
)
The code is Ok(
    "!verify_dns_length(&cow, dns_length == DnsLength::VerifyAllowRootDot)",
)
The code is Ok(
    "verify_dns_length(&cow, dns_length == DnsLength::VerifyAllowRootDot)",
)
resolved new call Call { call_expr: HirId(DefId(0:174 ~ idna[bc6b]::uts46::{impl#4}::to_ascii).81), call_expr_span: idna/src/uts46.rs:548:25: 548:93 (#0), caller: Some(DefId(0:174 ~ idna[bc6b]::uts46::{impl#4}::to_ascii)), caller_span: None, callee: DefId(0:166 ~ idna[bc6b]::uts46::verify_dns_length), callee_span: idna/src/uts46.rs:548:25: 548:42 (#0), callee_path: "uts46::verify_dns_length", constraint_depth: 2 }
The code is Ok(
    "verify_dns_length",
)
The code is Ok(
    "&cow",
)
The code is Ok(
    "cow",
)
The code is Ok(
    "dns_length == DnsLength::VerifyAllowRootDot",
)
The code is Ok(
    "dns_length",
)
The code is Ok(
    "DnsLength::VerifyAllowRootDot",
)
The code is Ok(
    "Err(crate::Errors::default())",
)
resolved new call Call { call_expr: HirId(DefId(0:174 ~ idna[bc6b]::uts46::{impl#4}::to_ascii).94), call_expr_span: idna/src/uts46.rs:550:21: 550:50 (#0), caller: Some(DefId(0:174 ~ idna[bc6b]::uts46::{impl#4}::to_ascii)), caller_span: None, callee: DefId(1:45572 ~ core[f118]::result::Result::Err::{constructor#0}), callee_span: idna/src/uts46.rs:550:21: 550:24 (#0), callee_path: "core::prelude::v1::Err", constraint_depth: 3 }
The code is Ok(
    "Err",
)
The code is Ok(
    "crate::Errors::default()",
)
The code is Ok(
    "crate::Errors::default",
)
The code is Ok(
    "Ok(cow)",
)
resolved new call Call { call_expr: HirId(DefId(0:174 ~ idna[bc6b]::uts46::{impl#4}::to_ascii).106), call_expr_span: idna/src/uts46.rs:552:21: 552:28 (#0), caller: Some(DefId(0:174 ~ idna[bc6b]::uts46::{impl#4}::to_ascii)), caller_span: None, callee: DefId(1:45569 ~ core[f118]::result::Result::Ok::{constructor#0}), callee_span: idna/src/uts46.rs:552:21: 552:23 (#0), callee_path: "core::prelude::v1::Ok", constraint_depth: 3 }
The code is Ok(
    "Ok",
)
The code is Ok(
    "cow",
)
The code is Ok(
    "{\n                let cow: Cow<'_, str> = Cow::Owned(s);\n                if dns_length != DnsLength::Ignore\n                    && !verify_dns_length(&cow, dns_length == DnsLength::VerifyAllowRootDot)\n                {\n                    Err(crate::Errors::default())\n                } else {\n                    Ok(cow)\n                }\n            }",
)
The code is Ok(
    "Cow::Owned(s)",
)
resolved new call Call { call_expr: HirId(DefId(0:174 ~ idna[bc6b]::uts46::{impl#4}::to_ascii).126), call_expr_span: idna/src/uts46.rs:556:41: 556:54 (#0), caller: Some(DefId(0:174 ~ idna[bc6b]::uts46::{impl#4}::to_ascii)), caller_span: None, callee: DefId(5:794 ~ alloc[186e]::borrow::Cow::Owned::{constructor#0}), callee_span: idna/src/uts46.rs:556:41: 556:51 (#0), callee_path: "std::borrow::Cow::Owned", constraint_depth: 1 }
The code is Ok(
    "Cow::Owned",
)
The code is Ok(
    "s",
)
The code is Ok(
    "if dns_length != DnsLength::Ignore\n                    && !verify_dns_length(&cow, dns_length == DnsLength::VerifyAllowRootDot)\n                {\n                    Err(crate::Errors::default())\n                } else {\n                    Ok(cow)\n                }",
)
The code is Ok(
    "dns_length != DnsLength::Ignore\n                    && !verify_dns_length(&cow, dns_length == DnsLength::VerifyAllowRootDot)",
)
The code is Ok(
    "dns_length != DnsLength::Ignore",
)
The code is Ok(
    "dns_length",
)
The code is Ok(
    "DnsLength::Ignore",
)
The code is Ok(
    "!verify_dns_length(&cow, dns_length == DnsLength::VerifyAllowRootDot)",
)
The code is Ok(
    "verify_dns_length(&cow, dns_length == DnsLength::VerifyAllowRootDot)",
)
resolved new call Call { call_expr: HirId(DefId(0:174 ~ idna[bc6b]::uts46::{impl#4}::to_ascii).143), call_expr_span: idna/src/uts46.rs:558:25: 558:93 (#0), caller: Some(DefId(0:174 ~ idna[bc6b]::uts46::{impl#4}::to_ascii)), caller_span: None, callee: DefId(0:166 ~ idna[bc6b]::uts46::verify_dns_length), callee_span: idna/src/uts46.rs:558:25: 558:42 (#0), callee_path: "uts46::verify_dns_length", constraint_depth: 2 }
The code is Ok(
    "verify_dns_length",
)
The code is Ok(
    "&cow",
)
The code is Ok(
    "cow",
)
The code is Ok(
    "dns_length == DnsLength::VerifyAllowRootDot",
)
The code is Ok(
    "dns_length",
)
The code is Ok(
    "DnsLength::VerifyAllowRootDot",
)
The code is Ok(
    "Err(crate::Errors::default())",
)
resolved new call Call { call_expr: HirId(DefId(0:174 ~ idna[bc6b]::uts46::{impl#4}::to_ascii).156), call_expr_span: idna/src/uts46.rs:560:21: 560:50 (#0), caller: Some(DefId(0:174 ~ idna[bc6b]::uts46::{impl#4}::to_ascii)), caller_span: None, callee: DefId(1:45572 ~ core[f118]::result::Result::Err::{constructor#0}), callee_span: idna/src/uts46.rs:560:21: 560:24 (#0), callee_path: "core::prelude::v1::Err", constraint_depth: 3 }
The code is Ok(
    "Err",
)
The code is Ok(
    "crate::Errors::default()",
)
The code is Ok(
    "crate::Errors::default",
)
The code is Ok(
    "Ok(cow)",
)
resolved new call Call { call_expr: HirId(DefId(0:174 ~ idna[bc6b]::uts46::{impl#4}::to_ascii).168), call_expr_span: idna/src/uts46.rs:562:21: 562:28 (#0), caller: Some(DefId(0:174 ~ idna[bc6b]::uts46::{impl#4}::to_ascii)), caller_span: None, callee: DefId(1:45569 ~ core[f118]::result::Result::Ok::{constructor#0}), callee_span: idna/src/uts46.rs:562:21: 562:23 (#0), callee_path: "core::prelude::v1::Ok", constraint_depth: 3 }
The code is Ok(
    "Ok",
)
The code is Ok(
    "cow",
)
The code is Ok(
    "Err(crate::Errors::default())",
)
resolved new call Call { call_expr: HirId(DefId(0:174 ~ idna[bc6b]::uts46::{impl#4}::to_ascii).181), call_expr_span: idna/src/uts46.rs:565:52: 565:81 (#0), caller: Some(DefId(0:174 ~ idna[bc6b]::uts46::{impl#4}::to_ascii)), caller_span: None, callee: DefId(1:45572 ~ core[f118]::result::Result::Err::{constructor#0}), callee_span: idna/src/uts46.rs:565:52: 565:55 (#0), callee_path: "core::prelude::v1::Err", constraint_depth: 1 }
The code is Ok(
    "Err",
)
The code is Ok(
    "crate::Errors::default()",
)
The code is Ok(
    "crate::Errors::default",
)
The code is Ok(
    "$crate::panicking::panic(\"internal error: entered unreachable code\")",
)
resolved new call Call { call_expr: HirId(DefId(0:174 ~ idna[bc6b]::uts46::{impl#4}::to_ascii).196), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:118:9: 118:77 (#102), caller: Some(DefId(0:174 ~ idna[bc6b]::uts46::{impl#4}::to_ascii)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:118:9: 118:33 (#102), callee_path: "core::panicking::panic", constraint_depth: 1 }
The code is Ok(
    "$crate::panicking::panic",
)
The code is Ok(
    "\"internal error: entered unreachable code\"",
)
The code is Ok(
    "{\n        self.to_user_interface(domain_name, ascii_deny_list, hyphens, |_, _, _| true)\n    }",
)
The code is Ok(
    "self.to_user_interface(domain_name, ascii_deny_list, hyphens, |_, _, _| true)",
)
The code is Ok(
    "self",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "ascii_deny_list",
)
The code is Ok(
    "hyphens",
)
The code is Ok(
    "|_, _, _| true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "{\n        let mut s = String::new();\n        match self.process(\n            domain_name,\n            ascii_deny_list,\n            hyphens,\n            ErrorPolicy::MarkErrors,\n            output_as_unicode,\n            &mut s,\n            None,\n        ) {\n            // SAFETY: `ProcessingSuccess::Passthrough` asserts that `domain_name` is ASCII.\n            Ok(ProcessingSuccess::Passthrough) => (\n                Cow::Borrowed(unsafe { core::str::from_utf8_unchecked(domain_name) }),\n                Ok(()),\n            ),\n            Ok(ProcessingSuccess::WroteToSink) => (Cow::Owned(s), Ok(())),\n            Err(ProcessingError::ValidityError) => (Cow::Owned(s), Err(crate::Errors::default())),\n            Err(ProcessingError::SinkError) => unreachable!(),\n        }\n    }",
)
The code is Ok(
    "String::new()",
)
The code is Ok(
    "String::new",
)
The code is Ok(
    "match self.process(\n            domain_name,\n            ascii_deny_list,\n            hyphens,\n            ErrorPolicy::MarkErrors,\n            output_as_unicode,\n            &mut s,\n            None,\n        ) {\n            // SAFETY: `ProcessingSuccess::Passthrough` asserts that `domain_name` is ASCII.\n            Ok(ProcessingSuccess::Passthrough) => (\n                Cow::Borrowed(unsafe { core::str::from_utf8_unchecked(domain_name) }),\n                Ok(()),\n            ),\n            Ok(ProcessingSuccess::WroteToSink) => (Cow::Owned(s), Ok(())),\n            Err(ProcessingError::ValidityError) => (Cow::Owned(s), Err(crate::Errors::default())),\n            Err(ProcessingError::SinkError) => unreachable!(),\n        }",
)
The code is Ok(
    "self.process(\n            domain_name,\n            ascii_deny_list,\n            hyphens,\n            ErrorPolicy::MarkErrors,\n            output_as_unicode,\n            &mut s,\n            None,\n        )",
)
The code is Ok(
    "self",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "ascii_deny_list",
)
The code is Ok(
    "hyphens",
)
The code is Ok(
    "ErrorPolicy::MarkErrors",
)
The code is Ok(
    "output_as_unicode",
)
The code is Ok(
    "&mut s",
)
The code is Ok(
    "s",
)
The code is Ok(
    "None",
)
The code is Ok(
    "(\n                Cow::Borrowed(unsafe { core::str::from_utf8_unchecked(domain_name) }),\n                Ok(()),\n            )",
)
The code is Ok(
    "Cow::Borrowed(unsafe { core::str::from_utf8_unchecked(domain_name) })",
)
resolved new call Call { call_expr: HirId(DefId(0:180 ~ idna[bc6b]::uts46::{impl#4}::to_user_interface).47), call_expr_span: idna/src/uts46.rs:666:17: 666:86 (#0), caller: Some(DefId(0:180 ~ idna[bc6b]::uts46::{impl#4}::to_user_interface)), caller_span: None, callee: DefId(5:791 ~ alloc[186e]::borrow::Cow::Borrowed::{constructor#0}), callee_span: idna/src/uts46.rs:666:17: 666:30 (#0), callee_path: "std::borrow::Cow::Borrowed", constraint_depth: 1 }
The code is Ok(
    "Cow::Borrowed",
)
The code is Ok(
    "unsafe { core::str::from_utf8_unchecked(domain_name) }",
)
The code is Ok(
    "core::str::from_utf8_unchecked(domain_name)",
)
resolved new call Call { call_expr: HirId(DefId(0:180 ~ idna[bc6b]::uts46::{impl#4}::to_user_interface).52), call_expr_span: idna/src/uts46.rs:666:40: 666:83 (#0), caller: Some(DefId(0:180 ~ idna[bc6b]::uts46::{impl#4}::to_user_interface)), caller_span: None, callee: DefId(1:12976 ~ core[f118]::str::converts::from_utf8_unchecked), callee_span: idna/src/uts46.rs:666:40: 666:70 (#0), callee_path: "core::str::from_utf8_unchecked", constraint_depth: 1 }
The code is Ok(
    "core::str::from_utf8_unchecked",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "Ok(())",
)
resolved new call Call { call_expr: HirId(DefId(0:180 ~ idna[bc6b]::uts46::{impl#4}::to_user_interface).60), call_expr_span: idna/src/uts46.rs:667:17: 667:23 (#0), caller: Some(DefId(0:180 ~ idna[bc6b]::uts46::{impl#4}::to_user_interface)), caller_span: None, callee: DefId(1:45569 ~ core[f118]::result::Result::Ok::{constructor#0}), callee_span: idna/src/uts46.rs:667:17: 667:19 (#0), callee_path: "core::prelude::v1::Ok", constraint_depth: 1 }
The code is Ok(
    "Ok",
)
The code is Ok(
    "()",
)
The code is Ok(
    "(Cow::Owned(s), Ok(()))",
)
The code is Ok(
    "Cow::Owned(s)",
)
resolved new call Call { call_expr: HirId(DefId(0:180 ~ idna[bc6b]::uts46::{impl#4}::to_user_interface).71), call_expr_span: idna/src/uts46.rs:669:52: 669:65 (#0), caller: Some(DefId(0:180 ~ idna[bc6b]::uts46::{impl#4}::to_user_interface)), caller_span: None, callee: DefId(5:794 ~ alloc[186e]::borrow::Cow::Owned::{constructor#0}), callee_span: idna/src/uts46.rs:669:52: 669:62 (#0), callee_path: "std::borrow::Cow::Owned", constraint_depth: 1 }
The code is Ok(
    "Cow::Owned",
)
The code is Ok(
    "s",
)
The code is Ok(
    "Ok(())",
)
resolved new call Call { call_expr: HirId(DefId(0:180 ~ idna[bc6b]::uts46::{impl#4}::to_user_interface).77), call_expr_span: idna/src/uts46.rs:669:67: 669:73 (#0), caller: Some(DefId(0:180 ~ idna[bc6b]::uts46::{impl#4}::to_user_interface)), caller_span: None, callee: DefId(1:45569 ~ core[f118]::result::Result::Ok::{constructor#0}), callee_span: idna/src/uts46.rs:669:67: 669:69 (#0), callee_path: "core::prelude::v1::Ok", constraint_depth: 1 }
The code is Ok(
    "Ok",
)
The code is Ok(
    "()",
)
The code is Ok(
    "(Cow::Owned(s), Err(crate::Errors::default()))",
)
The code is Ok(
    "Cow::Owned(s)",
)
resolved new call Call { call_expr: HirId(DefId(0:180 ~ idna[bc6b]::uts46::{impl#4}::to_user_interface).88), call_expr_span: idna/src/uts46.rs:670:53: 670:66 (#0), caller: Some(DefId(0:180 ~ idna[bc6b]::uts46::{impl#4}::to_user_interface)), caller_span: None, callee: DefId(5:794 ~ alloc[186e]::borrow::Cow::Owned::{constructor#0}), callee_span: idna/src/uts46.rs:670:53: 670:63 (#0), callee_path: "std::borrow::Cow::Owned", constraint_depth: 1 }
The code is Ok(
    "Cow::Owned",
)
The code is Ok(
    "s",
)
The code is Ok(
    "Err(crate::Errors::default())",
)
resolved new call Call { call_expr: HirId(DefId(0:180 ~ idna[bc6b]::uts46::{impl#4}::to_user_interface).94), call_expr_span: idna/src/uts46.rs:670:68: 670:97 (#0), caller: Some(DefId(0:180 ~ idna[bc6b]::uts46::{impl#4}::to_user_interface)), caller_span: None, callee: DefId(1:45572 ~ core[f118]::result::Result::Err::{constructor#0}), callee_span: idna/src/uts46.rs:670:68: 670:71 (#0), callee_path: "core::prelude::v1::Err", constraint_depth: 1 }
The code is Ok(
    "Err",
)
The code is Ok(
    "crate::Errors::default()",
)
The code is Ok(
    "crate::Errors::default",
)
The code is Ok(
    "$crate::panicking::panic(\"internal error: entered unreachable code\")",
)
resolved new call Call { call_expr: HirId(DefId(0:180 ~ idna[bc6b]::uts46::{impl#4}::to_user_interface).109), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:118:9: 118:77 (#105), caller: Some(DefId(0:180 ~ idna[bc6b]::uts46::{impl#4}::to_user_interface)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:118:9: 118:33 (#105), callee_path: "core::panicking::panic", constraint_depth: 1 }
The code is Ok(
    "$crate::panicking::panic",
)
The code is Ok(
    "\"internal error: entered unreachable code\"",
)
The code is Ok(
    "{\n        let fail_fast = error_policy == ErrorPolicy::FailFast;\n        let mut domain_buffer = SmallVec::<[char; 253]>::new();\n        let mut already_punycode = SmallVec::<[AlreadyAsciiLabel; 8]>::new();\n        // `process_inner` could be pasted inline here, but it's out of line in order\n        // to avoid duplicating that code when monomorphizing over `W` and `OutputUnicode`.\n        let (passthrough_up_to, is_bidi, had_errors) = self.process_inner(\n            domain_name,\n            ascii_deny_list,\n            hyphens,\n            fail_fast,\n            &mut domain_buffer,\n            &mut already_punycode,\n        );\n        if passthrough_up_to == domain_name.len() {\n            debug_assert!(!had_errors);\n            return Ok(ProcessingSuccess::Passthrough);\n        }\n        // Checked only after passthrough as a micro optimization.\n        if fail_fast && had_errors {\n            return Err(ProcessingError::ValidityError);\n        }\n        debug_assert_eq!(had_errors, domain_buffer.contains(&'\\u{FFFD}'));\n        let without_dot = if let Some(without_dot) = domain_buffer.strip_suffix(&['.']) {\n            without_dot\n        } else {\n            &domain_buffer[..]\n        };\n        // unwrap is OK, because we always have at least one label\n        let tld = without_dot.rsplit(|c| *c == '.').next().unwrap();\n        let mut had_unicode_output = false;\n        let mut seen_label = false;\n        let mut already_punycode_iter = already_punycode.iter();\n        let mut passthrough_up_to_extended = passthrough_up_to;\n        let mut flushed_prefix = false;\n        for label in domain_buffer.split(|c| *c == '.') {\n            // Unwrap is OK, because there are supposed to be as many items in\n            // `already_punycode` as there are labels.\n            let input_punycode = *already_punycode_iter.next().unwrap();\n            if seen_label {\n                if flushed_prefix {\n                    sink.write_char('.')?;\n                } else {\n                    debug_assert_eq!(domain_name[passthrough_up_to_extended], b'.');\n                    passthrough_up_to_extended += 1;\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n            }\n            seen_label = true;\n\n            if let AlreadyAsciiLabel::MixedCaseAscii(mixed_case) = input_punycode {\n                if let Some(first_upper_case) =\n                    mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                {\n                    let (head, tail) = mixed_case.split_at(first_upper_case);\n                    let slice_to_write = if flushed_prefix {\n                        head\n                    } else {\n                        flushed_prefix = true;\n                        passthrough_up_to_extended += head.len();\n                        debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                        &domain_name[..passthrough_up_to_extended]\n                    };\n                    // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?;\n                    for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }\n                } else if flushed_prefix {\n                    // SAFETY: `mixed_case` is known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                } else {\n                    passthrough_up_to_extended += mixed_case.len();\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n                continue;\n            }\n\n            let potentially_punycode = if fail_fast {\n                debug_assert!(classify_for_punycode(label) != PunycodeClassification::Error);\n                !is_ascii(label)\n            } else {\n                classify_for_punycode(label) == PunycodeClassification::Unicode\n            };\n            let passthrough = if potentially_punycode {\n                let unicode = output_as_unicode(label, tld, is_bidi);\n                had_unicode_output |= unicode;\n                unicode\n            } else {\n                true\n            };\n            if passthrough {\n                if !flushed_prefix {\n                    flushed_prefix = true;\n                    // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?;\n                }\n                for c in label.iter().copied() {\n                    sink.write_char(c)?;\n                }\n            } else if let AlreadyAsciiLabel::MixedCasePunycode(mixed_case) = input_punycode {\n                if let Some(first_upper_case) =\n                    mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                {\n                    let (head, tail) = mixed_case.split_at(first_upper_case);\n                    let slice_to_write = if flushed_prefix {\n                        head\n                    } else {\n                        flushed_prefix = true;\n                        passthrough_up_to_extended += head.len();\n                        debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                        &domain_name[..passthrough_up_to_extended]\n                    };\n                    // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?;\n                    for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }\n                } else if flushed_prefix {\n                    // SAFETY: `mixed_case` is known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                } else {\n                    passthrough_up_to_extended += mixed_case.len();\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n            } else {\n                if !flushed_prefix {\n                    flushed_prefix = true;\n                    // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?;\n                }\n                write_punycode_label(label, sink)?;\n            }\n        }\n\n        if had_errors {\n            return Err(ProcessingError::ValidityError);\n        }\n\n        if had_unicode_output {\n            if let Some(sink) = ascii_sink {\n                let mut seen_label = false;\n                let mut already_punycode_iter = already_punycode.iter();\n                let mut passthrough_up_to_extended = passthrough_up_to;\n                let mut flushed_prefix = false;\n                for label in domain_buffer.split(|c| *c == '.') {\n                    // Unwrap is OK, because there are supposed to be as many items in\n                    // `already_punycode` as there are labels.\n                    let input_punycode = *already_punycode_iter.next().unwrap();\n                    if seen_label {\n                        if flushed_prefix {\n                            sink.write_char('.')?;\n                        } else {\n                            debug_assert_eq!(domain_name[passthrough_up_to_extended], b'.');\n                            passthrough_up_to_extended += 1;\n                        }\n                    }\n                    seen_label = true;\n\n                    if let AlreadyAsciiLabel::MixedCaseAscii(mixed_case) = input_punycode {\n                        if let Some(first_upper_case) =\n                            mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                        {\n                            let (head, tail) = mixed_case.split_at(first_upper_case);\n                            let slice_to_write = if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                                &domain_name[..passthrough_up_to_extended]\n                            };\n                            // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?;\n                            for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }\n                        } else if flushed_prefix {\n                            // SAFETY: `mixed_case` is known to be ASCII.\n                            sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                        } else {\n                            passthrough_up_to_extended += mixed_case.len();\n                        }\n                        continue;\n                    }\n\n                    if is_ascii(label) {\n                        if !flushed_prefix {\n                            flushed_prefix = true;\n                            // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?;\n                        }\n                        for c in label.iter().copied() {\n                            sink.write_char(c)?;\n                        }\n                    } else if let AlreadyAsciiLabel::MixedCasePunycode(mixed_case) = input_punycode\n                    {\n                        if let Some(first_upper_case) =\n                            mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                        {\n                            let (head, tail) = mixed_case.split_at(first_upper_case);\n                            let slice_to_write = if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                                &domain_name[..passthrough_up_to_extended]\n                            };\n                            // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?;\n                            for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }\n                        } else if flushed_prefix {\n                            // SAFETY: `mixed_case` is known to be ASCII.\n                            sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                        } else {\n                            passthrough_up_to_extended += mixed_case.len();\n                        }\n                    } else {\n                        if !flushed_prefix {\n                            flushed_prefix = true;\n                            // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?;\n                        }\n                        write_punycode_label(label, sink)?;\n                    }\n                }\n                if !flushed_prefix {\n                    // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?;\n                }\n            }\n        }\n        Ok(ProcessingSuccess::WroteToSink)\n    }",
)
The code is Ok(
    "error_policy == ErrorPolicy::FailFast",
)
The code is Ok(
    "error_policy",
)
The code is Ok(
    "ErrorPolicy::FailFast",
)
The code is Ok(
    "SmallVec::<[char; 253]>::new()",
)
The code is Ok(
    "SmallVec::<[char; 253]>::new",
)
The code is Ok(
    "253",
)
The code is Ok(
    "SmallVec::<[AlreadyAsciiLabel; 8]>::new()",
)
The code is Ok(
    "SmallVec::<[AlreadyAsciiLabel; 8]>::new",
)
The code is Ok(
    "8",
)
The code is Ok(
    "self.process_inner(\n            domain_name,\n            ascii_deny_list,\n            hyphens,\n            fail_fast,\n            &mut domain_buffer,\n            &mut already_punycode,\n        )",
)
The code is Ok(
    "self",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "ascii_deny_list",
)
The code is Ok(
    "hyphens",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "&mut domain_buffer",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "&mut already_punycode",
)
The code is Ok(
    "already_punycode",
)
The code is Ok(
    "if passthrough_up_to == domain_name.len() {\n            debug_assert!(!had_errors);\n            return Ok(ProcessingSuccess::Passthrough);\n        }",
)
The code is Ok(
    "passthrough_up_to == domain_name.len()",
)
The code is Ok(
    "passthrough_up_to",
)
The code is Ok(
    "domain_name.len()",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "if $crate::cfg!(debug_assertions) {\n            $crate::assert!($($arg)*);\n        }",
)
The code is Ok(
    "$crate::cfg!(debug_assertions)",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "!had_errors",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).97), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:335:13: 335:38 (#108), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:335:13: 335:13 (#108), callee_path: "core::panicking::panic", constraint_depth: 1 }
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "",
)
The code is Ok(
    "return Ok(ProcessingSuccess::Passthrough)",
)
The code is Ok(
    "Ok(ProcessingSuccess::Passthrough)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).110), call_expr_span: idna/src/uts46.rs:780:20: 780:54 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:45569 ~ core[f118]::result::Result::Ok::{constructor#0}), callee_span: idna/src/uts46.rs:780:20: 780:22 (#0), callee_path: "core::prelude::v1::Ok", constraint_depth: 0 }
The code is Ok(
    "Ok",
)
The code is Ok(
    "ProcessingSuccess::Passthrough",
)
The code is Ok(
    "if fail_fast && had_errors {\n            return Err(ProcessingError::ValidityError);\n        }",
)
The code is Ok(
    "fail_fast && had_errors",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "return Err(ProcessingError::ValidityError)",
)
The code is Ok(
    "Err(ProcessingError::ValidityError)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).128), call_expr_span: idna/src/uts46.rs:784:20: 784:55 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:45572 ~ core[f118]::result::Result::Err::{constructor#0}), callee_span: idna/src/uts46.rs:784:20: 784:23 (#0), callee_path: "core::prelude::v1::Err", constraint_depth: 2 }
The code is Ok(
    "Err",
)
The code is Ok(
    "ProcessingError::ValidityError",
)
The code is Ok(
    "if $crate::cfg!(debug_assertions) {\n            $crate::assert_eq!($($arg)*);\n        }",
)
The code is Ok(
    "$crate::cfg!(debug_assertions)",
)
The code is Ok(
    "match (&$left, &$right) {\n            (left_val, right_val) => {\n                if !(*left_val == *right_val) {\n                    let kind = $crate::panicking::AssertKind::Eq;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }\n            }\n        }",
)
The code is Ok(
    "(&$left, &$right)",
)
The code is Ok(
    "&$left",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "&$right",
)
The code is Ok(
    "domain_buffer.contains(&'\\u{FFFD}')",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "&'\\u{FFFD}'",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "{\n                if !(*left_val == *right_val) {\n                    let kind = $crate::panicking::AssertKind::Eq;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }\n            }",
)
The code is Ok(
    "if !(*left_val == *right_val) {\n                    let kind = $crate::panicking::AssertKind::Eq;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }",
)
The code is Ok(
    "!(*left_val == *right_val)",
)
The code is Ok(
    "(*left_val == *right_val)",
)
The code is Ok(
    "*left_val",
)
The code is Ok(
    "left_val",
)
The code is Ok(
    "*right_val",
)
The code is Ok(
    "right_val",
)
The code is Ok(
    "$crate::panicking::AssertKind::Eq",
)
The code is Ok(
    "$crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).176), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:51:21: 51:114 (#112), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:9590 ~ core[f118]::panicking::assert_failed), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:51:21: 51:53 (#112), callee_path: "core::panicking::assert_failed", constraint_depth: 2 }
The code is Ok(
    "$crate::panicking::assert_failed",
)
The code is Ok(
    "kind",
)
The code is Ok(
    "&*left_val",
)
The code is Ok(
    "*left_val",
)
The code is Ok(
    "left_val",
)
The code is Ok(
    "&*right_val",
)
The code is Ok(
    "*right_val",
)
The code is Ok(
    "right_val",
)
The code is Ok(
    "$crate::option::Option::None",
)
The code is Ok(
    "if let Some(without_dot) = domain_buffer.strip_suffix(&['.']) {\n            without_dot\n        } else {\n            &domain_buffer[..]\n        }",
)
The code is Ok(
    "domain_buffer.strip_suffix(&['.'])",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "&['.']",
)
The code is Ok(
    "['.']",
)
The code is Ok(
    "'.'",
)
The code is Ok(
    "without_dot",
)
The code is Ok(
    "&domain_buffer[..]",
)
The code is Ok(
    "domain_buffer[..]",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "..",
)
The code is Ok(
    "without_dot.rsplit(|c| *c == '.').next().unwrap()",
)
The code is Ok(
    "without_dot.rsplit(|c| *c == '.').next()",
)
The code is Ok(
    "without_dot.rsplit(|c| *c == '.')",
)
The code is Ok(
    "without_dot",
)
The code is Ok(
    "|c| *c == '.'",
)
The code is Ok(
    "*c == '.'",
)
The code is Ok(
    "*c",
)
The code is Ok(
    "c",
)
The code is Ok(
    "'.'",
)
The code is Ok(
    "false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "already_punycode.iter()",
)
The code is Ok(
    "already_punycode",
)
The code is Ok(
    "passthrough_up_to",
)
The code is Ok(
    "false",
)
The code is Ok(
    "for label in domain_buffer.split(|c| *c == '.') {\n            // Unwrap is OK, because there are supposed to be as many items in\n            // `already_punycode` as there are labels.\n            let input_punycode = *already_punycode_iter.next().unwrap();\n            if seen_label {\n                if flushed_prefix {\n                    sink.write_char('.')?;\n                } else {\n                    debug_assert_eq!(domain_name[passthrough_up_to_extended], b'.');\n                    passthrough_up_to_extended += 1;\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n            }\n            seen_label = true;\n\n            if let AlreadyAsciiLabel::MixedCaseAscii(mixed_case) = input_punycode {\n                if let Some(first_upper_case) =\n                    mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                {\n                    let (head, tail) = mixed_case.split_at(first_upper_case);\n                    let slice_to_write = if flushed_prefix {\n                        head\n                    } else {\n                        flushed_prefix = true;\n                        passthrough_up_to_extended += head.len();\n                        debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                        &domain_name[..passthrough_up_to_extended]\n                    };\n                    // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?;\n                    for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }\n                } else if flushed_prefix {\n                    // SAFETY: `mixed_case` is known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                } else {\n                    passthrough_up_to_extended += mixed_case.len();\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n                continue;\n            }\n\n            let potentially_punycode = if fail_fast {\n                debug_assert!(classify_for_punycode(label) != PunycodeClassification::Error);\n                !is_ascii(label)\n            } else {\n                classify_for_punycode(label) == PunycodeClassification::Unicode\n            };\n            let passthrough = if potentially_punycode {\n                let unicode = output_as_unicode(label, tld, is_bidi);\n                had_unicode_output |= unicode;\n                unicode\n            } else {\n                true\n            };\n            if passthrough {\n                if !flushed_prefix {\n                    flushed_prefix = true;\n                    // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?;\n                }\n                for c in label.iter().copied() {\n                    sink.write_char(c)?;\n                }\n            } else if let AlreadyAsciiLabel::MixedCasePunycode(mixed_case) = input_punycode {\n                if let Some(first_upper_case) =\n                    mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                {\n                    let (head, tail) = mixed_case.split_at(first_upper_case);\n                    let slice_to_write = if flushed_prefix {\n                        head\n                    } else {\n                        flushed_prefix = true;\n                        passthrough_up_to_extended += head.len();\n                        debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                        &domain_name[..passthrough_up_to_extended]\n                    };\n                    // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?;\n                    for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }\n                } else if flushed_prefix {\n                    // SAFETY: `mixed_case` is known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                } else {\n                    passthrough_up_to_extended += mixed_case.len();\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n            } else {\n                if !flushed_prefix {\n                    flushed_prefix = true;\n                    // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?;\n                }\n                write_punycode_label(label, sink)?;\n            }\n        }",
)
The code is Ok(
    "for label in domain_buffer.split(|c| *c == '.') {\n            // Unwrap is OK, because there are supposed to be as many items in\n            // `already_punycode` as there are labels.\n            let input_punycode = *already_punycode_iter.next().unwrap();\n            if seen_label {\n                if flushed_prefix {\n                    sink.write_char('.')?;\n                } else {\n                    debug_assert_eq!(domain_name[passthrough_up_to_extended], b'.');\n                    passthrough_up_to_extended += 1;\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n            }\n            seen_label = true;\n\n            if let AlreadyAsciiLabel::MixedCaseAscii(mixed_case) = input_punycode {\n                if let Some(first_upper_case) =\n                    mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                {\n                    let (head, tail) = mixed_case.split_at(first_upper_case);\n                    let slice_to_write = if flushed_prefix {\n                        head\n                    } else {\n                        flushed_prefix = true;\n                        passthrough_up_to_extended += head.len();\n                        debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                        &domain_name[..passthrough_up_to_extended]\n                    };\n                    // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?;\n                    for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }\n                } else if flushed_prefix {\n                    // SAFETY: `mixed_case` is known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                } else {\n                    passthrough_up_to_extended += mixed_case.len();\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n                continue;\n            }\n\n            let potentially_punycode = if fail_fast {\n                debug_assert!(classify_for_punycode(label) != PunycodeClassification::Error);\n                !is_ascii(label)\n            } else {\n                classify_for_punycode(label) == PunycodeClassification::Unicode\n            };\n            let passthrough = if potentially_punycode {\n                let unicode = output_as_unicode(label, tld, is_bidi);\n                had_unicode_output |= unicode;\n                unicode\n            } else {\n                true\n            };\n            if passthrough {\n                if !flushed_prefix {\n                    flushed_prefix = true;\n                    // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?;\n                }\n                for c in label.iter().copied() {\n                    sink.write_char(c)?;\n                }\n            } else if let AlreadyAsciiLabel::MixedCasePunycode(mixed_case) = input_punycode {\n                if let Some(first_upper_case) =\n                    mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                {\n                    let (head, tail) = mixed_case.split_at(first_upper_case);\n                    let slice_to_write = if flushed_prefix {\n                        head\n                    } else {\n                        flushed_prefix = true;\n                        passthrough_up_to_extended += head.len();\n                        debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                        &domain_name[..passthrough_up_to_extended]\n                    };\n                    // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?;\n                    for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }\n                } else if flushed_prefix {\n                    // SAFETY: `mixed_case` is known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                } else {\n                    passthrough_up_to_extended += mixed_case.len();\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n            } else {\n                if !flushed_prefix {\n                    flushed_prefix = true;\n                    // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?;\n                }\n                write_punycode_label(label, sink)?;\n            }\n        }",
)
into Match call
The code is Ok(
    "domain_buffer.split(|c| *c == '.')",
)
LangItem path: idna/src/uts46.rs:799:22: 799:56 (#331)
The code is Ok(
    "domain_buffer.split(|c| *c == '.')",
)
The code is Ok(
    "domain_buffer.split(|c| *c == '.')",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "|c| *c == '.'",
)
The code is Ok(
    "*c == '.'",
)
The code is Ok(
    "*c",
)
The code is Ok(
    "c",
)
The code is Ok(
    "'.'",
)
The code is Ok(
    "for label in domain_buffer.split(|c| *c == '.') {\n            // Unwrap is OK, because there are supposed to be as many items in\n            // `already_punycode` as there are labels.\n            let input_punycode = *already_punycode_iter.next().unwrap();\n            if seen_label {\n                if flushed_prefix {\n                    sink.write_char('.')?;\n                } else {\n                    debug_assert_eq!(domain_name[passthrough_up_to_extended], b'.');\n                    passthrough_up_to_extended += 1;\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n            }\n            seen_label = true;\n\n            if let AlreadyAsciiLabel::MixedCaseAscii(mixed_case) = input_punycode {\n                if let Some(first_upper_case) =\n                    mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                {\n                    let (head, tail) = mixed_case.split_at(first_upper_case);\n                    let slice_to_write = if flushed_prefix {\n                        head\n                    } else {\n                        flushed_prefix = true;\n                        passthrough_up_to_extended += head.len();\n                        debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                        &domain_name[..passthrough_up_to_extended]\n                    };\n                    // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?;\n                    for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }\n                } else if flushed_prefix {\n                    // SAFETY: `mixed_case` is known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                } else {\n                    passthrough_up_to_extended += mixed_case.len();\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n                continue;\n            }\n\n            let potentially_punycode = if fail_fast {\n                debug_assert!(classify_for_punycode(label) != PunycodeClassification::Error);\n                !is_ascii(label)\n            } else {\n                classify_for_punycode(label) == PunycodeClassification::Unicode\n            };\n            let passthrough = if potentially_punycode {\n                let unicode = output_as_unicode(label, tld, is_bidi);\n                had_unicode_output |= unicode;\n                unicode\n            } else {\n                true\n            };\n            if passthrough {\n                if !flushed_prefix {\n                    flushed_prefix = true;\n                    // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?;\n                }\n                for c in label.iter().copied() {\n                    sink.write_char(c)?;\n                }\n            } else if let AlreadyAsciiLabel::MixedCasePunycode(mixed_case) = input_punycode {\n                if let Some(first_upper_case) =\n                    mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                {\n                    let (head, tail) = mixed_case.split_at(first_upper_case);\n                    let slice_to_write = if flushed_prefix {\n                        head\n                    } else {\n                        flushed_prefix = true;\n                        passthrough_up_to_extended += head.len();\n                        debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                        &domain_name[..passthrough_up_to_extended]\n                    };\n                    // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?;\n                    for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }\n                } else if flushed_prefix {\n                    // SAFETY: `mixed_case` is known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                } else {\n                    passthrough_up_to_extended += mixed_case.len();\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n            } else {\n                if !flushed_prefix {\n                    flushed_prefix = true;\n                    // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?;\n                }\n                write_punycode_label(label, sink)?;\n            }\n        }",
)
The code is Ok(
    "domain_buffer.split(|c| *c == '.')",
)
into Match call
is inner Match
The code is Ok(
    "domain_buffer.split(|c| *c == '.')",
)
LangItem path: idna/src/uts46.rs:799:22: 799:56 (#331)
The code is Ok(
    "domain_buffer.split(|c| *c == '.')",
)
The code is Ok(
    "domain_buffer.split(|c| *c == '.')",
)
The code is Ok(
    "domain_buffer.split(|c| *c == '.')",
)
The code is Ok(
    "for label in domain_buffer.split(|c| *c == '.') {\n            // Unwrap is OK, because there are supposed to be as many items in\n            // `already_punycode` as there are labels.\n            let input_punycode = *already_punycode_iter.next().unwrap();\n            if seen_label {\n                if flushed_prefix {\n                    sink.write_char('.')?;\n                } else {\n                    debug_assert_eq!(domain_name[passthrough_up_to_extended], b'.');\n                    passthrough_up_to_extended += 1;\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n            }\n            seen_label = true;\n\n            if let AlreadyAsciiLabel::MixedCaseAscii(mixed_case) = input_punycode {\n                if let Some(first_upper_case) =\n                    mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                {\n                    let (head, tail) = mixed_case.split_at(first_upper_case);\n                    let slice_to_write = if flushed_prefix {\n                        head\n                    } else {\n                        flushed_prefix = true;\n                        passthrough_up_to_extended += head.len();\n                        debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                        &domain_name[..passthrough_up_to_extended]\n                    };\n                    // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?;\n                    for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }\n                } else if flushed_prefix {\n                    // SAFETY: `mixed_case` is known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                } else {\n                    passthrough_up_to_extended += mixed_case.len();\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n                continue;\n            }\n\n            let potentially_punycode = if fail_fast {\n                debug_assert!(classify_for_punycode(label) != PunycodeClassification::Error);\n                !is_ascii(label)\n            } else {\n                classify_for_punycode(label) == PunycodeClassification::Unicode\n            };\n            let passthrough = if potentially_punycode {\n                let unicode = output_as_unicode(label, tld, is_bidi);\n                had_unicode_output |= unicode;\n                unicode\n            } else {\n                true\n            };\n            if passthrough {\n                if !flushed_prefix {\n                    flushed_prefix = true;\n                    // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?;\n                }\n                for c in label.iter().copied() {\n                    sink.write_char(c)?;\n                }\n            } else if let AlreadyAsciiLabel::MixedCasePunycode(mixed_case) = input_punycode {\n                if let Some(first_upper_case) =\n                    mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                {\n                    let (head, tail) = mixed_case.split_at(first_upper_case);\n                    let slice_to_write = if flushed_prefix {\n                        head\n                    } else {\n                        flushed_prefix = true;\n                        passthrough_up_to_extended += head.len();\n                        debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                        &domain_name[..passthrough_up_to_extended]\n                    };\n                    // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?;\n                    for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }\n                } else if flushed_prefix {\n                    // SAFETY: `mixed_case` is known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                } else {\n                    passthrough_up_to_extended += mixed_case.len();\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n            } else {\n                if !flushed_prefix {\n                    flushed_prefix = true;\n                    // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?;\n                }\n                write_punycode_label(label, sink)?;\n            }\n        }",
)
The code is Ok(
    "{\n            // Unwrap is OK, because there are supposed to be as many items in\n            // `already_punycode` as there are labels.\n            let input_punycode = *already_punycode_iter.next().unwrap();\n            if seen_label {\n                if flushed_prefix {\n                    sink.write_char('.')?;\n                } else {\n                    debug_assert_eq!(domain_name[passthrough_up_to_extended], b'.');\n                    passthrough_up_to_extended += 1;\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n            }\n            seen_label = true;\n\n            if let AlreadyAsciiLabel::MixedCaseAscii(mixed_case) = input_punycode {\n                if let Some(first_upper_case) =\n                    mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                {\n                    let (head, tail) = mixed_case.split_at(first_upper_case);\n                    let slice_to_write = if flushed_prefix {\n                        head\n                    } else {\n                        flushed_prefix = true;\n                        passthrough_up_to_extended += head.len();\n                        debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                        &domain_name[..passthrough_up_to_extended]\n                    };\n                    // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?;\n                    for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }\n                } else if flushed_prefix {\n                    // SAFETY: `mixed_case` is known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                } else {\n                    passthrough_up_to_extended += mixed_case.len();\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n                continue;\n            }\n\n            let potentially_punycode = if fail_fast {\n                debug_assert!(classify_for_punycode(label) != PunycodeClassification::Error);\n                !is_ascii(label)\n            } else {\n                classify_for_punycode(label) == PunycodeClassification::Unicode\n            };\n            let passthrough = if potentially_punycode {\n                let unicode = output_as_unicode(label, tld, is_bidi);\n                had_unicode_output |= unicode;\n                unicode\n            } else {\n                true\n            };\n            if passthrough {\n                if !flushed_prefix {\n                    flushed_prefix = true;\n                    // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?;\n                }\n                for c in label.iter().copied() {\n                    sink.write_char(c)?;\n                }\n            } else if let AlreadyAsciiLabel::MixedCasePunycode(mixed_case) = input_punycode {\n                if let Some(first_upper_case) =\n                    mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                {\n                    let (head, tail) = mixed_case.split_at(first_upper_case);\n                    let slice_to_write = if flushed_prefix {\n                        head\n                    } else {\n                        flushed_prefix = true;\n                        passthrough_up_to_extended += head.len();\n                        debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                        &domain_name[..passthrough_up_to_extended]\n                    };\n                    // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?;\n                    for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }\n                } else if flushed_prefix {\n                    // SAFETY: `mixed_case` is known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                } else {\n                    passthrough_up_to_extended += mixed_case.len();\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n            } else {\n                if !flushed_prefix {\n                    flushed_prefix = true;\n                    // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?;\n                }\n                write_punycode_label(label, sink)?;\n            }\n        }",
)
The code is Ok(
    "*already_punycode_iter.next().unwrap()",
)
The code is Ok(
    "already_punycode_iter.next().unwrap()",
)
The code is Ok(
    "already_punycode_iter.next()",
)
The code is Ok(
    "already_punycode_iter",
)
The code is Ok(
    "if seen_label {\n                if flushed_prefix {\n                    sink.write_char('.')?;\n                } else {\n                    debug_assert_eq!(domain_name[passthrough_up_to_extended], b'.');\n                    passthrough_up_to_extended += 1;\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n            }",
)
The code is Ok(
    "seen_label",
)
The code is Ok(
    "if flushed_prefix {\n                    sink.write_char('.')?;\n                } else {\n                    debug_assert_eq!(domain_name[passthrough_up_to_extended], b'.');\n                    passthrough_up_to_extended += 1;\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "sink.write_char('.')?",
)
into Match call
The code is Ok(
    "sink.write_char('.')?",
)
LangItem path: idna/src/uts46.rs:805:21: 805:42 (#335)
The code is Ok(
    "sink.write_char('.')?",
)
The code is Ok(
    "sink.write_char('.')",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).313),
    call_expr_span: idna/src/uts46.rs:805:21: 805:41 (#0),
    caller: Some(
        DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process),
    ),
    caller_span: None,
    callee: DefId(1:10605 ~ core[f118]::fmt::Write::write_char),
    callee_span: idna/src/uts46.rs:805:21: 805:41 (#0),
    callee_path: "core::fmt::Write::write_char",
    constraint_depth: 1,
}
The code is Ok(
    "sink",
)
The code is Ok(
    "'.'",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_char('.')?",
)
LangItem path: idna/src/uts46.rs:805:41: 805:42 (#336)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_char('.')?",
)
The code is Ok(
    "if $crate::cfg!(debug_assertions) {\n            $crate::assert_eq!($($arg)*);\n        }",
)
The code is Ok(
    "$crate::cfg!(debug_assertions)",
)
The code is Ok(
    "match (&$left, &$right) {\n            (left_val, right_val) => {\n                if !(*left_val == *right_val) {\n                    let kind = $crate::panicking::AssertKind::Eq;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }\n            }\n        }",
)
The code is Ok(
    "(&$left, &$right)",
)
The code is Ok(
    "&$left",
)
The code is Ok(
    "domain_name[passthrough_up_to_extended]",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "&$right",
)
The code is Ok(
    "b'.'",
)
The code is Ok(
    "{\n                if !(*left_val == *right_val) {\n                    let kind = $crate::panicking::AssertKind::Eq;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }\n            }",
)
The code is Ok(
    "if !(*left_val == *right_val) {\n                    let kind = $crate::panicking::AssertKind::Eq;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }",
)
The code is Ok(
    "!(*left_val == *right_val)",
)
The code is Ok(
    "(*left_val == *right_val)",
)
The code is Ok(
    "*left_val",
)
The code is Ok(
    "left_val",
)
The code is Ok(
    "*right_val",
)
The code is Ok(
    "right_val",
)
The code is Ok(
    "$crate::panicking::AssertKind::Eq",
)
The code is Ok(
    "$crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).375), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:51:21: 51:114 (#115), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:9590 ~ core[f118]::panicking::assert_failed), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:51:21: 51:53 (#115), callee_path: "core::panicking::assert_failed", constraint_depth: 3 }
The code is Ok(
    "$crate::panicking::assert_failed",
)
The code is Ok(
    "kind",
)
The code is Ok(
    "&*left_val",
)
The code is Ok(
    "*left_val",
)
The code is Ok(
    "left_val",
)
The code is Ok(
    "&*right_val",
)
The code is Ok(
    "*right_val",
)
The code is Ok(
    "right_val",
)
The code is Ok(
    "$crate::option::Option::None",
)
The code is Ok(
    "passthrough_up_to_extended += 1",
)
The code is Ok(
    "1",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }",
)
The code is Ok(
    "passthrough_up_to_extended == domain_name.len()",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "domain_name.len()",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "if $crate::cfg!(debug_assertions) {\n            $crate::assert!($($arg)*);\n        }",
)
The code is Ok(
    "$crate::cfg!(debug_assertions)",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "!had_errors",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).426), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:335:13: 335:38 (#118), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:335:13: 335:13 (#118), callee_path: "core::panicking::panic", constraint_depth: 2 }
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "",
)
The code is Ok(
    "return Ok(ProcessingSuccess::Passthrough)",
)
The code is Ok(
    "Ok(ProcessingSuccess::Passthrough)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).439), call_expr_span: idna/src/uts46.rs:811:32: 811:66 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:45569 ~ core[f118]::result::Result::Ok::{constructor#0}), callee_span: idna/src/uts46.rs:811:32: 811:34 (#0), callee_path: "core::prelude::v1::Ok", constraint_depth: 1 }
The code is Ok(
    "Ok",
)
The code is Ok(
    "ProcessingSuccess::Passthrough",
)
The code is Ok(
    "seen_label = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "seen_label",
)
The code is Ok(
    "if let AlreadyAsciiLabel::MixedCaseAscii(mixed_case) = input_punycode {\n                if let Some(first_upper_case) =\n                    mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                {\n                    let (head, tail) = mixed_case.split_at(first_upper_case);\n                    let slice_to_write = if flushed_prefix {\n                        head\n                    } else {\n                        flushed_prefix = true;\n                        passthrough_up_to_extended += head.len();\n                        debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                        &domain_name[..passthrough_up_to_extended]\n                    };\n                    // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?;\n                    for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }\n                } else if flushed_prefix {\n                    // SAFETY: `mixed_case` is known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                } else {\n                    passthrough_up_to_extended += mixed_case.len();\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n                continue;\n            }",
)
The code is Ok(
    "input_punycode",
)
The code is Ok(
    "if let Some(first_upper_case) =\n                    mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                {\n                    let (head, tail) = mixed_case.split_at(first_upper_case);\n                    let slice_to_write = if flushed_prefix {\n                        head\n                    } else {\n                        flushed_prefix = true;\n                        passthrough_up_to_extended += head.len();\n                        debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                        &domain_name[..passthrough_up_to_extended]\n                    };\n                    // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?;\n                    for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }\n                } else if flushed_prefix {\n                    // SAFETY: `mixed_case` is known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                } else {\n                    passthrough_up_to_extended += mixed_case.len();\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }",
)
The code is Ok(
    "mixed_case.iter().position(|c| c.is_ascii_uppercase())",
)
The code is Ok(
    "mixed_case.iter()",
)
The code is Ok(
    "mixed_case",
)
The code is Ok(
    "|c| c.is_ascii_uppercase()",
)
The code is Ok(
    "c.is_ascii_uppercase()",
)
The code is Ok(
    "c",
)
The code is Ok(
    "mixed_case.split_at(first_upper_case)",
)
The code is Ok(
    "mixed_case",
)
The code is Ok(
    "first_upper_case",
)
The code is Ok(
    "if flushed_prefix {\n                        head\n                    } else {\n                        flushed_prefix = true;\n                        passthrough_up_to_extended += head.len();\n                        debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                        &domain_name[..passthrough_up_to_extended]\n                    }",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "head",
)
The code is Ok(
    "flushed_prefix = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "passthrough_up_to_extended += head.len()",
)
The code is Ok(
    "head.len()",
)
The code is Ok(
    "head",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "if $crate::cfg!(debug_assertions) {\n            $crate::assert_ne!($($arg)*);\n        }",
)
The code is Ok(
    "$crate::cfg!(debug_assertions)",
)
The code is Ok(
    "match (&$left, &$right) {\n            (left_val, right_val) => {\n                if *left_val == *right_val {\n                    let kind = $crate::panicking::AssertKind::Ne;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }\n            }\n        }",
)
The code is Ok(
    "(&$left, &$right)",
)
The code is Ok(
    "&$left",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "&$right",
)
The code is Ok(
    "domain_name.len()",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "{\n                if *left_val == *right_val {\n                    let kind = $crate::panicking::AssertKind::Ne;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }\n            }",
)
The code is Ok(
    "if *left_val == *right_val {\n                    let kind = $crate::panicking::AssertKind::Ne;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }",
)
The code is Ok(
    "*left_val == *right_val",
)
The code is Ok(
    "*left_val",
)
The code is Ok(
    "left_val",
)
The code is Ok(
    "*right_val",
)
The code is Ok(
    "right_val",
)
The code is Ok(
    "$crate::panicking::AssertKind::Ne",
)
The code is Ok(
    "$crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).553), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:107:21: 107:114 (#122), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:9590 ~ core[f118]::panicking::assert_failed), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:107:21: 107:53 (#122), callee_path: "core::panicking::assert_failed", constraint_depth: 3 }
The code is Ok(
    "$crate::panicking::assert_failed",
)
The code is Ok(
    "kind",
)
The code is Ok(
    "&*left_val",
)
The code is Ok(
    "*left_val",
)
The code is Ok(
    "left_val",
)
The code is Ok(
    "&*right_val",
)
The code is Ok(
    "*right_val",
)
The code is Ok(
    "right_val",
)
The code is Ok(
    "$crate::option::Option::None",
)
The code is Ok(
    "&domain_name[..passthrough_up_to_extended]",
)
The code is Ok(
    "domain_name[..passthrough_up_to_extended]",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "..passthrough_up_to_extended",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?",
)
into Match call
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?",
)
LangItem path: idna/src/uts46.rs:831:21: 831:95 (#352)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).593),
    call_expr_span: idna/src/uts46.rs:831:21: 831:94 (#0),
    caller: Some(
        DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process),
    ),
    caller_span: None,
    callee: DefId(1:10604 ~ core[f118]::fmt::Write::write_str),
    callee_span: idna/src/uts46.rs:831:21: 831:94 (#0),
    callee_path: "core::fmt::Write::write_str",
    constraint_depth: 1,
}
The code is Ok(
    "sink",
)
The code is Ok(
    "unsafe { core::str::from_utf8_unchecked(slice_to_write) }",
)
The code is Ok(
    "core::str::from_utf8_unchecked(slice_to_write)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).598), call_expr_span: idna/src/uts46.rs:831:45: 831:91 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:12976 ~ core[f118]::str::converts::from_utf8_unchecked), callee_span: idna/src/uts46.rs:831:45: 831:75 (#0), callee_path: "core::str::from_utf8_unchecked", constraint_depth: 1 }
The code is Ok(
    "core::str::from_utf8_unchecked",
)
The code is Ok(
    "slice_to_write",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?",
)
LangItem path: idna/src/uts46.rs:831:94: 831:95 (#353)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?",
)
The code is Ok(
    "for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }",
)
The code is Ok(
    "for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }",
)
into Match call
The code is Ok(
    "tail.iter()",
)
LangItem path: idna/src/uts46.rs:832:30: 832:41 (#355)
The code is Ok(
    "tail.iter()",
)
The code is Ok(
    "tail.iter()",
)
The code is Ok(
    "tail",
)
The code is Ok(
    "for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }",
)
The code is Ok(
    "tail.iter()",
)
into Match call
is inner Match
The code is Ok(
    "tail.iter()",
)
LangItem path: idna/src/uts46.rs:832:30: 832:41 (#355)
The code is Ok(
    "tail.iter()",
)
The code is Ok(
    "tail.iter()",
)
The code is Ok(
    "tail.iter()",
)
The code is Ok(
    "for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }",
)
The code is Ok(
    "{\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }",
)
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))?",
)
into Match call
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))?",
)
LangItem path: idna/src/uts46.rs:833:25: 833:77 (#357)
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))?",
)
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).636),
    call_expr_span: idna/src/uts46.rs:833:25: 833:76 (#0),
    caller: Some(
        DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process),
    ),
    caller_span: None,
    callee: DefId(1:10605 ~ core[f118]::fmt::Write::write_char),
    callee_span: idna/src/uts46.rs:833:25: 833:76 (#0),
    callee_path: "core::fmt::Write::write_char",
    constraint_depth: 2,
}
The code is Ok(
    "sink",
)
The code is Ok(
    "char::from(c.to_ascii_lowercase())",
)
The code is Ok(
    "char::from",
)
The code is Ok(
    "c.to_ascii_lowercase()",
)
The code is Ok(
    "c",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))?",
)
LangItem path: idna/src/uts46.rs:833:76: 833:77 (#358)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))?",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "{\n                    // SAFETY: `mixed_case` is known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                }",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?",
)
into Match call
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?",
)
LangItem path: idna/src/uts46.rs:837:21: 837:91 (#360)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).691),
    call_expr_span: idna/src/uts46.rs:837:21: 837:90 (#0),
    caller: Some(
        DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process),
    ),
    caller_span: None,
    callee: DefId(1:10604 ~ core[f118]::fmt::Write::write_str),
    callee_span: idna/src/uts46.rs:837:21: 837:90 (#0),
    callee_path: "core::fmt::Write::write_str",
    constraint_depth: 1,
}
The code is Ok(
    "sink",
)
The code is Ok(
    "unsafe { core::str::from_utf8_unchecked(mixed_case) }",
)
The code is Ok(
    "core::str::from_utf8_unchecked(mixed_case)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).696), call_expr_span: idna/src/uts46.rs:837:45: 837:87 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:12976 ~ core[f118]::str::converts::from_utf8_unchecked), callee_span: idna/src/uts46.rs:837:45: 837:75 (#0), callee_path: "core::str::from_utf8_unchecked", constraint_depth: 1 }
The code is Ok(
    "core::str::from_utf8_unchecked",
)
The code is Ok(
    "mixed_case",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?",
)
LangItem path: idna/src/uts46.rs:837:90: 837:91 (#361)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?",
)
The code is Ok(
    "{\n                    passthrough_up_to_extended += mixed_case.len();\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }",
)
The code is Ok(
    "passthrough_up_to_extended += mixed_case.len()",
)
The code is Ok(
    "mixed_case.len()",
)
The code is Ok(
    "mixed_case",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }",
)
The code is Ok(
    "passthrough_up_to_extended == domain_name.len()",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "domain_name.len()",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "if $crate::cfg!(debug_assertions) {\n            $crate::assert!($($arg)*);\n        }",
)
The code is Ok(
    "$crate::cfg!(debug_assertions)",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "!had_errors",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).751), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:335:13: 335:38 (#125), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:335:13: 335:13 (#125), callee_path: "core::panicking::panic", constraint_depth: 2 }
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "",
)
The code is Ok(
    "return Ok(ProcessingSuccess::Passthrough)",
)
The code is Ok(
    "Ok(ProcessingSuccess::Passthrough)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).764), call_expr_span: idna/src/uts46.rs:842:32: 842:66 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:45569 ~ core[f118]::result::Result::Ok::{constructor#0}), callee_span: idna/src/uts46.rs:842:32: 842:34 (#0), callee_path: "core::prelude::v1::Ok", constraint_depth: 1 }
The code is Ok(
    "Ok",
)
The code is Ok(
    "ProcessingSuccess::Passthrough",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "if fail_fast {\n                debug_assert!(classify_for_punycode(label) != PunycodeClassification::Error);\n                !is_ascii(label)\n            } else {\n                classify_for_punycode(label) == PunycodeClassification::Unicode\n            }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "if $crate::cfg!(debug_assertions) {\n            $crate::assert!($($arg)*);\n        }",
)
The code is Ok(
    "$crate::cfg!(debug_assertions)",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "classify_for_punycode(label) != PunycodeClassification::Error",
)
The code is Ok(
    "classify_for_punycode(label)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).791), call_expr_span: idna/src/uts46.rs:849:31: 849:59 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(0:156 ~ idna[bc6b]::uts46::classify_for_punycode), callee_span: idna/src/uts46.rs:849:31: 849:52 (#0), callee_path: "uts46::classify_for_punycode", constraint_depth: 1 }
The code is Ok(
    "classify_for_punycode",
)
The code is Ok(
    "label",
)
The code is Ok(
    "PunycodeClassification::Error",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).800), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:335:13: 335:38 (#129), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:335:13: 335:13 (#129), callee_path: "core::panicking::panic", constraint_depth: 2 }
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "",
)
The code is Ok(
    "!is_ascii(label)",
)
The code is Ok(
    "is_ascii(label)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).813), call_expr_span: idna/src/uts46.rs:850:18: 850:33 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(0:155 ~ idna[bc6b]::uts46::is_ascii), callee_span: idna/src/uts46.rs:850:18: 850:26 (#0), callee_path: "uts46::is_ascii", constraint_depth: 1 }
The code is Ok(
    "is_ascii",
)
The code is Ok(
    "label",
)
The code is Ok(
    "classify_for_punycode(label) == PunycodeClassification::Unicode",
)
The code is Ok(
    "classify_for_punycode(label)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).822), call_expr_span: idna/src/uts46.rs:852:17: 852:45 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(0:156 ~ idna[bc6b]::uts46::classify_for_punycode), callee_span: idna/src/uts46.rs:852:17: 852:38 (#0), callee_path: "uts46::classify_for_punycode", constraint_depth: 1 }
The code is Ok(
    "classify_for_punycode",
)
The code is Ok(
    "label",
)
The code is Ok(
    "PunycodeClassification::Unicode",
)
The code is Ok(
    "if potentially_punycode {\n                let unicode = output_as_unicode(label, tld, is_bidi);\n                had_unicode_output |= unicode;\n                unicode\n            } else {\n                true\n            }",
)
The code is Ok(
    "potentially_punycode",
)
The code is Ok(
    "output_as_unicode(label, tld, is_bidi)",
)
The code is Ok(
    "output_as_unicode",
)
The code is Ok(
    "label",
)
The code is Ok(
    "tld",
)
The code is Ok(
    "is_bidi",
)
The code is Ok(
    "had_unicode_output |= unicode",
)
The code is Ok(
    "unicode",
)
The code is Ok(
    "had_unicode_output",
)
The code is Ok(
    "unicode",
)
The code is Ok(
    "true",
)
The code is Ok(
    "if passthrough {\n                if !flushed_prefix {\n                    flushed_prefix = true;\n                    // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?;\n                }\n                for c in label.iter().copied() {\n                    sink.write_char(c)?;\n                }\n            } else if let AlreadyAsciiLabel::MixedCasePunycode(mixed_case) = input_punycode {\n                if let Some(first_upper_case) =\n                    mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                {\n                    let (head, tail) = mixed_case.split_at(first_upper_case);\n                    let slice_to_write = if flushed_prefix {\n                        head\n                    } else {\n                        flushed_prefix = true;\n                        passthrough_up_to_extended += head.len();\n                        debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                        &domain_name[..passthrough_up_to_extended]\n                    };\n                    // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?;\n                    for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }\n                } else if flushed_prefix {\n                    // SAFETY: `mixed_case` is known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                } else {\n                    passthrough_up_to_extended += mixed_case.len();\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n            } else {\n                if !flushed_prefix {\n                    flushed_prefix = true;\n                    // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?;\n                }\n                write_punycode_label(label, sink)?;\n            }",
)
The code is Ok(
    "passthrough",
)
The code is Ok(
    "if !flushed_prefix {\n                    flushed_prefix = true;\n                    // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?;\n                }",
)
The code is Ok(
    "!flushed_prefix",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "flushed_prefix = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?",
)
into Match call
The code is Ok(
    "sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?",
)
LangItem path: idna/src/uts46.rs:865:21: 867:24 (#377)
The code is Ok(
    "sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?",
)
The code is Ok(
    "sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).880),
    call_expr_span: idna/src/uts46.rs:865:21: 867:23 (#0),
    caller: Some(
        DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process),
    ),
    caller_span: None,
    callee: DefId(1:10604 ~ core[f118]::fmt::Write::write_str),
    callee_span: idna/src/uts46.rs:865:21: 867:23 (#0),
    callee_path: "core::fmt::Write::write_str",
    constraint_depth: 2,
}
The code is Ok(
    "sink",
)
The code is Ok(
    "unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    }",
)
The code is Ok(
    "core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).885), call_expr_span: idna/src/uts46.rs:866:25: 866:99 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:12976 ~ core[f118]::str::converts::from_utf8_unchecked), callee_span: idna/src/uts46.rs:866:25: 866:55 (#0), callee_path: "core::str::from_utf8_unchecked", constraint_depth: 2 }
The code is Ok(
    "core::str::from_utf8_unchecked",
)
The code is Ok(
    "&domain_name[..passthrough_up_to_extended]",
)
The code is Ok(
    "domain_name[..passthrough_up_to_extended]",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "..passthrough_up_to_extended",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?",
)
LangItem path: idna/src/uts46.rs:867:23: 867:24 (#378)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?",
)
The code is Ok(
    "for c in label.iter().copied() {\n                    sink.write_char(c)?;\n                }",
)
The code is Ok(
    "for c in label.iter().copied() {\n                    sink.write_char(c)?;\n                }",
)
into Match call
The code is Ok(
    "label.iter().copied()",
)
LangItem path: idna/src/uts46.rs:869:26: 869:47 (#380)
The code is Ok(
    "label.iter().copied()",
)
The code is Ok(
    "label.iter().copied()",
)
The code is Ok(
    "label.iter()",
)
The code is Ok(
    "label",
)
The code is Ok(
    "for c in label.iter().copied() {\n                    sink.write_char(c)?;\n                }",
)
The code is Ok(
    "label.iter().copied()",
)
into Match call
is inner Match
The code is Ok(
    "label.iter().copied()",
)
LangItem path: idna/src/uts46.rs:869:26: 869:47 (#380)
The code is Ok(
    "label.iter().copied()",
)
The code is Ok(
    "label.iter().copied()",
)
The code is Ok(
    "label.iter().copied()",
)
The code is Ok(
    "for c in label.iter().copied() {\n                    sink.write_char(c)?;\n                }",
)
The code is Ok(
    "{\n                    sink.write_char(c)?;\n                }",
)
The code is Ok(
    "sink.write_char(c)?",
)
into Match call
The code is Ok(
    "sink.write_char(c)?",
)
LangItem path: idna/src/uts46.rs:870:21: 870:40 (#382)
The code is Ok(
    "sink.write_char(c)?",
)
The code is Ok(
    "sink.write_char(c)",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).934),
    call_expr_span: idna/src/uts46.rs:870:21: 870:39 (#0),
    caller: Some(
        DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process),
    ),
    caller_span: None,
    callee: DefId(1:10605 ~ core[f118]::fmt::Write::write_char),
    callee_span: idna/src/uts46.rs:870:21: 870:39 (#0),
    callee_path: "core::fmt::Write::write_char",
    constraint_depth: 2,
}
The code is Ok(
    "sink",
)
The code is Ok(
    "c",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_char(c)?",
)
LangItem path: idna/src/uts46.rs:870:39: 870:40 (#383)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_char(c)?",
)
The code is Ok(
    "let AlreadyAsciiLabel::MixedCasePunycode(mixed_case) = input_punycode",
)
The code is Ok(
    "input_punycode",
)
The code is Ok(
    "{\n                if let Some(first_upper_case) =\n                    mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                {\n                    let (head, tail) = mixed_case.split_at(first_upper_case);\n                    let slice_to_write = if flushed_prefix {\n                        head\n                    } else {\n                        flushed_prefix = true;\n                        passthrough_up_to_extended += head.len();\n                        debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                        &domain_name[..passthrough_up_to_extended]\n                    };\n                    // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?;\n                    for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }\n                } else if flushed_prefix {\n                    // SAFETY: `mixed_case` is known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                } else {\n                    passthrough_up_to_extended += mixed_case.len();\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n            }",
)
The code is Ok(
    "if let Some(first_upper_case) =\n                    mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                {\n                    let (head, tail) = mixed_case.split_at(first_upper_case);\n                    let slice_to_write = if flushed_prefix {\n                        head\n                    } else {\n                        flushed_prefix = true;\n                        passthrough_up_to_extended += head.len();\n                        debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                        &domain_name[..passthrough_up_to_extended]\n                    };\n                    // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?;\n                    for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }\n                } else if flushed_prefix {\n                    // SAFETY: `mixed_case` is known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                } else {\n                    passthrough_up_to_extended += mixed_case.len();\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }",
)
The code is Ok(
    "mixed_case.iter().position(|c| c.is_ascii_uppercase())",
)
The code is Ok(
    "mixed_case.iter()",
)
The code is Ok(
    "mixed_case",
)
The code is Ok(
    "|c| c.is_ascii_uppercase()",
)
The code is Ok(
    "c.is_ascii_uppercase()",
)
The code is Ok(
    "c",
)
The code is Ok(
    "mixed_case.split_at(first_upper_case)",
)
The code is Ok(
    "mixed_case",
)
The code is Ok(
    "first_upper_case",
)
The code is Ok(
    "if flushed_prefix {\n                        head\n                    } else {\n                        flushed_prefix = true;\n                        passthrough_up_to_extended += head.len();\n                        debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                        &domain_name[..passthrough_up_to_extended]\n                    }",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "head",
)
The code is Ok(
    "flushed_prefix = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "passthrough_up_to_extended += head.len()",
)
The code is Ok(
    "head.len()",
)
The code is Ok(
    "head",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "if $crate::cfg!(debug_assertions) {\n            $crate::assert_ne!($($arg)*);\n        }",
)
The code is Ok(
    "$crate::cfg!(debug_assertions)",
)
The code is Ok(
    "match (&$left, &$right) {\n            (left_val, right_val) => {\n                if *left_val == *right_val {\n                    let kind = $crate::panicking::AssertKind::Ne;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }\n            }\n        }",
)
The code is Ok(
    "(&$left, &$right)",
)
The code is Ok(
    "&$left",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "&$right",
)
The code is Ok(
    "domain_name.len()",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "{\n                if *left_val == *right_val {\n                    let kind = $crate::panicking::AssertKind::Ne;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }\n            }",
)
The code is Ok(
    "if *left_val == *right_val {\n                    let kind = $crate::panicking::AssertKind::Ne;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }",
)
The code is Ok(
    "*left_val == *right_val",
)
The code is Ok(
    "*left_val",
)
The code is Ok(
    "left_val",
)
The code is Ok(
    "*right_val",
)
The code is Ok(
    "right_val",
)
The code is Ok(
    "$crate::panicking::AssertKind::Ne",
)
The code is Ok(
    "$crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1073), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:107:21: 107:114 (#133), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:9590 ~ core[f118]::panicking::assert_failed), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:107:21: 107:53 (#133), callee_path: "core::panicking::assert_failed", constraint_depth: 3 }
The code is Ok(
    "$crate::panicking::assert_failed",
)
The code is Ok(
    "kind",
)
The code is Ok(
    "&*left_val",
)
The code is Ok(
    "*left_val",
)
The code is Ok(
    "left_val",
)
The code is Ok(
    "&*right_val",
)
The code is Ok(
    "*right_val",
)
The code is Ok(
    "right_val",
)
The code is Ok(
    "$crate::option::Option::None",
)
The code is Ok(
    "&domain_name[..passthrough_up_to_extended]",
)
The code is Ok(
    "domain_name[..passthrough_up_to_extended]",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "..passthrough_up_to_extended",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?",
)
into Match call
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?",
)
LangItem path: idna/src/uts46.rs:886:21: 886:95 (#389)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1113),
    call_expr_span: idna/src/uts46.rs:886:21: 886:94 (#0),
    caller: Some(
        DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process),
    ),
    caller_span: None,
    callee: DefId(1:10604 ~ core[f118]::fmt::Write::write_str),
    callee_span: idna/src/uts46.rs:886:21: 886:94 (#0),
    callee_path: "core::fmt::Write::write_str",
    constraint_depth: 1,
}
The code is Ok(
    "sink",
)
The code is Ok(
    "unsafe { core::str::from_utf8_unchecked(slice_to_write) }",
)
The code is Ok(
    "core::str::from_utf8_unchecked(slice_to_write)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1118), call_expr_span: idna/src/uts46.rs:886:45: 886:91 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:12976 ~ core[f118]::str::converts::from_utf8_unchecked), callee_span: idna/src/uts46.rs:886:45: 886:75 (#0), callee_path: "core::str::from_utf8_unchecked", constraint_depth: 1 }
The code is Ok(
    "core::str::from_utf8_unchecked",
)
The code is Ok(
    "slice_to_write",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?",
)
LangItem path: idna/src/uts46.rs:886:94: 886:95 (#390)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(slice_to_write) })?",
)
The code is Ok(
    "for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }",
)
The code is Ok(
    "for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }",
)
into Match call
The code is Ok(
    "tail.iter()",
)
LangItem path: idna/src/uts46.rs:887:30: 887:41 (#392)
The code is Ok(
    "tail.iter()",
)
The code is Ok(
    "tail.iter()",
)
The code is Ok(
    "tail",
)
The code is Ok(
    "for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }",
)
The code is Ok(
    "tail.iter()",
)
into Match call
is inner Match
The code is Ok(
    "tail.iter()",
)
LangItem path: idna/src/uts46.rs:887:30: 887:41 (#392)
The code is Ok(
    "tail.iter()",
)
The code is Ok(
    "tail.iter()",
)
The code is Ok(
    "tail.iter()",
)
The code is Ok(
    "for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }",
)
The code is Ok(
    "{\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }",
)
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))?",
)
into Match call
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))?",
)
LangItem path: idna/src/uts46.rs:888:25: 888:77 (#394)
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))?",
)
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1156),
    call_expr_span: idna/src/uts46.rs:888:25: 888:76 (#0),
    caller: Some(
        DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process),
    ),
    caller_span: None,
    callee: DefId(1:10605 ~ core[f118]::fmt::Write::write_char),
    callee_span: idna/src/uts46.rs:888:25: 888:76 (#0),
    callee_path: "core::fmt::Write::write_char",
    constraint_depth: 2,
}
The code is Ok(
    "sink",
)
The code is Ok(
    "char::from(c.to_ascii_lowercase())",
)
The code is Ok(
    "char::from",
)
The code is Ok(
    "c.to_ascii_lowercase()",
)
The code is Ok(
    "c",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))?",
)
LangItem path: idna/src/uts46.rs:888:76: 888:77 (#395)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))?",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "{\n                    // SAFETY: `mixed_case` is known to be ASCII.\n                    sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                }",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?",
)
into Match call
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?",
)
LangItem path: idna/src/uts46.rs:892:21: 892:91 (#397)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1211),
    call_expr_span: idna/src/uts46.rs:892:21: 892:90 (#0),
    caller: Some(
        DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process),
    ),
    caller_span: None,
    callee: DefId(1:10604 ~ core[f118]::fmt::Write::write_str),
    callee_span: idna/src/uts46.rs:892:21: 892:90 (#0),
    callee_path: "core::fmt::Write::write_str",
    constraint_depth: 1,
}
The code is Ok(
    "sink",
)
The code is Ok(
    "unsafe { core::str::from_utf8_unchecked(mixed_case) }",
)
The code is Ok(
    "core::str::from_utf8_unchecked(mixed_case)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1216), call_expr_span: idna/src/uts46.rs:892:45: 892:87 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:12976 ~ core[f118]::str::converts::from_utf8_unchecked), callee_span: idna/src/uts46.rs:892:45: 892:75 (#0), callee_path: "core::str::from_utf8_unchecked", constraint_depth: 1 }
The code is Ok(
    "core::str::from_utf8_unchecked",
)
The code is Ok(
    "mixed_case",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?",
)
LangItem path: idna/src/uts46.rs:892:90: 892:91 (#398)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?",
)
The code is Ok(
    "{\n                    passthrough_up_to_extended += mixed_case.len();\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }",
)
The code is Ok(
    "passthrough_up_to_extended += mixed_case.len()",
)
The code is Ok(
    "mixed_case.len()",
)
The code is Ok(
    "mixed_case",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(!had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }",
)
The code is Ok(
    "passthrough_up_to_extended == domain_name.len()",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "domain_name.len()",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "if $crate::cfg!(debug_assertions) {\n            $crate::assert!($($arg)*);\n        }",
)
The code is Ok(
    "$crate::cfg!(debug_assertions)",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "!had_errors",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1271), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:335:13: 335:38 (#136), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:335:13: 335:13 (#136), callee_path: "core::panicking::panic", constraint_depth: 2 }
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "",
)
The code is Ok(
    "return Ok(ProcessingSuccess::Passthrough)",
)
The code is Ok(
    "Ok(ProcessingSuccess::Passthrough)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1284), call_expr_span: idna/src/uts46.rs:897:32: 897:66 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:45569 ~ core[f118]::result::Result::Ok::{constructor#0}), callee_span: idna/src/uts46.rs:897:32: 897:34 (#0), callee_path: "core::prelude::v1::Ok", constraint_depth: 1 }
The code is Ok(
    "Ok",
)
The code is Ok(
    "ProcessingSuccess::Passthrough",
)
The code is Ok(
    "{\n                if !flushed_prefix {\n                    flushed_prefix = true;\n                    // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?;\n                }\n                write_punycode_label(label, sink)?;\n            }",
)
The code is Ok(
    "if !flushed_prefix {\n                    flushed_prefix = true;\n                    // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?;\n                }",
)
The code is Ok(
    "!flushed_prefix",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "flushed_prefix = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?",
)
into Match call
The code is Ok(
    "sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?",
)
LangItem path: idna/src/uts46.rs:904:21: 906:24 (#406)
The code is Ok(
    "sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?",
)
The code is Ok(
    "sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1308),
    call_expr_span: idna/src/uts46.rs:904:21: 906:23 (#0),
    caller: Some(
        DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process),
    ),
    caller_span: None,
    callee: DefId(1:10604 ~ core[f118]::fmt::Write::write_str),
    callee_span: idna/src/uts46.rs:904:21: 906:23 (#0),
    callee_path: "core::fmt::Write::write_str",
    constraint_depth: 2,
}
The code is Ok(
    "sink",
)
The code is Ok(
    "unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    }",
)
The code is Ok(
    "core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1313), call_expr_span: idna/src/uts46.rs:905:25: 905:99 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:12976 ~ core[f118]::str::converts::from_utf8_unchecked), callee_span: idna/src/uts46.rs:905:25: 905:55 (#0), callee_path: "core::str::from_utf8_unchecked", constraint_depth: 2 }
The code is Ok(
    "core::str::from_utf8_unchecked",
)
The code is Ok(
    "&domain_name[..passthrough_up_to_extended]",
)
The code is Ok(
    "domain_name[..passthrough_up_to_extended]",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "..passthrough_up_to_extended",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?",
)
LangItem path: idna/src/uts46.rs:906:23: 906:24 (#407)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?",
)
The code is Ok(
    "write_punycode_label(label, sink)?",
)
into Match call
The code is Ok(
    "write_punycode_label(label, sink)?",
)
LangItem path: idna/src/uts46.rs:908:17: 908:51 (#408)
The code is Ok(
    "write_punycode_label(label, sink)?",
)
The code is Ok(
    "write_punycode_label(label, sink)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1349), call_expr_span: idna/src/uts46.rs:908:17: 908:50 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(0:145 ~ idna[bc6b]::uts46::write_punycode_label), callee_span: idna/src/uts46.rs:908:17: 908:37 (#0), callee_path: "uts46::write_punycode_label", constraint_depth: 1 }
The code is Ok(
    "write_punycode_label",
)
The code is Ok(
    "label",
)
The code is Ok(
    "sink",
)
The code is Ok(
    "?",
)
The code is Ok(
    "write_punycode_label(label, sink)?",
)
LangItem path: idna/src/uts46.rs:908:50: 908:51 (#409)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "write_punycode_label(label, sink)?",
)
The code is Ok(
    "if had_errors {\n            return Err(ProcessingError::ValidityError);\n        }",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "return Err(ProcessingError::ValidityError)",
)
The code is Ok(
    "Err(ProcessingError::ValidityError)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1398), call_expr_span: idna/src/uts46.rs:913:20: 913:55 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:45572 ~ core[f118]::result::Result::Err::{constructor#0}), callee_span: idna/src/uts46.rs:913:20: 913:23 (#0), callee_path: "core::prelude::v1::Err", constraint_depth: 1 }
The code is Ok(
    "Err",
)
The code is Ok(
    "ProcessingError::ValidityError",
)
The code is Ok(
    "if had_unicode_output {\n            if let Some(sink) = ascii_sink {\n                let mut seen_label = false;\n                let mut already_punycode_iter = already_punycode.iter();\n                let mut passthrough_up_to_extended = passthrough_up_to;\n                let mut flushed_prefix = false;\n                for label in domain_buffer.split(|c| *c == '.') {\n                    // Unwrap is OK, because there are supposed to be as many items in\n                    // `already_punycode` as there are labels.\n                    let input_punycode = *already_punycode_iter.next().unwrap();\n                    if seen_label {\n                        if flushed_prefix {\n                            sink.write_char('.')?;\n                        } else {\n                            debug_assert_eq!(domain_name[passthrough_up_to_extended], b'.');\n                            passthrough_up_to_extended += 1;\n                        }\n                    }\n                    seen_label = true;\n\n                    if let AlreadyAsciiLabel::MixedCaseAscii(mixed_case) = input_punycode {\n                        if let Some(first_upper_case) =\n                            mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                        {\n                            let (head, tail) = mixed_case.split_at(first_upper_case);\n                            let slice_to_write = if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                                &domain_name[..passthrough_up_to_extended]\n                            };\n                            // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?;\n                            for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }\n                        } else if flushed_prefix {\n                            // SAFETY: `mixed_case` is known to be ASCII.\n                            sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                        } else {\n                            passthrough_up_to_extended += mixed_case.len();\n                        }\n                        continue;\n                    }\n\n                    if is_ascii(label) {\n                        if !flushed_prefix {\n                            flushed_prefix = true;\n                            // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?;\n                        }\n                        for c in label.iter().copied() {\n                            sink.write_char(c)?;\n                        }\n                    } else if let AlreadyAsciiLabel::MixedCasePunycode(mixed_case) = input_punycode\n                    {\n                        if let Some(first_upper_case) =\n                            mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                        {\n                            let (head, tail) = mixed_case.split_at(first_upper_case);\n                            let slice_to_write = if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                                &domain_name[..passthrough_up_to_extended]\n                            };\n                            // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?;\n                            for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }\n                        } else if flushed_prefix {\n                            // SAFETY: `mixed_case` is known to be ASCII.\n                            sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                        } else {\n                            passthrough_up_to_extended += mixed_case.len();\n                        }\n                    } else {\n                        if !flushed_prefix {\n                            flushed_prefix = true;\n                            // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?;\n                        }\n                        write_punycode_label(label, sink)?;\n                    }\n                }\n                if !flushed_prefix {\n                    // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?;\n                }\n            }\n        }",
)
The code is Ok(
    "had_unicode_output",
)
The code is Ok(
    "if let Some(sink) = ascii_sink {\n                let mut seen_label = false;\n                let mut already_punycode_iter = already_punycode.iter();\n                let mut passthrough_up_to_extended = passthrough_up_to;\n                let mut flushed_prefix = false;\n                for label in domain_buffer.split(|c| *c == '.') {\n                    // Unwrap is OK, because there are supposed to be as many items in\n                    // `already_punycode` as there are labels.\n                    let input_punycode = *already_punycode_iter.next().unwrap();\n                    if seen_label {\n                        if flushed_prefix {\n                            sink.write_char('.')?;\n                        } else {\n                            debug_assert_eq!(domain_name[passthrough_up_to_extended], b'.');\n                            passthrough_up_to_extended += 1;\n                        }\n                    }\n                    seen_label = true;\n\n                    if let AlreadyAsciiLabel::MixedCaseAscii(mixed_case) = input_punycode {\n                        if let Some(first_upper_case) =\n                            mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                        {\n                            let (head, tail) = mixed_case.split_at(first_upper_case);\n                            let slice_to_write = if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                                &domain_name[..passthrough_up_to_extended]\n                            };\n                            // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?;\n                            for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }\n                        } else if flushed_prefix {\n                            // SAFETY: `mixed_case` is known to be ASCII.\n                            sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                        } else {\n                            passthrough_up_to_extended += mixed_case.len();\n                        }\n                        continue;\n                    }\n\n                    if is_ascii(label) {\n                        if !flushed_prefix {\n                            flushed_prefix = true;\n                            // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?;\n                        }\n                        for c in label.iter().copied() {\n                            sink.write_char(c)?;\n                        }\n                    } else if let AlreadyAsciiLabel::MixedCasePunycode(mixed_case) = input_punycode\n                    {\n                        if let Some(first_upper_case) =\n                            mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                        {\n                            let (head, tail) = mixed_case.split_at(first_upper_case);\n                            let slice_to_write = if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                                &domain_name[..passthrough_up_to_extended]\n                            };\n                            // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?;\n                            for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }\n                        } else if flushed_prefix {\n                            // SAFETY: `mixed_case` is known to be ASCII.\n                            sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                        } else {\n                            passthrough_up_to_extended += mixed_case.len();\n                        }\n                    } else {\n                        if !flushed_prefix {\n                            flushed_prefix = true;\n                            // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?;\n                        }\n                        write_punycode_label(label, sink)?;\n                    }\n                }\n                if !flushed_prefix {\n                    // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?;\n                }\n            }",
)
The code is Ok(
    "ascii_sink",
)
The code is Ok(
    "false",
)
The code is Ok(
    "already_punycode.iter()",
)
The code is Ok(
    "already_punycode",
)
The code is Ok(
    "passthrough_up_to",
)
The code is Ok(
    "false",
)
The code is Ok(
    "for label in domain_buffer.split(|c| *c == '.') {\n                    // Unwrap is OK, because there are supposed to be as many items in\n                    // `already_punycode` as there are labels.\n                    let input_punycode = *already_punycode_iter.next().unwrap();\n                    if seen_label {\n                        if flushed_prefix {\n                            sink.write_char('.')?;\n                        } else {\n                            debug_assert_eq!(domain_name[passthrough_up_to_extended], b'.');\n                            passthrough_up_to_extended += 1;\n                        }\n                    }\n                    seen_label = true;\n\n                    if let AlreadyAsciiLabel::MixedCaseAscii(mixed_case) = input_punycode {\n                        if let Some(first_upper_case) =\n                            mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                        {\n                            let (head, tail) = mixed_case.split_at(first_upper_case);\n                            let slice_to_write = if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                                &domain_name[..passthrough_up_to_extended]\n                            };\n                            // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?;\n                            for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }\n                        } else if flushed_prefix {\n                            // SAFETY: `mixed_case` is known to be ASCII.\n                            sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                        } else {\n                            passthrough_up_to_extended += mixed_case.len();\n                        }\n                        continue;\n                    }\n\n                    if is_ascii(label) {\n                        if !flushed_prefix {\n                            flushed_prefix = true;\n                            // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?;\n                        }\n                        for c in label.iter().copied() {\n                            sink.write_char(c)?;\n                        }\n                    } else if let AlreadyAsciiLabel::MixedCasePunycode(mixed_case) = input_punycode\n                    {\n                        if let Some(first_upper_case) =\n                            mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                        {\n                            let (head, tail) = mixed_case.split_at(first_upper_case);\n                            let slice_to_write = if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                                &domain_name[..passthrough_up_to_extended]\n                            };\n                            // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?;\n                            for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }\n                        } else if flushed_prefix {\n                            // SAFETY: `mixed_case` is known to be ASCII.\n                            sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                        } else {\n                            passthrough_up_to_extended += mixed_case.len();\n                        }\n                    } else {\n                        if !flushed_prefix {\n                            flushed_prefix = true;\n                            // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?;\n                        }\n                        write_punycode_label(label, sink)?;\n                    }\n                }",
)
The code is Ok(
    "for label in domain_buffer.split(|c| *c == '.') {\n                    // Unwrap is OK, because there are supposed to be as many items in\n                    // `already_punycode` as there are labels.\n                    let input_punycode = *already_punycode_iter.next().unwrap();\n                    if seen_label {\n                        if flushed_prefix {\n                            sink.write_char('.')?;\n                        } else {\n                            debug_assert_eq!(domain_name[passthrough_up_to_extended], b'.');\n                            passthrough_up_to_extended += 1;\n                        }\n                    }\n                    seen_label = true;\n\n                    if let AlreadyAsciiLabel::MixedCaseAscii(mixed_case) = input_punycode {\n                        if let Some(first_upper_case) =\n                            mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                        {\n                            let (head, tail) = mixed_case.split_at(first_upper_case);\n                            let slice_to_write = if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                                &domain_name[..passthrough_up_to_extended]\n                            };\n                            // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?;\n                            for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }\n                        } else if flushed_prefix {\n                            // SAFETY: `mixed_case` is known to be ASCII.\n                            sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                        } else {\n                            passthrough_up_to_extended += mixed_case.len();\n                        }\n                        continue;\n                    }\n\n                    if is_ascii(label) {\n                        if !flushed_prefix {\n                            flushed_prefix = true;\n                            // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?;\n                        }\n                        for c in label.iter().copied() {\n                            sink.write_char(c)?;\n                        }\n                    } else if let AlreadyAsciiLabel::MixedCasePunycode(mixed_case) = input_punycode\n                    {\n                        if let Some(first_upper_case) =\n                            mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                        {\n                            let (head, tail) = mixed_case.split_at(first_upper_case);\n                            let slice_to_write = if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                                &domain_name[..passthrough_up_to_extended]\n                            };\n                            // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?;\n                            for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }\n                        } else if flushed_prefix {\n                            // SAFETY: `mixed_case` is known to be ASCII.\n                            sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                        } else {\n                            passthrough_up_to_extended += mixed_case.len();\n                        }\n                    } else {\n                        if !flushed_prefix {\n                            flushed_prefix = true;\n                            // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?;\n                        }\n                        write_punycode_label(label, sink)?;\n                    }\n                }",
)
into Match call
The code is Ok(
    "domain_buffer.split(|c| *c == '.')",
)
LangItem path: idna/src/uts46.rs:922:30: 922:64 (#413)
The code is Ok(
    "domain_buffer.split(|c| *c == '.')",
)
The code is Ok(
    "domain_buffer.split(|c| *c == '.')",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "|c| *c == '.'",
)
The code is Ok(
    "*c == '.'",
)
The code is Ok(
    "*c",
)
The code is Ok(
    "c",
)
The code is Ok(
    "'.'",
)
The code is Ok(
    "for label in domain_buffer.split(|c| *c == '.') {\n                    // Unwrap is OK, because there are supposed to be as many items in\n                    // `already_punycode` as there are labels.\n                    let input_punycode = *already_punycode_iter.next().unwrap();\n                    if seen_label {\n                        if flushed_prefix {\n                            sink.write_char('.')?;\n                        } else {\n                            debug_assert_eq!(domain_name[passthrough_up_to_extended], b'.');\n                            passthrough_up_to_extended += 1;\n                        }\n                    }\n                    seen_label = true;\n\n                    if let AlreadyAsciiLabel::MixedCaseAscii(mixed_case) = input_punycode {\n                        if let Some(first_upper_case) =\n                            mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                        {\n                            let (head, tail) = mixed_case.split_at(first_upper_case);\n                            let slice_to_write = if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                                &domain_name[..passthrough_up_to_extended]\n                            };\n                            // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?;\n                            for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }\n                        } else if flushed_prefix {\n                            // SAFETY: `mixed_case` is known to be ASCII.\n                            sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                        } else {\n                            passthrough_up_to_extended += mixed_case.len();\n                        }\n                        continue;\n                    }\n\n                    if is_ascii(label) {\n                        if !flushed_prefix {\n                            flushed_prefix = true;\n                            // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?;\n                        }\n                        for c in label.iter().copied() {\n                            sink.write_char(c)?;\n                        }\n                    } else if let AlreadyAsciiLabel::MixedCasePunycode(mixed_case) = input_punycode\n                    {\n                        if let Some(first_upper_case) =\n                            mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                        {\n                            let (head, tail) = mixed_case.split_at(first_upper_case);\n                            let slice_to_write = if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                                &domain_name[..passthrough_up_to_extended]\n                            };\n                            // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?;\n                            for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }\n                        } else if flushed_prefix {\n                            // SAFETY: `mixed_case` is known to be ASCII.\n                            sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                        } else {\n                            passthrough_up_to_extended += mixed_case.len();\n                        }\n                    } else {\n                        if !flushed_prefix {\n                            flushed_prefix = true;\n                            // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?;\n                        }\n                        write_punycode_label(label, sink)?;\n                    }\n                }",
)
The code is Ok(
    "domain_buffer.split(|c| *c == '.')",
)
into Match call
is inner Match
The code is Ok(
    "domain_buffer.split(|c| *c == '.')",
)
LangItem path: idna/src/uts46.rs:922:30: 922:64 (#413)
The code is Ok(
    "domain_buffer.split(|c| *c == '.')",
)
The code is Ok(
    "domain_buffer.split(|c| *c == '.')",
)
The code is Ok(
    "domain_buffer.split(|c| *c == '.')",
)
The code is Ok(
    "for label in domain_buffer.split(|c| *c == '.') {\n                    // Unwrap is OK, because there are supposed to be as many items in\n                    // `already_punycode` as there are labels.\n                    let input_punycode = *already_punycode_iter.next().unwrap();\n                    if seen_label {\n                        if flushed_prefix {\n                            sink.write_char('.')?;\n                        } else {\n                            debug_assert_eq!(domain_name[passthrough_up_to_extended], b'.');\n                            passthrough_up_to_extended += 1;\n                        }\n                    }\n                    seen_label = true;\n\n                    if let AlreadyAsciiLabel::MixedCaseAscii(mixed_case) = input_punycode {\n                        if let Some(first_upper_case) =\n                            mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                        {\n                            let (head, tail) = mixed_case.split_at(first_upper_case);\n                            let slice_to_write = if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                                &domain_name[..passthrough_up_to_extended]\n                            };\n                            // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?;\n                            for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }\n                        } else if flushed_prefix {\n                            // SAFETY: `mixed_case` is known to be ASCII.\n                            sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                        } else {\n                            passthrough_up_to_extended += mixed_case.len();\n                        }\n                        continue;\n                    }\n\n                    if is_ascii(label) {\n                        if !flushed_prefix {\n                            flushed_prefix = true;\n                            // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?;\n                        }\n                        for c in label.iter().copied() {\n                            sink.write_char(c)?;\n                        }\n                    } else if let AlreadyAsciiLabel::MixedCasePunycode(mixed_case) = input_punycode\n                    {\n                        if let Some(first_upper_case) =\n                            mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                        {\n                            let (head, tail) = mixed_case.split_at(first_upper_case);\n                            let slice_to_write = if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                                &domain_name[..passthrough_up_to_extended]\n                            };\n                            // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?;\n                            for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }\n                        } else if flushed_prefix {\n                            // SAFETY: `mixed_case` is known to be ASCII.\n                            sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                        } else {\n                            passthrough_up_to_extended += mixed_case.len();\n                        }\n                    } else {\n                        if !flushed_prefix {\n                            flushed_prefix = true;\n                            // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?;\n                        }\n                        write_punycode_label(label, sink)?;\n                    }\n                }",
)
The code is Ok(
    "{\n                    // Unwrap is OK, because there are supposed to be as many items in\n                    // `already_punycode` as there are labels.\n                    let input_punycode = *already_punycode_iter.next().unwrap();\n                    if seen_label {\n                        if flushed_prefix {\n                            sink.write_char('.')?;\n                        } else {\n                            debug_assert_eq!(domain_name[passthrough_up_to_extended], b'.');\n                            passthrough_up_to_extended += 1;\n                        }\n                    }\n                    seen_label = true;\n\n                    if let AlreadyAsciiLabel::MixedCaseAscii(mixed_case) = input_punycode {\n                        if let Some(first_upper_case) =\n                            mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                        {\n                            let (head, tail) = mixed_case.split_at(first_upper_case);\n                            let slice_to_write = if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                                &domain_name[..passthrough_up_to_extended]\n                            };\n                            // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?;\n                            for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }\n                        } else if flushed_prefix {\n                            // SAFETY: `mixed_case` is known to be ASCII.\n                            sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                        } else {\n                            passthrough_up_to_extended += mixed_case.len();\n                        }\n                        continue;\n                    }\n\n                    if is_ascii(label) {\n                        if !flushed_prefix {\n                            flushed_prefix = true;\n                            // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?;\n                        }\n                        for c in label.iter().copied() {\n                            sink.write_char(c)?;\n                        }\n                    } else if let AlreadyAsciiLabel::MixedCasePunycode(mixed_case) = input_punycode\n                    {\n                        if let Some(first_upper_case) =\n                            mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                        {\n                            let (head, tail) = mixed_case.split_at(first_upper_case);\n                            let slice_to_write = if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                                &domain_name[..passthrough_up_to_extended]\n                            };\n                            // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?;\n                            for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }\n                        } else if flushed_prefix {\n                            // SAFETY: `mixed_case` is known to be ASCII.\n                            sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                        } else {\n                            passthrough_up_to_extended += mixed_case.len();\n                        }\n                    } else {\n                        if !flushed_prefix {\n                            flushed_prefix = true;\n                            // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?;\n                        }\n                        write_punycode_label(label, sink)?;\n                    }\n                }",
)
The code is Ok(
    "*already_punycode_iter.next().unwrap()",
)
The code is Ok(
    "already_punycode_iter.next().unwrap()",
)
The code is Ok(
    "already_punycode_iter.next()",
)
The code is Ok(
    "already_punycode_iter",
)
The code is Ok(
    "if seen_label {\n                        if flushed_prefix {\n                            sink.write_char('.')?;\n                        } else {\n                            debug_assert_eq!(domain_name[passthrough_up_to_extended], b'.');\n                            passthrough_up_to_extended += 1;\n                        }\n                    }",
)
The code is Ok(
    "seen_label",
)
The code is Ok(
    "if flushed_prefix {\n                            sink.write_char('.')?;\n                        } else {\n                            debug_assert_eq!(domain_name[passthrough_up_to_extended], b'.');\n                            passthrough_up_to_extended += 1;\n                        }",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "sink.write_char('.')?",
)
into Match call
The code is Ok(
    "sink.write_char('.')?",
)
LangItem path: idna/src/uts46.rs:928:29: 928:50 (#417)
The code is Ok(
    "sink.write_char('.')?",
)
The code is Ok(
    "sink.write_char('.')",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1478),
    call_expr_span: idna/src/uts46.rs:928:29: 928:49 (#0),
    caller: Some(
        DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process),
    ),
    caller_span: None,
    callee: DefId(1:10605 ~ core[f118]::fmt::Write::write_char),
    callee_span: idna/src/uts46.rs:928:29: 928:49 (#0),
    callee_path: "core::fmt::Write::write_char",
    constraint_depth: 1,
}
The code is Ok(
    "sink",
)
The code is Ok(
    "'.'",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_char('.')?",
)
LangItem path: idna/src/uts46.rs:928:49: 928:50 (#418)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_char('.')?",
)
The code is Ok(
    "if $crate::cfg!(debug_assertions) {\n            $crate::assert_eq!($($arg)*);\n        }",
)
The code is Ok(
    "$crate::cfg!(debug_assertions)",
)
The code is Ok(
    "match (&$left, &$right) {\n            (left_val, right_val) => {\n                if !(*left_val == *right_val) {\n                    let kind = $crate::panicking::AssertKind::Eq;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }\n            }\n        }",
)
The code is Ok(
    "(&$left, &$right)",
)
The code is Ok(
    "&$left",
)
The code is Ok(
    "domain_name[passthrough_up_to_extended]",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "&$right",
)
The code is Ok(
    "b'.'",
)
The code is Ok(
    "{\n                if !(*left_val == *right_val) {\n                    let kind = $crate::panicking::AssertKind::Eq;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }\n            }",
)
The code is Ok(
    "if !(*left_val == *right_val) {\n                    let kind = $crate::panicking::AssertKind::Eq;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }",
)
The code is Ok(
    "!(*left_val == *right_val)",
)
The code is Ok(
    "(*left_val == *right_val)",
)
The code is Ok(
    "*left_val",
)
The code is Ok(
    "left_val",
)
The code is Ok(
    "*right_val",
)
The code is Ok(
    "right_val",
)
The code is Ok(
    "$crate::panicking::AssertKind::Eq",
)
The code is Ok(
    "$crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1540), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:51:21: 51:114 (#140), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:9590 ~ core[f118]::panicking::assert_failed), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:51:21: 51:53 (#140), callee_path: "core::panicking::assert_failed", constraint_depth: 3 }
The code is Ok(
    "$crate::panicking::assert_failed",
)
The code is Ok(
    "kind",
)
The code is Ok(
    "&*left_val",
)
The code is Ok(
    "*left_val",
)
The code is Ok(
    "left_val",
)
The code is Ok(
    "&*right_val",
)
The code is Ok(
    "*right_val",
)
The code is Ok(
    "right_val",
)
The code is Ok(
    "$crate::option::Option::None",
)
The code is Ok(
    "passthrough_up_to_extended += 1",
)
The code is Ok(
    "1",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "seen_label = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "seen_label",
)
The code is Ok(
    "if let AlreadyAsciiLabel::MixedCaseAscii(mixed_case) = input_punycode {\n                        if let Some(first_upper_case) =\n                            mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                        {\n                            let (head, tail) = mixed_case.split_at(first_upper_case);\n                            let slice_to_write = if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                                &domain_name[..passthrough_up_to_extended]\n                            };\n                            // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?;\n                            for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }\n                        } else if flushed_prefix {\n                            // SAFETY: `mixed_case` is known to be ASCII.\n                            sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                        } else {\n                            passthrough_up_to_extended += mixed_case.len();\n                        }\n                        continue;\n                    }",
)
The code is Ok(
    "input_punycode",
)
The code is Ok(
    "if let Some(first_upper_case) =\n                            mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                        {\n                            let (head, tail) = mixed_case.split_at(first_upper_case);\n                            let slice_to_write = if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                                &domain_name[..passthrough_up_to_extended]\n                            };\n                            // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?;\n                            for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }\n                        } else if flushed_prefix {\n                            // SAFETY: `mixed_case` is known to be ASCII.\n                            sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                        } else {\n                            passthrough_up_to_extended += mixed_case.len();\n                        }",
)
The code is Ok(
    "mixed_case.iter().position(|c| c.is_ascii_uppercase())",
)
The code is Ok(
    "mixed_case.iter()",
)
The code is Ok(
    "mixed_case",
)
The code is Ok(
    "|c| c.is_ascii_uppercase()",
)
The code is Ok(
    "c.is_ascii_uppercase()",
)
The code is Ok(
    "c",
)
The code is Ok(
    "mixed_case.split_at(first_upper_case)",
)
The code is Ok(
    "mixed_case",
)
The code is Ok(
    "first_upper_case",
)
The code is Ok(
    "if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                                &domain_name[..passthrough_up_to_extended]\n                            }",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "head",
)
The code is Ok(
    "flushed_prefix = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "passthrough_up_to_extended += head.len()",
)
The code is Ok(
    "head.len()",
)
The code is Ok(
    "head",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "if $crate::cfg!(debug_assertions) {\n            $crate::assert_ne!($($arg)*);\n        }",
)
The code is Ok(
    "$crate::cfg!(debug_assertions)",
)
The code is Ok(
    "match (&$left, &$right) {\n            (left_val, right_val) => {\n                if *left_val == *right_val {\n                    let kind = $crate::panicking::AssertKind::Ne;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }\n            }\n        }",
)
The code is Ok(
    "(&$left, &$right)",
)
The code is Ok(
    "&$left",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "&$right",
)
The code is Ok(
    "domain_name.len()",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "{\n                if *left_val == *right_val {\n                    let kind = $crate::panicking::AssertKind::Ne;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }\n            }",
)
The code is Ok(
    "if *left_val == *right_val {\n                    let kind = $crate::panicking::AssertKind::Ne;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }",
)
The code is Ok(
    "*left_val == *right_val",
)
The code is Ok(
    "*left_val",
)
The code is Ok(
    "left_val",
)
The code is Ok(
    "*right_val",
)
The code is Ok(
    "right_val",
)
The code is Ok(
    "$crate::panicking::AssertKind::Ne",
)
The code is Ok(
    "$crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1678), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:107:21: 107:114 (#143), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:9590 ~ core[f118]::panicking::assert_failed), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:107:21: 107:53 (#143), callee_path: "core::panicking::assert_failed", constraint_depth: 3 }
The code is Ok(
    "$crate::panicking::assert_failed",
)
The code is Ok(
    "kind",
)
The code is Ok(
    "&*left_val",
)
The code is Ok(
    "*left_val",
)
The code is Ok(
    "left_val",
)
The code is Ok(
    "&*right_val",
)
The code is Ok(
    "*right_val",
)
The code is Ok(
    "right_val",
)
The code is Ok(
    "$crate::option::Option::None",
)
The code is Ok(
    "&domain_name[..passthrough_up_to_extended]",
)
The code is Ok(
    "domain_name[..passthrough_up_to_extended]",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "..passthrough_up_to_extended",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?",
)
into Match call
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?",
)
LangItem path: idna/src/uts46.rs:950:29: 952:32 (#428)
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?",
)
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1718),
    call_expr_span: idna/src/uts46.rs:950:29: 952:31 (#0),
    caller: Some(
        DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process),
    ),
    caller_span: None,
    callee: DefId(1:10604 ~ core[f118]::fmt::Write::write_str),
    callee_span: idna/src/uts46.rs:950:29: 952:31 (#0),
    callee_path: "core::fmt::Write::write_str",
    constraint_depth: 1,
}
The code is Ok(
    "sink",
)
The code is Ok(
    "unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            }",
)
The code is Ok(
    "core::str::from_utf8_unchecked(slice_to_write)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1723), call_expr_span: idna/src/uts46.rs:951:33: 951:79 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:12976 ~ core[f118]::str::converts::from_utf8_unchecked), callee_span: idna/src/uts46.rs:951:33: 951:63 (#0), callee_path: "core::str::from_utf8_unchecked", constraint_depth: 1 }
The code is Ok(
    "core::str::from_utf8_unchecked",
)
The code is Ok(
    "slice_to_write",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?",
)
LangItem path: idna/src/uts46.rs:952:31: 952:32 (#429)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?",
)
The code is Ok(
    "for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }",
)
The code is Ok(
    "for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }",
)
into Match call
The code is Ok(
    "tail.iter()",
)
LangItem path: idna/src/uts46.rs:953:38: 953:49 (#431)
The code is Ok(
    "tail.iter()",
)
The code is Ok(
    "tail.iter()",
)
The code is Ok(
    "tail",
)
The code is Ok(
    "for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }",
)
The code is Ok(
    "tail.iter()",
)
into Match call
is inner Match
The code is Ok(
    "tail.iter()",
)
LangItem path: idna/src/uts46.rs:953:38: 953:49 (#431)
The code is Ok(
    "tail.iter()",
)
The code is Ok(
    "tail.iter()",
)
The code is Ok(
    "tail.iter()",
)
The code is Ok(
    "for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }",
)
The code is Ok(
    "{\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }",
)
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))?",
)
into Match call
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))?",
)
LangItem path: idna/src/uts46.rs:954:33: 954:85 (#433)
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))?",
)
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1761),
    call_expr_span: idna/src/uts46.rs:954:33: 954:84 (#0),
    caller: Some(
        DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process),
    ),
    caller_span: None,
    callee: DefId(1:10605 ~ core[f118]::fmt::Write::write_char),
    callee_span: idna/src/uts46.rs:954:33: 954:84 (#0),
    callee_path: "core::fmt::Write::write_char",
    constraint_depth: 2,
}
The code is Ok(
    "sink",
)
The code is Ok(
    "char::from(c.to_ascii_lowercase())",
)
The code is Ok(
    "char::from",
)
The code is Ok(
    "c.to_ascii_lowercase()",
)
The code is Ok(
    "c",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))?",
)
LangItem path: idna/src/uts46.rs:954:84: 954:85 (#434)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))?",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "{\n                            // SAFETY: `mixed_case` is known to be ASCII.\n                            sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                        }",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?",
)
into Match call
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?",
)
LangItem path: idna/src/uts46.rs:958:29: 958:99 (#436)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1816),
    call_expr_span: idna/src/uts46.rs:958:29: 958:98 (#0),
    caller: Some(
        DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process),
    ),
    caller_span: None,
    callee: DefId(1:10604 ~ core[f118]::fmt::Write::write_str),
    callee_span: idna/src/uts46.rs:958:29: 958:98 (#0),
    callee_path: "core::fmt::Write::write_str",
    constraint_depth: 1,
}
The code is Ok(
    "sink",
)
The code is Ok(
    "unsafe { core::str::from_utf8_unchecked(mixed_case) }",
)
The code is Ok(
    "core::str::from_utf8_unchecked(mixed_case)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1821), call_expr_span: idna/src/uts46.rs:958:53: 958:95 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:12976 ~ core[f118]::str::converts::from_utf8_unchecked), callee_span: idna/src/uts46.rs:958:53: 958:83 (#0), callee_path: "core::str::from_utf8_unchecked", constraint_depth: 1 }
The code is Ok(
    "core::str::from_utf8_unchecked",
)
The code is Ok(
    "mixed_case",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?",
)
LangItem path: idna/src/uts46.rs:958:98: 958:99 (#437)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?",
)
The code is Ok(
    "{\n                            passthrough_up_to_extended += mixed_case.len();\n                        }",
)
The code is Ok(
    "passthrough_up_to_extended += mixed_case.len()",
)
The code is Ok(
    "mixed_case.len()",
)
The code is Ok(
    "mixed_case",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "if is_ascii(label) {\n                        if !flushed_prefix {\n                            flushed_prefix = true;\n                            // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?;\n                        }\n                        for c in label.iter().copied() {\n                            sink.write_char(c)?;\n                        }\n                    } else if let AlreadyAsciiLabel::MixedCasePunycode(mixed_case) = input_punycode\n                    {\n                        if let Some(first_upper_case) =\n                            mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                        {\n                            let (head, tail) = mixed_case.split_at(first_upper_case);\n                            let slice_to_write = if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                                &domain_name[..passthrough_up_to_extended]\n                            };\n                            // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?;\n                            for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }\n                        } else if flushed_prefix {\n                            // SAFETY: `mixed_case` is known to be ASCII.\n                            sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                        } else {\n                            passthrough_up_to_extended += mixed_case.len();\n                        }\n                    } else {\n                        if !flushed_prefix {\n                            flushed_prefix = true;\n                            // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?;\n                        }\n                        write_punycode_label(label, sink)?;\n                    }",
)
The code is Ok(
    "is_ascii(label)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1866), call_expr_span: idna/src/uts46.rs:965:24: 965:39 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(0:155 ~ idna[bc6b]::uts46::is_ascii), callee_span: idna/src/uts46.rs:965:24: 965:32 (#0), callee_path: "uts46::is_ascii", constraint_depth: 1 }
The code is Ok(
    "is_ascii",
)
The code is Ok(
    "label",
)
The code is Ok(
    "if !flushed_prefix {\n                            flushed_prefix = true;\n                            // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?;\n                        }",
)
The code is Ok(
    "!flushed_prefix",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "flushed_prefix = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?",
)
into Match call
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?",
)
LangItem path: idna/src/uts46.rs:969:29: 973:32 (#440)
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?",
)
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1883),
    call_expr_span: idna/src/uts46.rs:969:29: 973:31 (#0),
    caller: Some(
        DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process),
    ),
    caller_span: None,
    callee: DefId(1:10604 ~ core[f118]::fmt::Write::write_str),
    callee_span: idna/src/uts46.rs:969:29: 973:31 (#0),
    callee_path: "core::fmt::Write::write_str",
    constraint_depth: 2,
}
The code is Ok(
    "sink",
)
The code is Ok(
    "unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            }",
)
The code is Ok(
    "core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1888), call_expr_span: idna/src/uts46.rs:970:33: 972:34 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:12976 ~ core[f118]::str::converts::from_utf8_unchecked), callee_span: idna/src/uts46.rs:970:33: 970:63 (#0), callee_path: "core::str::from_utf8_unchecked", constraint_depth: 2 }
The code is Ok(
    "core::str::from_utf8_unchecked",
)
The code is Ok(
    "&domain_name[..passthrough_up_to_extended]",
)
The code is Ok(
    "domain_name[..passthrough_up_to_extended]",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "..passthrough_up_to_extended",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?",
)
LangItem path: idna/src/uts46.rs:973:31: 973:32 (#441)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?",
)
The code is Ok(
    "for c in label.iter().copied() {\n                            sink.write_char(c)?;\n                        }",
)
The code is Ok(
    "for c in label.iter().copied() {\n                            sink.write_char(c)?;\n                        }",
)
into Match call
The code is Ok(
    "label.iter().copied()",
)
LangItem path: idna/src/uts46.rs:975:34: 975:55 (#443)
The code is Ok(
    "label.iter().copied()",
)
The code is Ok(
    "label.iter().copied()",
)
The code is Ok(
    "label.iter()",
)
The code is Ok(
    "label",
)
The code is Ok(
    "for c in label.iter().copied() {\n                            sink.write_char(c)?;\n                        }",
)
The code is Ok(
    "label.iter().copied()",
)
into Match call
is inner Match
The code is Ok(
    "label.iter().copied()",
)
LangItem path: idna/src/uts46.rs:975:34: 975:55 (#443)
The code is Ok(
    "label.iter().copied()",
)
The code is Ok(
    "label.iter().copied()",
)
The code is Ok(
    "label.iter().copied()",
)
The code is Ok(
    "for c in label.iter().copied() {\n                            sink.write_char(c)?;\n                        }",
)
The code is Ok(
    "{\n                            sink.write_char(c)?;\n                        }",
)
The code is Ok(
    "sink.write_char(c)?",
)
into Match call
The code is Ok(
    "sink.write_char(c)?",
)
LangItem path: idna/src/uts46.rs:976:29: 976:48 (#445)
The code is Ok(
    "sink.write_char(c)?",
)
The code is Ok(
    "sink.write_char(c)",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).1937),
    call_expr_span: idna/src/uts46.rs:976:29: 976:47 (#0),
    caller: Some(
        DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process),
    ),
    caller_span: None,
    callee: DefId(1:10605 ~ core[f118]::fmt::Write::write_char),
    callee_span: idna/src/uts46.rs:976:29: 976:47 (#0),
    callee_path: "core::fmt::Write::write_char",
    constraint_depth: 2,
}
The code is Ok(
    "sink",
)
The code is Ok(
    "c",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_char(c)?",
)
LangItem path: idna/src/uts46.rs:976:47: 976:48 (#446)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_char(c)?",
)
The code is Ok(
    "let AlreadyAsciiLabel::MixedCasePunycode(mixed_case) = input_punycode",
)
The code is Ok(
    "input_punycode",
)
The code is Ok(
    "{\n                        if let Some(first_upper_case) =\n                            mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                        {\n                            let (head, tail) = mixed_case.split_at(first_upper_case);\n                            let slice_to_write = if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                                &domain_name[..passthrough_up_to_extended]\n                            };\n                            // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?;\n                            for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }\n                        } else if flushed_prefix {\n                            // SAFETY: `mixed_case` is known to be ASCII.\n                            sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                        } else {\n                            passthrough_up_to_extended += mixed_case.len();\n                        }\n                    }",
)
The code is Ok(
    "if let Some(first_upper_case) =\n                            mixed_case.iter().position(|c| c.is_ascii_uppercase())\n                        {\n                            let (head, tail) = mixed_case.split_at(first_upper_case);\n                            let slice_to_write = if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                                &domain_name[..passthrough_up_to_extended]\n                            };\n                            // SAFETY: `mixed_case` and `domain_name` up to `passthrough_up_to_extended` are known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?;\n                            for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }\n                        } else if flushed_prefix {\n                            // SAFETY: `mixed_case` is known to be ASCII.\n                            sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                        } else {\n                            passthrough_up_to_extended += mixed_case.len();\n                        }",
)
The code is Ok(
    "mixed_case.iter().position(|c| c.is_ascii_uppercase())",
)
The code is Ok(
    "mixed_case.iter()",
)
The code is Ok(
    "mixed_case",
)
The code is Ok(
    "|c| c.is_ascii_uppercase()",
)
The code is Ok(
    "c.is_ascii_uppercase()",
)
The code is Ok(
    "c",
)
The code is Ok(
    "mixed_case.split_at(first_upper_case)",
)
The code is Ok(
    "mixed_case",
)
The code is Ok(
    "first_upper_case",
)
The code is Ok(
    "if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                                &domain_name[..passthrough_up_to_extended]\n                            }",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "head",
)
The code is Ok(
    "flushed_prefix = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "passthrough_up_to_extended += head.len()",
)
The code is Ok(
    "head.len()",
)
The code is Ok(
    "head",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "if $crate::cfg!(debug_assertions) {\n            $crate::assert_ne!($($arg)*);\n        }",
)
The code is Ok(
    "$crate::cfg!(debug_assertions)",
)
The code is Ok(
    "match (&$left, &$right) {\n            (left_val, right_val) => {\n                if *left_val == *right_val {\n                    let kind = $crate::panicking::AssertKind::Ne;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }\n            }\n        }",
)
The code is Ok(
    "(&$left, &$right)",
)
The code is Ok(
    "&$left",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "&$right",
)
The code is Ok(
    "domain_name.len()",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "{\n                if *left_val == *right_val {\n                    let kind = $crate::panicking::AssertKind::Ne;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }\n            }",
)
The code is Ok(
    "if *left_val == *right_val {\n                    let kind = $crate::panicking::AssertKind::Ne;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }",
)
The code is Ok(
    "*left_val == *right_val",
)
The code is Ok(
    "*left_val",
)
The code is Ok(
    "left_val",
)
The code is Ok(
    "*right_val",
)
The code is Ok(
    "right_val",
)
The code is Ok(
    "$crate::panicking::AssertKind::Ne",
)
The code is Ok(
    "$crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).2076), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:107:21: 107:114 (#146), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:9590 ~ core[f118]::panicking::assert_failed), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:107:21: 107:53 (#146), callee_path: "core::panicking::assert_failed", constraint_depth: 3 }
The code is Ok(
    "$crate::panicking::assert_failed",
)
The code is Ok(
    "kind",
)
The code is Ok(
    "&*left_val",
)
The code is Ok(
    "*left_val",
)
The code is Ok(
    "left_val",
)
The code is Ok(
    "&*right_val",
)
The code is Ok(
    "*right_val",
)
The code is Ok(
    "right_val",
)
The code is Ok(
    "$crate::option::Option::None",
)
The code is Ok(
    "&domain_name[..passthrough_up_to_extended]",
)
The code is Ok(
    "domain_name[..passthrough_up_to_extended]",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "..passthrough_up_to_extended",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?",
)
into Match call
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?",
)
LangItem path: idna/src/uts46.rs:993:29: 995:32 (#452)
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?",
)
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).2116),
    call_expr_span: idna/src/uts46.rs:993:29: 995:31 (#0),
    caller: Some(
        DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process),
    ),
    caller_span: None,
    callee: DefId(1:10604 ~ core[f118]::fmt::Write::write_str),
    callee_span: idna/src/uts46.rs:993:29: 995:31 (#0),
    callee_path: "core::fmt::Write::write_str",
    constraint_depth: 1,
}
The code is Ok(
    "sink",
)
The code is Ok(
    "unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            }",
)
The code is Ok(
    "core::str::from_utf8_unchecked(slice_to_write)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).2121), call_expr_span: idna/src/uts46.rs:994:33: 994:79 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:12976 ~ core[f118]::str::converts::from_utf8_unchecked), callee_span: idna/src/uts46.rs:994:33: 994:63 (#0), callee_path: "core::str::from_utf8_unchecked", constraint_depth: 1 }
The code is Ok(
    "core::str::from_utf8_unchecked",
)
The code is Ok(
    "slice_to_write",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?",
)
LangItem path: idna/src/uts46.rs:995:31: 995:32 (#453)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?",
)
The code is Ok(
    "for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }",
)
The code is Ok(
    "for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }",
)
into Match call
The code is Ok(
    "tail.iter()",
)
LangItem path: idna/src/uts46.rs:996:38: 996:49 (#455)
The code is Ok(
    "tail.iter()",
)
The code is Ok(
    "tail.iter()",
)
The code is Ok(
    "tail",
)
The code is Ok(
    "for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }",
)
The code is Ok(
    "tail.iter()",
)
into Match call
is inner Match
The code is Ok(
    "tail.iter()",
)
LangItem path: idna/src/uts46.rs:996:38: 996:49 (#455)
The code is Ok(
    "tail.iter()",
)
The code is Ok(
    "tail.iter()",
)
The code is Ok(
    "tail.iter()",
)
The code is Ok(
    "for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }",
)
The code is Ok(
    "{\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }",
)
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))?",
)
into Match call
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))?",
)
LangItem path: idna/src/uts46.rs:997:33: 997:85 (#457)
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))?",
)
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).2159),
    call_expr_span: idna/src/uts46.rs:997:33: 997:84 (#0),
    caller: Some(
        DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process),
    ),
    caller_span: None,
    callee: DefId(1:10605 ~ core[f118]::fmt::Write::write_char),
    callee_span: idna/src/uts46.rs:997:33: 997:84 (#0),
    callee_path: "core::fmt::Write::write_char",
    constraint_depth: 2,
}
The code is Ok(
    "sink",
)
The code is Ok(
    "char::from(c.to_ascii_lowercase())",
)
The code is Ok(
    "char::from",
)
The code is Ok(
    "c.to_ascii_lowercase()",
)
The code is Ok(
    "c",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))?",
)
LangItem path: idna/src/uts46.rs:997:84: 997:85 (#458)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_char(char::from(c.to_ascii_lowercase()))?",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "{\n                            // SAFETY: `mixed_case` is known to be ASCII.\n                            sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?;\n                        }",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?",
)
into Match call
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?",
)
LangItem path: idna/src/uts46.rs:1001:29: 1001:99 (#460)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).2214),
    call_expr_span: idna/src/uts46.rs:1001:29: 1001:98 (#0),
    caller: Some(
        DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process),
    ),
    caller_span: None,
    callee: DefId(1:10604 ~ core[f118]::fmt::Write::write_str),
    callee_span: idna/src/uts46.rs:1001:29: 1001:98 (#0),
    callee_path: "core::fmt::Write::write_str",
    constraint_depth: 1,
}
The code is Ok(
    "sink",
)
The code is Ok(
    "unsafe { core::str::from_utf8_unchecked(mixed_case) }",
)
The code is Ok(
    "core::str::from_utf8_unchecked(mixed_case)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).2219), call_expr_span: idna/src/uts46.rs:1001:53: 1001:95 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:12976 ~ core[f118]::str::converts::from_utf8_unchecked), callee_span: idna/src/uts46.rs:1001:53: 1001:83 (#0), callee_path: "core::str::from_utf8_unchecked", constraint_depth: 1 }
The code is Ok(
    "core::str::from_utf8_unchecked",
)
The code is Ok(
    "mixed_case",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?",
)
LangItem path: idna/src/uts46.rs:1001:98: 1001:99 (#461)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe { core::str::from_utf8_unchecked(mixed_case) })?",
)
The code is Ok(
    "{\n                            passthrough_up_to_extended += mixed_case.len();\n                        }",
)
The code is Ok(
    "passthrough_up_to_extended += mixed_case.len()",
)
The code is Ok(
    "mixed_case.len()",
)
The code is Ok(
    "mixed_case",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "{\n                        if !flushed_prefix {\n                            flushed_prefix = true;\n                            // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?;\n                        }\n                        write_punycode_label(label, sink)?;\n                    }",
)
The code is Ok(
    "if !flushed_prefix {\n                            flushed_prefix = true;\n                            // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?;\n                        }",
)
The code is Ok(
    "!flushed_prefix",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "flushed_prefix = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?",
)
into Match call
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?",
)
LangItem path: idna/src/uts46.rs:1009:29: 1013:32 (#463)
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?",
)
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).2271),
    call_expr_span: idna/src/uts46.rs:1009:29: 1013:31 (#0),
    caller: Some(
        DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process),
    ),
    caller_span: None,
    callee: DefId(1:10604 ~ core[f118]::fmt::Write::write_str),
    callee_span: idna/src/uts46.rs:1009:29: 1013:31 (#0),
    callee_path: "core::fmt::Write::write_str",
    constraint_depth: 2,
}
The code is Ok(
    "sink",
)
The code is Ok(
    "unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            }",
)
The code is Ok(
    "core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).2276), call_expr_span: idna/src/uts46.rs:1010:33: 1012:34 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:12976 ~ core[f118]::str::converts::from_utf8_unchecked), callee_span: idna/src/uts46.rs:1010:33: 1010:63 (#0), callee_path: "core::str::from_utf8_unchecked", constraint_depth: 2 }
The code is Ok(
    "core::str::from_utf8_unchecked",
)
The code is Ok(
    "&domain_name[..passthrough_up_to_extended]",
)
The code is Ok(
    "domain_name[..passthrough_up_to_extended]",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "..passthrough_up_to_extended",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?",
)
LangItem path: idna/src/uts46.rs:1013:31: 1013:32 (#464)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?",
)
The code is Ok(
    "write_punycode_label(label, sink)?",
)
into Match call
The code is Ok(
    "write_punycode_label(label, sink)?",
)
LangItem path: idna/src/uts46.rs:1015:25: 1015:59 (#465)
The code is Ok(
    "write_punycode_label(label, sink)?",
)
The code is Ok(
    "write_punycode_label(label, sink)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).2312), call_expr_span: idna/src/uts46.rs:1015:25: 1015:58 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(0:145 ~ idna[bc6b]::uts46::write_punycode_label), callee_span: idna/src/uts46.rs:1015:25: 1015:45 (#0), callee_path: "uts46::write_punycode_label", constraint_depth: 1 }
The code is Ok(
    "write_punycode_label",
)
The code is Ok(
    "label",
)
The code is Ok(
    "sink",
)
The code is Ok(
    "?",
)
The code is Ok(
    "write_punycode_label(label, sink)?",
)
LangItem path: idna/src/uts46.rs:1015:58: 1015:59 (#466)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "write_punycode_label(label, sink)?",
)
The code is Ok(
    "if !flushed_prefix {\n                    // SAFETY: `domain_name` up to `passthrough_up_to_extended` is known to be ASCII.\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?;\n                }",
)
The code is Ok(
    "!flushed_prefix",
)
The code is Ok(
    "flushed_prefix",
)
The code is Ok(
    "sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?",
)
into Match call
The code is Ok(
    "sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?",
)
LangItem path: idna/src/uts46.rs:1020:21: 1022:24 (#468)
The code is Ok(
    "sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?",
)
The code is Ok(
    "sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).2362),
    call_expr_span: idna/src/uts46.rs:1020:21: 1022:23 (#0),
    caller: Some(
        DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process),
    ),
    caller_span: None,
    callee: DefId(1:10604 ~ core[f118]::fmt::Write::write_str),
    callee_span: idna/src/uts46.rs:1020:21: 1022:23 (#0),
    callee_path: "core::fmt::Write::write_str",
    constraint_depth: 1,
}
The code is Ok(
    "sink",
)
The code is Ok(
    "unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    }",
)
The code is Ok(
    "core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).2367), call_expr_span: idna/src/uts46.rs:1021:25: 1021:99 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:12976 ~ core[f118]::str::converts::from_utf8_unchecked), callee_span: idna/src/uts46.rs:1021:25: 1021:55 (#0), callee_path: "core::str::from_utf8_unchecked", constraint_depth: 1 }
The code is Ok(
    "core::str::from_utf8_unchecked",
)
The code is Ok(
    "&domain_name[..passthrough_up_to_extended]",
)
The code is Ok(
    "domain_name[..passthrough_up_to_extended]",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "..passthrough_up_to_extended",
)
The code is Ok(
    "passthrough_up_to_extended",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?",
)
LangItem path: idna/src/uts46.rs:1022:23: 1022:24 (#469)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(&domain_name[..passthrough_up_to_extended])\n                    })?",
)
The code is Ok(
    "Ok(ProcessingSuccess::WroteToSink)",
)
resolved new call Call { call_expr: HirId(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process).2406), call_expr_span: idna/src/uts46.rs:1026:9: 1026:43 (#0), caller: Some(DefId(0:183 ~ idna[bc6b]::uts46::{impl#4}::process)), caller_span: None, callee: DefId(1:45569 ~ core[f118]::result::Result::Ok::{constructor#0}), callee_span: idna/src/uts46.rs:1026:9: 1026:11 (#0), callee_path: "core::prelude::v1::Ok", constraint_depth: 0 }
The code is Ok(
    "Ok",
)
The code is Ok(
    "ProcessingSuccess::WroteToSink",
)
The code is Ok(
    "253",
)
The code is Ok(
    "8",
)
The code is Ok(
    "{\n        // Sadly, this even faster-path ASCII tier is needed to avoid regressing\n        // performance.\n        let mut iter = domain_name.iter();\n        let mut most_recent_label_start = iter.clone();\n        loop {\n            if let Some(&b) = iter.next() {\n                if in_inclusive_range8(b, b'a', b'z') {\n                    continue;\n                }\n                if b == b'.' {\n                    most_recent_label_start = iter.clone();\n                    continue;\n                }\n                return self.process_innermost(\n                    domain_name,\n                    ascii_deny_list,\n                    hyphens,\n                    fail_fast,\n                    domain_buffer,\n                    already_punycode,\n                    most_recent_label_start.as_slice(),\n                );\n            } else {\n                // Success! The whole input passes through on the fastest path!\n                return (domain_name.len(), false, false);\n            }\n        }\n    }",
)
The code is Ok(
    "domain_name.iter()",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "iter.clone()",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "loop {\n            if let Some(&b) = iter.next() {\n                if in_inclusive_range8(b, b'a', b'z') {\n                    continue;\n                }\n                if b == b'.' {\n                    most_recent_label_start = iter.clone();\n                    continue;\n                }\n                return self.process_innermost(\n                    domain_name,\n                    ascii_deny_list,\n                    hyphens,\n                    fail_fast,\n                    domain_buffer,\n                    already_punycode,\n                    most_recent_label_start.as_slice(),\n                );\n            } else {\n                // Success! The whole input passes through on the fastest path!\n                return (domain_name.len(), false, false);\n            }\n        }",
)
The code is Ok(
    "if let Some(&b) = iter.next() {\n                if in_inclusive_range8(b, b'a', b'z') {\n                    continue;\n                }\n                if b == b'.' {\n                    most_recent_label_start = iter.clone();\n                    continue;\n                }\n                return self.process_innermost(\n                    domain_name,\n                    ascii_deny_list,\n                    hyphens,\n                    fail_fast,\n                    domain_buffer,\n                    already_punycode,\n                    most_recent_label_start.as_slice(),\n                );\n            } else {\n                // Success! The whole input passes through on the fastest path!\n                return (domain_name.len(), false, false);\n            }",
)
The code is Ok(
    "iter.next()",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "if in_inclusive_range8(b, b'a', b'z') {\n                    continue;\n                }",
)
The code is Ok(
    "in_inclusive_range8(b, b'a', b'z')",
)
resolved new call Call { call_expr: HirId(DefId(0:195 ~ idna[bc6b]::uts46::{impl#4}::process_inner).41), call_expr_span: idna/src/uts46.rs:1046:20: 1046:54 (#0), caller: Some(DefId(0:195 ~ idna[bc6b]::uts46::{impl#4}::process_inner)), caller_span: None, callee: DefId(0:148 ~ idna[bc6b]::uts46::in_inclusive_range8), callee_span: idna/src/uts46.rs:1046:20: 1046:39 (#0), callee_path: "uts46::in_inclusive_range8", constraint_depth: 1 }
The code is Ok(
    "in_inclusive_range8",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'a'",
)
The code is Ok(
    "b'z'",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "if b == b'.' {\n                    most_recent_label_start = iter.clone();\n                    continue;\n                }",
)
The code is Ok(
    "b == b'.'",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'.'",
)
The code is Ok(
    "most_recent_label_start = iter.clone()",
)
The code is Ok(
    "iter.clone()",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "most_recent_label_start",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "return self.process_innermost(\n                    domain_name,\n                    ascii_deny_list,\n                    hyphens,\n                    fail_fast,\n                    domain_buffer,\n                    already_punycode,\n                    most_recent_label_start.as_slice(),\n                )",
)
The code is Ok(
    "self.process_innermost(\n                    domain_name,\n                    ascii_deny_list,\n                    hyphens,\n                    fail_fast,\n                    domain_buffer,\n                    already_punycode,\n                    most_recent_label_start.as_slice(),\n                )",
)
The code is Ok(
    "self",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "ascii_deny_list",
)
The code is Ok(
    "hyphens",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "already_punycode",
)
The code is Ok(
    "most_recent_label_start.as_slice()",
)
The code is Ok(
    "most_recent_label_start",
)
The code is Ok(
    "return (domain_name.len(), false, false)",
)
The code is Ok(
    "(domain_name.len(), false, false)",
)
The code is Ok(
    "domain_name.len()",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "253",
)
The code is Ok(
    "8",
)
The code is Ok(
    "{\n        let deny_list = ascii_deny_list.bits;\n        let deny_list_deny_dot = deny_list | DOT_MASK;\n\n        let mut had_errors = false;\n\n        let mut passthrough_up_to = domain_name.len() - tail.len(); // Index into `domain_name`\n                                                                    // 253 ASCII characters is the max length for a valid domain name\n                                                                    // (excluding the root dot).\n        let mut current_label_start; // Index into `domain_buffer`\n        let mut seen_label = false;\n        let mut in_prefix = true;\n        for label in tail.split(|b| *b == b'.') {\n            // We check for passthrough only for the prefix. That is, if we\n            // haven't moved on and started filling `domain_buffer`. Keeping\n            // this stuff in one loop where the first items keep being skipped\n            // once they have been skipped at least once instead of working\n            // this into a fancier loop structure in order to make sure that\n            // no item from the iterator is lost or processed twice.\n            // Furthermore, after the passthrough fails, restarting the\n            // normalization process after each pre-existing ASCII dot also\n            // provides an opportunity for the processing to get back onto\n            // an ASCII fast path that bypasses the normalizer for ASCII\n            // after a pre-existing ASCII dot (pre-existing in the sense\n            // of not coming from e.g. normalizing an ideographic dot).\n            if in_prefix && is_passthrough_ascii_label(label) {\n                if seen_label {\n                    debug_assert_eq!(domain_name[passthrough_up_to], b'.');\n                    passthrough_up_to += 1;\n                }\n                seen_label = true;\n\n                passthrough_up_to += label.len();\n                continue;\n            }\n            if seen_label {\n                if in_prefix {\n                    debug_assert_eq!(domain_name[passthrough_up_to], b'.');\n                    passthrough_up_to += 1;\n                } else {\n                    domain_buffer.push('.');\n                }\n            }\n            seen_label = true;\n            in_prefix = false;\n            current_label_start = domain_buffer.len();\n            if !label.is_empty() {\n                let (ascii, non_ascii) = split_ascii_fast_path_prefix(label);\n                let non_punycode_ascii_label = if non_ascii.is_empty() {\n                    if has_punycode_prefix(ascii) {\n                        if (ascii.last() != Some(&b'-'))\n                            && (ascii.len() - 4 <= PUNYCODE_DECODE_MAX_INPUT_LENGTH)\n                        {\n                            if let Ok(decode) =\n                                Decoder::default().decode::<u8, InternalCaller>(&ascii[4..])\n                            {\n                                // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                // characters.\n                                let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                label_buffer.extend(decode);\n\n                                if self.after_punycode_decode(\n                                    domain_buffer,\n                                    current_label_start,\n                                    &label_buffer,\n                                    deny_list_deny_dot,\n                                    fail_fast,\n                                    &mut had_errors,\n                                ) {\n                                    return (0, false, true);\n                                }\n\n                                if self.check_label(\n                                    hyphens,\n                                    &mut domain_buffer[current_label_start..],\n                                    fail_fast,\n                                    &mut had_errors,\n                                    true,\n                                    true,\n                                ) {\n                                    return (0, false, true);\n                                }\n                            } else {\n                                // Punycode failed\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                domain_buffer.push('\\u{FFFD}');\n                                let mut iter = ascii.iter();\n                                // Discard the first character that we replaced.\n                                let _ = iter.next();\n                                domain_buffer.extend(iter.map(|c| {\n                                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                                    // not matter.\n                                    apply_ascii_deny_list_to_potentially_upper_case_ascii(\n                                        *c, deny_list,\n                                    )\n                                }));\n                            };\n                            // If there were errors, we won't be trying to use this\n                            // anyway later, so it's fine to put it here unconditionally.\n                            already_punycode.push(AlreadyAsciiLabel::MixedCasePunycode(label));\n                            continue;\n                        } else if fail_fast {\n                            return (0, false, true);\n                        }\n                        // Else fall through to the complex path and rediscover error\n                        // there.\n                        false\n                    } else {\n                        true\n                    }\n                } else {\n                    false\n                };\n                for c in ascii.iter().map(|c| {\n                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                    // not matter.\n                    apply_ascii_deny_list_to_potentially_upper_case_ascii(*c, deny_list)\n                }) {\n                    if c == '\\u{FFFD}' {\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                    }\n                    domain_buffer.push(c);\n                }\n                if non_punycode_ascii_label {\n                    if hyphens != Hyphens::Allow\n                        && check_hyphens(\n                            &mut domain_buffer[current_label_start..],\n                            hyphens == Hyphens::CheckFirstLast,\n                            fail_fast,\n                            &mut had_errors,\n                        )\n                    {\n                        return (0, false, true);\n                    }\n                    already_punycode.push(if had_errors {\n                        AlreadyAsciiLabel::Other\n                    } else {\n                        AlreadyAsciiLabel::MixedCaseAscii(label)\n                    });\n                    continue;\n                }\n                already_punycode.push(AlreadyAsciiLabel::Other);\n                let mut first_needs_combining_mark_check = ascii.is_empty();\n                let mut needs_contextj_check = !non_ascii.is_empty();\n                let mut mapping = self\n                    .data\n                    .map_normalize(non_ascii.chars())\n                    .map(|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list));\n                loop {\n                    let n = mapping.next();\n                    match n {\n                        None | Some('.') => {\n                            if domain_buffer[current_label_start..]\n                                .starts_with(&['x', 'n', '-', '-'])\n                            {\n                                let mut punycode_precondition_failed = false;\n                                for c in domain_buffer[current_label_start + 4..].iter_mut() {\n                                    if !c.is_ascii() {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                }\n\n                                if let Some(last) = domain_buffer.last_mut() {\n                                    if *last == '-' {\n                                        // Either there's nothing after the \"xn--\" prefix\n                                        // and we got the last hyphen of \"xn--\", or there\n                                        // are no Punycode digits after the last delimiter\n                                        // which would result in Punycode decode outputting\n                                        // ASCII only.\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *last = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                } else {\n                                    unreachable!();\n                                }\n\n                                // Reject excessively long input\n                                // https://github.com/whatwg/url/issues/824\n                                // https://unicode-org.atlassian.net/browse/ICU-13727\n                                if domain_buffer.len() - current_label_start - 4\n                                    > PUNYCODE_DECODE_MAX_INPUT_LENGTH\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    domain_buffer[current_label_start\n                                        + 4\n                                        + PUNYCODE_DECODE_MAX_INPUT_LENGTH] = '\\u{FFFD}';\n                                    punycode_precondition_failed = true;\n                                }\n\n                                if !punycode_precondition_failed {\n                                    if let Ok(decode) = Decoder::default()\n                                        .decode::<char, InternalCaller>(\n                                            &domain_buffer[current_label_start + 4..],\n                                        )\n                                    {\n                                        first_needs_combining_mark_check = true;\n                                        needs_contextj_check = true;\n                                        // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                        // characters.\n                                        let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                        label_buffer.extend(decode);\n\n                                        domain_buffer.truncate(current_label_start);\n                                        if self.after_punycode_decode(\n                                            domain_buffer,\n                                            current_label_start,\n                                            &label_buffer,\n                                            deny_list_deny_dot,\n                                            fail_fast,\n                                            &mut had_errors,\n                                        ) {\n                                            return (0, false, true);\n                                        }\n                                    } else {\n                                        // Punycode failed\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        domain_buffer[current_label_start] = '\\u{FFFD}';\n                                        needs_contextj_check = false; // ASCII label\n                                        first_needs_combining_mark_check = false;\n                                    };\n                                } else {\n                                    first_needs_combining_mark_check = false;\n                                    needs_contextj_check = false; // Non-ASCII already turned to U+FFFD.\n                                }\n                            }\n                            if self.check_label(\n                                hyphens,\n                                &mut domain_buffer[current_label_start..],\n                                fail_fast,\n                                &mut had_errors,\n                                first_needs_combining_mark_check,\n                                needs_contextj_check,\n                            ) {\n                                return (0, false, true);\n                            }\n\n                            if n.is_none() {\n                                break;\n                            }\n                            domain_buffer.push('.');\n                            current_label_start = domain_buffer.len();\n                            first_needs_combining_mark_check = true;\n                            needs_contextj_check = true;\n                            already_punycode.push(AlreadyAsciiLabel::Other);\n                        }\n                        Some(c) => {\n                            if c == '\\u{FFFD}' {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                            }\n                            domain_buffer.push(c);\n                        }\n                    }\n                }\n            } else {\n                // Empty label\n                already_punycode.push(AlreadyAsciiLabel::MixedCaseAscii(label));\n            }\n        }\n\n        let is_bidi = self.is_bidi(domain_buffer);\n        if is_bidi {\n            for label in domain_buffer.split_mut(|c| *c == '.') {\n                if let Some((first, tail)) = label.split_first_mut() {\n                    let first_bc = self.data.bidi_class(*first);\n                    if !FIRST_BC_MASK.intersects(first_bc.to_mask()) {\n                        // Neither RTL label nor LTR label\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                        *first = '\\u{FFFD}';\n                        continue;\n                    }\n                    let is_ltr = first_bc.is_ltr();\n                    // Trim NSM\n                    let mut middle = tail;\n                    #[allow(clippy::while_let_loop)]\n                    loop {\n                        if let Some((last, prior)) = middle.split_last_mut() {\n                            let last_bc = self.data.bidi_class(*last);\n                            if last_bc.is_nonspacing_mark() {\n                                middle = prior;\n                                continue;\n                            }\n                            let last_mask = if is_ltr { LAST_LTR_MASK } else { LAST_RTL_MASK };\n                            if !last_mask.intersects(last_bc.to_mask()) {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                *last = '\\u{FFFD}';\n                            }\n                            if is_ltr {\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_LTR_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    }\n                                }\n                            } else {\n                                let mut numeral_state = RtlNumeralState::Undecided;\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_RTL_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    } else {\n                                        match numeral_state {\n                                            RtlNumeralState::Undecided => {\n                                                if bc.is_european_number() {\n                                                    numeral_state = RtlNumeralState::European;\n                                                } else if bc.is_arabic_number() {\n                                                    numeral_state = RtlNumeralState::Arabic;\n                                                }\n                                            }\n                                            RtlNumeralState::European => {\n                                                if bc.is_arabic_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                            RtlNumeralState::Arabic => {\n                                                if bc.is_european_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                                if (numeral_state == RtlNumeralState::European\n                                    && last_bc.is_arabic_number())\n                                    || (numeral_state == RtlNumeralState::Arabic\n                                        && last_bc.is_european_number())\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    *last = '\\u{FFFD}';\n                                }\n                            }\n                            break;\n                        } else {\n                            // One-character label or label where\n                            // everything after the first character\n                            // is just non-spacing marks.\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        (passthrough_up_to, is_bidi, had_errors)\n    }",
)
The code is Ok(
    "ascii_deny_list.bits",
)
The code is Ok(
    "ascii_deny_list",
)
The code is Ok(
    "deny_list | DOT_MASK",
)
The code is Ok(
    "deny_list",
)
The code is Ok(
    "DOT_MASK",
)
The code is Ok(
    "false",
)
The code is Ok(
    "domain_name.len() - tail.len()",
)
The code is Ok(
    "domain_name.len()",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "tail.len()",
)
The code is Ok(
    "tail",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "for label in tail.split(|b| *b == b'.') {\n            // We check for passthrough only for the prefix. That is, if we\n            // haven't moved on and started filling `domain_buffer`. Keeping\n            // this stuff in one loop where the first items keep being skipped\n            // once they have been skipped at least once instead of working\n            // this into a fancier loop structure in order to make sure that\n            // no item from the iterator is lost or processed twice.\n            // Furthermore, after the passthrough fails, restarting the\n            // normalization process after each pre-existing ASCII dot also\n            // provides an opportunity for the processing to get back onto\n            // an ASCII fast path that bypasses the normalizer for ASCII\n            // after a pre-existing ASCII dot (pre-existing in the sense\n            // of not coming from e.g. normalizing an ideographic dot).\n            if in_prefix && is_passthrough_ascii_label(label) {\n                if seen_label {\n                    debug_assert_eq!(domain_name[passthrough_up_to], b'.');\n                    passthrough_up_to += 1;\n                }\n                seen_label = true;\n\n                passthrough_up_to += label.len();\n                continue;\n            }\n            if seen_label {\n                if in_prefix {\n                    debug_assert_eq!(domain_name[passthrough_up_to], b'.');\n                    passthrough_up_to += 1;\n                } else {\n                    domain_buffer.push('.');\n                }\n            }\n            seen_label = true;\n            in_prefix = false;\n            current_label_start = domain_buffer.len();\n            if !label.is_empty() {\n                let (ascii, non_ascii) = split_ascii_fast_path_prefix(label);\n                let non_punycode_ascii_label = if non_ascii.is_empty() {\n                    if has_punycode_prefix(ascii) {\n                        if (ascii.last() != Some(&b'-'))\n                            && (ascii.len() - 4 <= PUNYCODE_DECODE_MAX_INPUT_LENGTH)\n                        {\n                            if let Ok(decode) =\n                                Decoder::default().decode::<u8, InternalCaller>(&ascii[4..])\n                            {\n                                // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                // characters.\n                                let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                label_buffer.extend(decode);\n\n                                if self.after_punycode_decode(\n                                    domain_buffer,\n                                    current_label_start,\n                                    &label_buffer,\n                                    deny_list_deny_dot,\n                                    fail_fast,\n                                    &mut had_errors,\n                                ) {\n                                    return (0, false, true);\n                                }\n\n                                if self.check_label(\n                                    hyphens,\n                                    &mut domain_buffer[current_label_start..],\n                                    fail_fast,\n                                    &mut had_errors,\n                                    true,\n                                    true,\n                                ) {\n                                    return (0, false, true);\n                                }\n                            } else {\n                                // Punycode failed\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                domain_buffer.push('\\u{FFFD}');\n                                let mut iter = ascii.iter();\n                                // Discard the first character that we replaced.\n                                let _ = iter.next();\n                                domain_buffer.extend(iter.map(|c| {\n                                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                                    // not matter.\n                                    apply_ascii_deny_list_to_potentially_upper_case_ascii(\n                                        *c, deny_list,\n                                    )\n                                }));\n                            };\n                            // If there were errors, we won't be trying to use this\n                            // anyway later, so it's fine to put it here unconditionally.\n                            already_punycode.push(AlreadyAsciiLabel::MixedCasePunycode(label));\n                            continue;\n                        } else if fail_fast {\n                            return (0, false, true);\n                        }\n                        // Else fall through to the complex path and rediscover error\n                        // there.\n                        false\n                    } else {\n                        true\n                    }\n                } else {\n                    false\n                };\n                for c in ascii.iter().map(|c| {\n                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                    // not matter.\n                    apply_ascii_deny_list_to_potentially_upper_case_ascii(*c, deny_list)\n                }) {\n                    if c == '\\u{FFFD}' {\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                    }\n                    domain_buffer.push(c);\n                }\n                if non_punycode_ascii_label {\n                    if hyphens != Hyphens::Allow\n                        && check_hyphens(\n                            &mut domain_buffer[current_label_start..],\n                            hyphens == Hyphens::CheckFirstLast,\n                            fail_fast,\n                            &mut had_errors,\n                        )\n                    {\n                        return (0, false, true);\n                    }\n                    already_punycode.push(if had_errors {\n                        AlreadyAsciiLabel::Other\n                    } else {\n                        AlreadyAsciiLabel::MixedCaseAscii(label)\n                    });\n                    continue;\n                }\n                already_punycode.push(AlreadyAsciiLabel::Other);\n                let mut first_needs_combining_mark_check = ascii.is_empty();\n                let mut needs_contextj_check = !non_ascii.is_empty();\n                let mut mapping = self\n                    .data\n                    .map_normalize(non_ascii.chars())\n                    .map(|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list));\n                loop {\n                    let n = mapping.next();\n                    match n {\n                        None | Some('.') => {\n                            if domain_buffer[current_label_start..]\n                                .starts_with(&['x', 'n', '-', '-'])\n                            {\n                                let mut punycode_precondition_failed = false;\n                                for c in domain_buffer[current_label_start + 4..].iter_mut() {\n                                    if !c.is_ascii() {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                }\n\n                                if let Some(last) = domain_buffer.last_mut() {\n                                    if *last == '-' {\n                                        // Either there's nothing after the \"xn--\" prefix\n                                        // and we got the last hyphen of \"xn--\", or there\n                                        // are no Punycode digits after the last delimiter\n                                        // which would result in Punycode decode outputting\n                                        // ASCII only.\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *last = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                } else {\n                                    unreachable!();\n                                }\n\n                                // Reject excessively long input\n                                // https://github.com/whatwg/url/issues/824\n                                // https://unicode-org.atlassian.net/browse/ICU-13727\n                                if domain_buffer.len() - current_label_start - 4\n                                    > PUNYCODE_DECODE_MAX_INPUT_LENGTH\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    domain_buffer[current_label_start\n                                        + 4\n                                        + PUNYCODE_DECODE_MAX_INPUT_LENGTH] = '\\u{FFFD}';\n                                    punycode_precondition_failed = true;\n                                }\n\n                                if !punycode_precondition_failed {\n                                    if let Ok(decode) = Decoder::default()\n                                        .decode::<char, InternalCaller>(\n                                            &domain_buffer[current_label_start + 4..],\n                                        )\n                                    {\n                                        first_needs_combining_mark_check = true;\n                                        needs_contextj_check = true;\n                                        // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                        // characters.\n                                        let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                        label_buffer.extend(decode);\n\n                                        domain_buffer.truncate(current_label_start);\n                                        if self.after_punycode_decode(\n                                            domain_buffer,\n                                            current_label_start,\n                                            &label_buffer,\n                                            deny_list_deny_dot,\n                                            fail_fast,\n                                            &mut had_errors,\n                                        ) {\n                                            return (0, false, true);\n                                        }\n                                    } else {\n                                        // Punycode failed\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        domain_buffer[current_label_start] = '\\u{FFFD}';\n                                        needs_contextj_check = false; // ASCII label\n                                        first_needs_combining_mark_check = false;\n                                    };\n                                } else {\n                                    first_needs_combining_mark_check = false;\n                                    needs_contextj_check = false; // Non-ASCII already turned to U+FFFD.\n                                }\n                            }\n                            if self.check_label(\n                                hyphens,\n                                &mut domain_buffer[current_label_start..],\n                                fail_fast,\n                                &mut had_errors,\n                                first_needs_combining_mark_check,\n                                needs_contextj_check,\n                            ) {\n                                return (0, false, true);\n                            }\n\n                            if n.is_none() {\n                                break;\n                            }\n                            domain_buffer.push('.');\n                            current_label_start = domain_buffer.len();\n                            first_needs_combining_mark_check = true;\n                            needs_contextj_check = true;\n                            already_punycode.push(AlreadyAsciiLabel::Other);\n                        }\n                        Some(c) => {\n                            if c == '\\u{FFFD}' {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                            }\n                            domain_buffer.push(c);\n                        }\n                    }\n                }\n            } else {\n                // Empty label\n                already_punycode.push(AlreadyAsciiLabel::MixedCaseAscii(label));\n            }\n        }",
)
The code is Ok(
    "for label in tail.split(|b| *b == b'.') {\n            // We check for passthrough only for the prefix. That is, if we\n            // haven't moved on and started filling `domain_buffer`. Keeping\n            // this stuff in one loop where the first items keep being skipped\n            // once they have been skipped at least once instead of working\n            // this into a fancier loop structure in order to make sure that\n            // no item from the iterator is lost or processed twice.\n            // Furthermore, after the passthrough fails, restarting the\n            // normalization process after each pre-existing ASCII dot also\n            // provides an opportunity for the processing to get back onto\n            // an ASCII fast path that bypasses the normalizer for ASCII\n            // after a pre-existing ASCII dot (pre-existing in the sense\n            // of not coming from e.g. normalizing an ideographic dot).\n            if in_prefix && is_passthrough_ascii_label(label) {\n                if seen_label {\n                    debug_assert_eq!(domain_name[passthrough_up_to], b'.');\n                    passthrough_up_to += 1;\n                }\n                seen_label = true;\n\n                passthrough_up_to += label.len();\n                continue;\n            }\n            if seen_label {\n                if in_prefix {\n                    debug_assert_eq!(domain_name[passthrough_up_to], b'.');\n                    passthrough_up_to += 1;\n                } else {\n                    domain_buffer.push('.');\n                }\n            }\n            seen_label = true;\n            in_prefix = false;\n            current_label_start = domain_buffer.len();\n            if !label.is_empty() {\n                let (ascii, non_ascii) = split_ascii_fast_path_prefix(label);\n                let non_punycode_ascii_label = if non_ascii.is_empty() {\n                    if has_punycode_prefix(ascii) {\n                        if (ascii.last() != Some(&b'-'))\n                            && (ascii.len() - 4 <= PUNYCODE_DECODE_MAX_INPUT_LENGTH)\n                        {\n                            if let Ok(decode) =\n                                Decoder::default().decode::<u8, InternalCaller>(&ascii[4..])\n                            {\n                                // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                // characters.\n                                let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                label_buffer.extend(decode);\n\n                                if self.after_punycode_decode(\n                                    domain_buffer,\n                                    current_label_start,\n                                    &label_buffer,\n                                    deny_list_deny_dot,\n                                    fail_fast,\n                                    &mut had_errors,\n                                ) {\n                                    return (0, false, true);\n                                }\n\n                                if self.check_label(\n                                    hyphens,\n                                    &mut domain_buffer[current_label_start..],\n                                    fail_fast,\n                                    &mut had_errors,\n                                    true,\n                                    true,\n                                ) {\n                                    return (0, false, true);\n                                }\n                            } else {\n                                // Punycode failed\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                domain_buffer.push('\\u{FFFD}');\n                                let mut iter = ascii.iter();\n                                // Discard the first character that we replaced.\n                                let _ = iter.next();\n                                domain_buffer.extend(iter.map(|c| {\n                                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                                    // not matter.\n                                    apply_ascii_deny_list_to_potentially_upper_case_ascii(\n                                        *c, deny_list,\n                                    )\n                                }));\n                            };\n                            // If there were errors, we won't be trying to use this\n                            // anyway later, so it's fine to put it here unconditionally.\n                            already_punycode.push(AlreadyAsciiLabel::MixedCasePunycode(label));\n                            continue;\n                        } else if fail_fast {\n                            return (0, false, true);\n                        }\n                        // Else fall through to the complex path and rediscover error\n                        // there.\n                        false\n                    } else {\n                        true\n                    }\n                } else {\n                    false\n                };\n                for c in ascii.iter().map(|c| {\n                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                    // not matter.\n                    apply_ascii_deny_list_to_potentially_upper_case_ascii(*c, deny_list)\n                }) {\n                    if c == '\\u{FFFD}' {\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                    }\n                    domain_buffer.push(c);\n                }\n                if non_punycode_ascii_label {\n                    if hyphens != Hyphens::Allow\n                        && check_hyphens(\n                            &mut domain_buffer[current_label_start..],\n                            hyphens == Hyphens::CheckFirstLast,\n                            fail_fast,\n                            &mut had_errors,\n                        )\n                    {\n                        return (0, false, true);\n                    }\n                    already_punycode.push(if had_errors {\n                        AlreadyAsciiLabel::Other\n                    } else {\n                        AlreadyAsciiLabel::MixedCaseAscii(label)\n                    });\n                    continue;\n                }\n                already_punycode.push(AlreadyAsciiLabel::Other);\n                let mut first_needs_combining_mark_check = ascii.is_empty();\n                let mut needs_contextj_check = !non_ascii.is_empty();\n                let mut mapping = self\n                    .data\n                    .map_normalize(non_ascii.chars())\n                    .map(|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list));\n                loop {\n                    let n = mapping.next();\n                    match n {\n                        None | Some('.') => {\n                            if domain_buffer[current_label_start..]\n                                .starts_with(&['x', 'n', '-', '-'])\n                            {\n                                let mut punycode_precondition_failed = false;\n                                for c in domain_buffer[current_label_start + 4..].iter_mut() {\n                                    if !c.is_ascii() {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                }\n\n                                if let Some(last) = domain_buffer.last_mut() {\n                                    if *last == '-' {\n                                        // Either there's nothing after the \"xn--\" prefix\n                                        // and we got the last hyphen of \"xn--\", or there\n                                        // are no Punycode digits after the last delimiter\n                                        // which would result in Punycode decode outputting\n                                        // ASCII only.\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *last = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                } else {\n                                    unreachable!();\n                                }\n\n                                // Reject excessively long input\n                                // https://github.com/whatwg/url/issues/824\n                                // https://unicode-org.atlassian.net/browse/ICU-13727\n                                if domain_buffer.len() - current_label_start - 4\n                                    > PUNYCODE_DECODE_MAX_INPUT_LENGTH\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    domain_buffer[current_label_start\n                                        + 4\n                                        + PUNYCODE_DECODE_MAX_INPUT_LENGTH] = '\\u{FFFD}';\n                                    punycode_precondition_failed = true;\n                                }\n\n                                if !punycode_precondition_failed {\n                                    if let Ok(decode) = Decoder::default()\n                                        .decode::<char, InternalCaller>(\n                                            &domain_buffer[current_label_start + 4..],\n                                        )\n                                    {\n                                        first_needs_combining_mark_check = true;\n                                        needs_contextj_check = true;\n                                        // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                        // characters.\n                                        let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                        label_buffer.extend(decode);\n\n                                        domain_buffer.truncate(current_label_start);\n                                        if self.after_punycode_decode(\n                                            domain_buffer,\n                                            current_label_start,\n                                            &label_buffer,\n                                            deny_list_deny_dot,\n                                            fail_fast,\n                                            &mut had_errors,\n                                        ) {\n                                            return (0, false, true);\n                                        }\n                                    } else {\n                                        // Punycode failed\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        domain_buffer[current_label_start] = '\\u{FFFD}';\n                                        needs_contextj_check = false; // ASCII label\n                                        first_needs_combining_mark_check = false;\n                                    };\n                                } else {\n                                    first_needs_combining_mark_check = false;\n                                    needs_contextj_check = false; // Non-ASCII already turned to U+FFFD.\n                                }\n                            }\n                            if self.check_label(\n                                hyphens,\n                                &mut domain_buffer[current_label_start..],\n                                fail_fast,\n                                &mut had_errors,\n                                first_needs_combining_mark_check,\n                                needs_contextj_check,\n                            ) {\n                                return (0, false, true);\n                            }\n\n                            if n.is_none() {\n                                break;\n                            }\n                            domain_buffer.push('.');\n                            current_label_start = domain_buffer.len();\n                            first_needs_combining_mark_check = true;\n                            needs_contextj_check = true;\n                            already_punycode.push(AlreadyAsciiLabel::Other);\n                        }\n                        Some(c) => {\n                            if c == '\\u{FFFD}' {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                            }\n                            domain_buffer.push(c);\n                        }\n                    }\n                }\n            } else {\n                // Empty label\n                already_punycode.push(AlreadyAsciiLabel::MixedCaseAscii(label));\n            }\n        }",
)
into Match call
The code is Ok(
    "tail.split(|b| *b == b'.')",
)
LangItem path: idna/src/uts46.rs:1096:22: 1096:48 (#473)
The code is Ok(
    "tail.split(|b| *b == b'.')",
)
The code is Ok(
    "tail.split(|b| *b == b'.')",
)
The code is Ok(
    "tail",
)
The code is Ok(
    "|b| *b == b'.'",
)
The code is Ok(
    "*b == b'.'",
)
The code is Ok(
    "*b",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'.'",
)
The code is Ok(
    "for label in tail.split(|b| *b == b'.') {\n            // We check for passthrough only for the prefix. That is, if we\n            // haven't moved on and started filling `domain_buffer`. Keeping\n            // this stuff in one loop where the first items keep being skipped\n            // once they have been skipped at least once instead of working\n            // this into a fancier loop structure in order to make sure that\n            // no item from the iterator is lost or processed twice.\n            // Furthermore, after the passthrough fails, restarting the\n            // normalization process after each pre-existing ASCII dot also\n            // provides an opportunity for the processing to get back onto\n            // an ASCII fast path that bypasses the normalizer for ASCII\n            // after a pre-existing ASCII dot (pre-existing in the sense\n            // of not coming from e.g. normalizing an ideographic dot).\n            if in_prefix && is_passthrough_ascii_label(label) {\n                if seen_label {\n                    debug_assert_eq!(domain_name[passthrough_up_to], b'.');\n                    passthrough_up_to += 1;\n                }\n                seen_label = true;\n\n                passthrough_up_to += label.len();\n                continue;\n            }\n            if seen_label {\n                if in_prefix {\n                    debug_assert_eq!(domain_name[passthrough_up_to], b'.');\n                    passthrough_up_to += 1;\n                } else {\n                    domain_buffer.push('.');\n                }\n            }\n            seen_label = true;\n            in_prefix = false;\n            current_label_start = domain_buffer.len();\n            if !label.is_empty() {\n                let (ascii, non_ascii) = split_ascii_fast_path_prefix(label);\n                let non_punycode_ascii_label = if non_ascii.is_empty() {\n                    if has_punycode_prefix(ascii) {\n                        if (ascii.last() != Some(&b'-'))\n                            && (ascii.len() - 4 <= PUNYCODE_DECODE_MAX_INPUT_LENGTH)\n                        {\n                            if let Ok(decode) =\n                                Decoder::default().decode::<u8, InternalCaller>(&ascii[4..])\n                            {\n                                // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                // characters.\n                                let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                label_buffer.extend(decode);\n\n                                if self.after_punycode_decode(\n                                    domain_buffer,\n                                    current_label_start,\n                                    &label_buffer,\n                                    deny_list_deny_dot,\n                                    fail_fast,\n                                    &mut had_errors,\n                                ) {\n                                    return (0, false, true);\n                                }\n\n                                if self.check_label(\n                                    hyphens,\n                                    &mut domain_buffer[current_label_start..],\n                                    fail_fast,\n                                    &mut had_errors,\n                                    true,\n                                    true,\n                                ) {\n                                    return (0, false, true);\n                                }\n                            } else {\n                                // Punycode failed\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                domain_buffer.push('\\u{FFFD}');\n                                let mut iter = ascii.iter();\n                                // Discard the first character that we replaced.\n                                let _ = iter.next();\n                                domain_buffer.extend(iter.map(|c| {\n                                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                                    // not matter.\n                                    apply_ascii_deny_list_to_potentially_upper_case_ascii(\n                                        *c, deny_list,\n                                    )\n                                }));\n                            };\n                            // If there were errors, we won't be trying to use this\n                            // anyway later, so it's fine to put it here unconditionally.\n                            already_punycode.push(AlreadyAsciiLabel::MixedCasePunycode(label));\n                            continue;\n                        } else if fail_fast {\n                            return (0, false, true);\n                        }\n                        // Else fall through to the complex path and rediscover error\n                        // there.\n                        false\n                    } else {\n                        true\n                    }\n                } else {\n                    false\n                };\n                for c in ascii.iter().map(|c| {\n                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                    // not matter.\n                    apply_ascii_deny_list_to_potentially_upper_case_ascii(*c, deny_list)\n                }) {\n                    if c == '\\u{FFFD}' {\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                    }\n                    domain_buffer.push(c);\n                }\n                if non_punycode_ascii_label {\n                    if hyphens != Hyphens::Allow\n                        && check_hyphens(\n                            &mut domain_buffer[current_label_start..],\n                            hyphens == Hyphens::CheckFirstLast,\n                            fail_fast,\n                            &mut had_errors,\n                        )\n                    {\n                        return (0, false, true);\n                    }\n                    already_punycode.push(if had_errors {\n                        AlreadyAsciiLabel::Other\n                    } else {\n                        AlreadyAsciiLabel::MixedCaseAscii(label)\n                    });\n                    continue;\n                }\n                already_punycode.push(AlreadyAsciiLabel::Other);\n                let mut first_needs_combining_mark_check = ascii.is_empty();\n                let mut needs_contextj_check = !non_ascii.is_empty();\n                let mut mapping = self\n                    .data\n                    .map_normalize(non_ascii.chars())\n                    .map(|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list));\n                loop {\n                    let n = mapping.next();\n                    match n {\n                        None | Some('.') => {\n                            if domain_buffer[current_label_start..]\n                                .starts_with(&['x', 'n', '-', '-'])\n                            {\n                                let mut punycode_precondition_failed = false;\n                                for c in domain_buffer[current_label_start + 4..].iter_mut() {\n                                    if !c.is_ascii() {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                }\n\n                                if let Some(last) = domain_buffer.last_mut() {\n                                    if *last == '-' {\n                                        // Either there's nothing after the \"xn--\" prefix\n                                        // and we got the last hyphen of \"xn--\", or there\n                                        // are no Punycode digits after the last delimiter\n                                        // which would result in Punycode decode outputting\n                                        // ASCII only.\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *last = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                } else {\n                                    unreachable!();\n                                }\n\n                                // Reject excessively long input\n                                // https://github.com/whatwg/url/issues/824\n                                // https://unicode-org.atlassian.net/browse/ICU-13727\n                                if domain_buffer.len() - current_label_start - 4\n                                    > PUNYCODE_DECODE_MAX_INPUT_LENGTH\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    domain_buffer[current_label_start\n                                        + 4\n                                        + PUNYCODE_DECODE_MAX_INPUT_LENGTH] = '\\u{FFFD}';\n                                    punycode_precondition_failed = true;\n                                }\n\n                                if !punycode_precondition_failed {\n                                    if let Ok(decode) = Decoder::default()\n                                        .decode::<char, InternalCaller>(\n                                            &domain_buffer[current_label_start + 4..],\n                                        )\n                                    {\n                                        first_needs_combining_mark_check = true;\n                                        needs_contextj_check = true;\n                                        // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                        // characters.\n                                        let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                        label_buffer.extend(decode);\n\n                                        domain_buffer.truncate(current_label_start);\n                                        if self.after_punycode_decode(\n                                            domain_buffer,\n                                            current_label_start,\n                                            &label_buffer,\n                                            deny_list_deny_dot,\n                                            fail_fast,\n                                            &mut had_errors,\n                                        ) {\n                                            return (0, false, true);\n                                        }\n                                    } else {\n                                        // Punycode failed\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        domain_buffer[current_label_start] = '\\u{FFFD}';\n                                        needs_contextj_check = false; // ASCII label\n                                        first_needs_combining_mark_check = false;\n                                    };\n                                } else {\n                                    first_needs_combining_mark_check = false;\n                                    needs_contextj_check = false; // Non-ASCII already turned to U+FFFD.\n                                }\n                            }\n                            if self.check_label(\n                                hyphens,\n                                &mut domain_buffer[current_label_start..],\n                                fail_fast,\n                                &mut had_errors,\n                                first_needs_combining_mark_check,\n                                needs_contextj_check,\n                            ) {\n                                return (0, false, true);\n                            }\n\n                            if n.is_none() {\n                                break;\n                            }\n                            domain_buffer.push('.');\n                            current_label_start = domain_buffer.len();\n                            first_needs_combining_mark_check = true;\n                            needs_contextj_check = true;\n                            already_punycode.push(AlreadyAsciiLabel::Other);\n                        }\n                        Some(c) => {\n                            if c == '\\u{FFFD}' {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                            }\n                            domain_buffer.push(c);\n                        }\n                    }\n                }\n            } else {\n                // Empty label\n                already_punycode.push(AlreadyAsciiLabel::MixedCaseAscii(label));\n            }\n        }",
)
The code is Ok(
    "tail.split(|b| *b == b'.')",
)
into Match call
is inner Match
The code is Ok(
    "tail.split(|b| *b == b'.')",
)
LangItem path: idna/src/uts46.rs:1096:22: 1096:48 (#473)
The code is Ok(
    "tail.split(|b| *b == b'.')",
)
The code is Ok(
    "tail.split(|b| *b == b'.')",
)
The code is Ok(
    "tail.split(|b| *b == b'.')",
)
The code is Ok(
    "for label in tail.split(|b| *b == b'.') {\n            // We check for passthrough only for the prefix. That is, if we\n            // haven't moved on and started filling `domain_buffer`. Keeping\n            // this stuff in one loop where the first items keep being skipped\n            // once they have been skipped at least once instead of working\n            // this into a fancier loop structure in order to make sure that\n            // no item from the iterator is lost or processed twice.\n            // Furthermore, after the passthrough fails, restarting the\n            // normalization process after each pre-existing ASCII dot also\n            // provides an opportunity for the processing to get back onto\n            // an ASCII fast path that bypasses the normalizer for ASCII\n            // after a pre-existing ASCII dot (pre-existing in the sense\n            // of not coming from e.g. normalizing an ideographic dot).\n            if in_prefix && is_passthrough_ascii_label(label) {\n                if seen_label {\n                    debug_assert_eq!(domain_name[passthrough_up_to], b'.');\n                    passthrough_up_to += 1;\n                }\n                seen_label = true;\n\n                passthrough_up_to += label.len();\n                continue;\n            }\n            if seen_label {\n                if in_prefix {\n                    debug_assert_eq!(domain_name[passthrough_up_to], b'.');\n                    passthrough_up_to += 1;\n                } else {\n                    domain_buffer.push('.');\n                }\n            }\n            seen_label = true;\n            in_prefix = false;\n            current_label_start = domain_buffer.len();\n            if !label.is_empty() {\n                let (ascii, non_ascii) = split_ascii_fast_path_prefix(label);\n                let non_punycode_ascii_label = if non_ascii.is_empty() {\n                    if has_punycode_prefix(ascii) {\n                        if (ascii.last() != Some(&b'-'))\n                            && (ascii.len() - 4 <= PUNYCODE_DECODE_MAX_INPUT_LENGTH)\n                        {\n                            if let Ok(decode) =\n                                Decoder::default().decode::<u8, InternalCaller>(&ascii[4..])\n                            {\n                                // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                // characters.\n                                let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                label_buffer.extend(decode);\n\n                                if self.after_punycode_decode(\n                                    domain_buffer,\n                                    current_label_start,\n                                    &label_buffer,\n                                    deny_list_deny_dot,\n                                    fail_fast,\n                                    &mut had_errors,\n                                ) {\n                                    return (0, false, true);\n                                }\n\n                                if self.check_label(\n                                    hyphens,\n                                    &mut domain_buffer[current_label_start..],\n                                    fail_fast,\n                                    &mut had_errors,\n                                    true,\n                                    true,\n                                ) {\n                                    return (0, false, true);\n                                }\n                            } else {\n                                // Punycode failed\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                domain_buffer.push('\\u{FFFD}');\n                                let mut iter = ascii.iter();\n                                // Discard the first character that we replaced.\n                                let _ = iter.next();\n                                domain_buffer.extend(iter.map(|c| {\n                                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                                    // not matter.\n                                    apply_ascii_deny_list_to_potentially_upper_case_ascii(\n                                        *c, deny_list,\n                                    )\n                                }));\n                            };\n                            // If there were errors, we won't be trying to use this\n                            // anyway later, so it's fine to put it here unconditionally.\n                            already_punycode.push(AlreadyAsciiLabel::MixedCasePunycode(label));\n                            continue;\n                        } else if fail_fast {\n                            return (0, false, true);\n                        }\n                        // Else fall through to the complex path and rediscover error\n                        // there.\n                        false\n                    } else {\n                        true\n                    }\n                } else {\n                    false\n                };\n                for c in ascii.iter().map(|c| {\n                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                    // not matter.\n                    apply_ascii_deny_list_to_potentially_upper_case_ascii(*c, deny_list)\n                }) {\n                    if c == '\\u{FFFD}' {\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                    }\n                    domain_buffer.push(c);\n                }\n                if non_punycode_ascii_label {\n                    if hyphens != Hyphens::Allow\n                        && check_hyphens(\n                            &mut domain_buffer[current_label_start..],\n                            hyphens == Hyphens::CheckFirstLast,\n                            fail_fast,\n                            &mut had_errors,\n                        )\n                    {\n                        return (0, false, true);\n                    }\n                    already_punycode.push(if had_errors {\n                        AlreadyAsciiLabel::Other\n                    } else {\n                        AlreadyAsciiLabel::MixedCaseAscii(label)\n                    });\n                    continue;\n                }\n                already_punycode.push(AlreadyAsciiLabel::Other);\n                let mut first_needs_combining_mark_check = ascii.is_empty();\n                let mut needs_contextj_check = !non_ascii.is_empty();\n                let mut mapping = self\n                    .data\n                    .map_normalize(non_ascii.chars())\n                    .map(|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list));\n                loop {\n                    let n = mapping.next();\n                    match n {\n                        None | Some('.') => {\n                            if domain_buffer[current_label_start..]\n                                .starts_with(&['x', 'n', '-', '-'])\n                            {\n                                let mut punycode_precondition_failed = false;\n                                for c in domain_buffer[current_label_start + 4..].iter_mut() {\n                                    if !c.is_ascii() {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                }\n\n                                if let Some(last) = domain_buffer.last_mut() {\n                                    if *last == '-' {\n                                        // Either there's nothing after the \"xn--\" prefix\n                                        // and we got the last hyphen of \"xn--\", or there\n                                        // are no Punycode digits after the last delimiter\n                                        // which would result in Punycode decode outputting\n                                        // ASCII only.\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *last = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                } else {\n                                    unreachable!();\n                                }\n\n                                // Reject excessively long input\n                                // https://github.com/whatwg/url/issues/824\n                                // https://unicode-org.atlassian.net/browse/ICU-13727\n                                if domain_buffer.len() - current_label_start - 4\n                                    > PUNYCODE_DECODE_MAX_INPUT_LENGTH\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    domain_buffer[current_label_start\n                                        + 4\n                                        + PUNYCODE_DECODE_MAX_INPUT_LENGTH] = '\\u{FFFD}';\n                                    punycode_precondition_failed = true;\n                                }\n\n                                if !punycode_precondition_failed {\n                                    if let Ok(decode) = Decoder::default()\n                                        .decode::<char, InternalCaller>(\n                                            &domain_buffer[current_label_start + 4..],\n                                        )\n                                    {\n                                        first_needs_combining_mark_check = true;\n                                        needs_contextj_check = true;\n                                        // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                        // characters.\n                                        let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                        label_buffer.extend(decode);\n\n                                        domain_buffer.truncate(current_label_start);\n                                        if self.after_punycode_decode(\n                                            domain_buffer,\n                                            current_label_start,\n                                            &label_buffer,\n                                            deny_list_deny_dot,\n                                            fail_fast,\n                                            &mut had_errors,\n                                        ) {\n                                            return (0, false, true);\n                                        }\n                                    } else {\n                                        // Punycode failed\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        domain_buffer[current_label_start] = '\\u{FFFD}';\n                                        needs_contextj_check = false; // ASCII label\n                                        first_needs_combining_mark_check = false;\n                                    };\n                                } else {\n                                    first_needs_combining_mark_check = false;\n                                    needs_contextj_check = false; // Non-ASCII already turned to U+FFFD.\n                                }\n                            }\n                            if self.check_label(\n                                hyphens,\n                                &mut domain_buffer[current_label_start..],\n                                fail_fast,\n                                &mut had_errors,\n                                first_needs_combining_mark_check,\n                                needs_contextj_check,\n                            ) {\n                                return (0, false, true);\n                            }\n\n                            if n.is_none() {\n                                break;\n                            }\n                            domain_buffer.push('.');\n                            current_label_start = domain_buffer.len();\n                            first_needs_combining_mark_check = true;\n                            needs_contextj_check = true;\n                            already_punycode.push(AlreadyAsciiLabel::Other);\n                        }\n                        Some(c) => {\n                            if c == '\\u{FFFD}' {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                            }\n                            domain_buffer.push(c);\n                        }\n                    }\n                }\n            } else {\n                // Empty label\n                already_punycode.push(AlreadyAsciiLabel::MixedCaseAscii(label));\n            }\n        }",
)
The code is Ok(
    "{\n            // We check for passthrough only for the prefix. That is, if we\n            // haven't moved on and started filling `domain_buffer`. Keeping\n            // this stuff in one loop where the first items keep being skipped\n            // once they have been skipped at least once instead of working\n            // this into a fancier loop structure in order to make sure that\n            // no item from the iterator is lost or processed twice.\n            // Furthermore, after the passthrough fails, restarting the\n            // normalization process after each pre-existing ASCII dot also\n            // provides an opportunity for the processing to get back onto\n            // an ASCII fast path that bypasses the normalizer for ASCII\n            // after a pre-existing ASCII dot (pre-existing in the sense\n            // of not coming from e.g. normalizing an ideographic dot).\n            if in_prefix && is_passthrough_ascii_label(label) {\n                if seen_label {\n                    debug_assert_eq!(domain_name[passthrough_up_to], b'.');\n                    passthrough_up_to += 1;\n                }\n                seen_label = true;\n\n                passthrough_up_to += label.len();\n                continue;\n            }\n            if seen_label {\n                if in_prefix {\n                    debug_assert_eq!(domain_name[passthrough_up_to], b'.');\n                    passthrough_up_to += 1;\n                } else {\n                    domain_buffer.push('.');\n                }\n            }\n            seen_label = true;\n            in_prefix = false;\n            current_label_start = domain_buffer.len();\n            if !label.is_empty() {\n                let (ascii, non_ascii) = split_ascii_fast_path_prefix(label);\n                let non_punycode_ascii_label = if non_ascii.is_empty() {\n                    if has_punycode_prefix(ascii) {\n                        if (ascii.last() != Some(&b'-'))\n                            && (ascii.len() - 4 <= PUNYCODE_DECODE_MAX_INPUT_LENGTH)\n                        {\n                            if let Ok(decode) =\n                                Decoder::default().decode::<u8, InternalCaller>(&ascii[4..])\n                            {\n                                // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                // characters.\n                                let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                label_buffer.extend(decode);\n\n                                if self.after_punycode_decode(\n                                    domain_buffer,\n                                    current_label_start,\n                                    &label_buffer,\n                                    deny_list_deny_dot,\n                                    fail_fast,\n                                    &mut had_errors,\n                                ) {\n                                    return (0, false, true);\n                                }\n\n                                if self.check_label(\n                                    hyphens,\n                                    &mut domain_buffer[current_label_start..],\n                                    fail_fast,\n                                    &mut had_errors,\n                                    true,\n                                    true,\n                                ) {\n                                    return (0, false, true);\n                                }\n                            } else {\n                                // Punycode failed\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                domain_buffer.push('\\u{FFFD}');\n                                let mut iter = ascii.iter();\n                                // Discard the first character that we replaced.\n                                let _ = iter.next();\n                                domain_buffer.extend(iter.map(|c| {\n                                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                                    // not matter.\n                                    apply_ascii_deny_list_to_potentially_upper_case_ascii(\n                                        *c, deny_list,\n                                    )\n                                }));\n                            };\n                            // If there were errors, we won't be trying to use this\n                            // anyway later, so it's fine to put it here unconditionally.\n                            already_punycode.push(AlreadyAsciiLabel::MixedCasePunycode(label));\n                            continue;\n                        } else if fail_fast {\n                            return (0, false, true);\n                        }\n                        // Else fall through to the complex path and rediscover error\n                        // there.\n                        false\n                    } else {\n                        true\n                    }\n                } else {\n                    false\n                };\n                for c in ascii.iter().map(|c| {\n                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                    // not matter.\n                    apply_ascii_deny_list_to_potentially_upper_case_ascii(*c, deny_list)\n                }) {\n                    if c == '\\u{FFFD}' {\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                    }\n                    domain_buffer.push(c);\n                }\n                if non_punycode_ascii_label {\n                    if hyphens != Hyphens::Allow\n                        && check_hyphens(\n                            &mut domain_buffer[current_label_start..],\n                            hyphens == Hyphens::CheckFirstLast,\n                            fail_fast,\n                            &mut had_errors,\n                        )\n                    {\n                        return (0, false, true);\n                    }\n                    already_punycode.push(if had_errors {\n                        AlreadyAsciiLabel::Other\n                    } else {\n                        AlreadyAsciiLabel::MixedCaseAscii(label)\n                    });\n                    continue;\n                }\n                already_punycode.push(AlreadyAsciiLabel::Other);\n                let mut first_needs_combining_mark_check = ascii.is_empty();\n                let mut needs_contextj_check = !non_ascii.is_empty();\n                let mut mapping = self\n                    .data\n                    .map_normalize(non_ascii.chars())\n                    .map(|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list));\n                loop {\n                    let n = mapping.next();\n                    match n {\n                        None | Some('.') => {\n                            if domain_buffer[current_label_start..]\n                                .starts_with(&['x', 'n', '-', '-'])\n                            {\n                                let mut punycode_precondition_failed = false;\n                                for c in domain_buffer[current_label_start + 4..].iter_mut() {\n                                    if !c.is_ascii() {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                }\n\n                                if let Some(last) = domain_buffer.last_mut() {\n                                    if *last == '-' {\n                                        // Either there's nothing after the \"xn--\" prefix\n                                        // and we got the last hyphen of \"xn--\", or there\n                                        // are no Punycode digits after the last delimiter\n                                        // which would result in Punycode decode outputting\n                                        // ASCII only.\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *last = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                } else {\n                                    unreachable!();\n                                }\n\n                                // Reject excessively long input\n                                // https://github.com/whatwg/url/issues/824\n                                // https://unicode-org.atlassian.net/browse/ICU-13727\n                                if domain_buffer.len() - current_label_start - 4\n                                    > PUNYCODE_DECODE_MAX_INPUT_LENGTH\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    domain_buffer[current_label_start\n                                        + 4\n                                        + PUNYCODE_DECODE_MAX_INPUT_LENGTH] = '\\u{FFFD}';\n                                    punycode_precondition_failed = true;\n                                }\n\n                                if !punycode_precondition_failed {\n                                    if let Ok(decode) = Decoder::default()\n                                        .decode::<char, InternalCaller>(\n                                            &domain_buffer[current_label_start + 4..],\n                                        )\n                                    {\n                                        first_needs_combining_mark_check = true;\n                                        needs_contextj_check = true;\n                                        // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                        // characters.\n                                        let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                        label_buffer.extend(decode);\n\n                                        domain_buffer.truncate(current_label_start);\n                                        if self.after_punycode_decode(\n                                            domain_buffer,\n                                            current_label_start,\n                                            &label_buffer,\n                                            deny_list_deny_dot,\n                                            fail_fast,\n                                            &mut had_errors,\n                                        ) {\n                                            return (0, false, true);\n                                        }\n                                    } else {\n                                        // Punycode failed\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        domain_buffer[current_label_start] = '\\u{FFFD}';\n                                        needs_contextj_check = false; // ASCII label\n                                        first_needs_combining_mark_check = false;\n                                    };\n                                } else {\n                                    first_needs_combining_mark_check = false;\n                                    needs_contextj_check = false; // Non-ASCII already turned to U+FFFD.\n                                }\n                            }\n                            if self.check_label(\n                                hyphens,\n                                &mut domain_buffer[current_label_start..],\n                                fail_fast,\n                                &mut had_errors,\n                                first_needs_combining_mark_check,\n                                needs_contextj_check,\n                            ) {\n                                return (0, false, true);\n                            }\n\n                            if n.is_none() {\n                                break;\n                            }\n                            domain_buffer.push('.');\n                            current_label_start = domain_buffer.len();\n                            first_needs_combining_mark_check = true;\n                            needs_contextj_check = true;\n                            already_punycode.push(AlreadyAsciiLabel::Other);\n                        }\n                        Some(c) => {\n                            if c == '\\u{FFFD}' {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                            }\n                            domain_buffer.push(c);\n                        }\n                    }\n                }\n            } else {\n                // Empty label\n                already_punycode.push(AlreadyAsciiLabel::MixedCaseAscii(label));\n            }\n        }",
)
The code is Ok(
    "if in_prefix && is_passthrough_ascii_label(label) {\n                if seen_label {\n                    debug_assert_eq!(domain_name[passthrough_up_to], b'.');\n                    passthrough_up_to += 1;\n                }\n                seen_label = true;\n\n                passthrough_up_to += label.len();\n                continue;\n            }",
)
The code is Ok(
    "in_prefix && is_passthrough_ascii_label(label)",
)
The code is Ok(
    "in_prefix",
)
The code is Ok(
    "is_passthrough_ascii_label(label)",
)
resolved new call Call { call_expr: HirId(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost).82), call_expr_span: idna/src/uts46.rs:1109:29: 1109:62 (#0), caller: Some(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost)), caller_span: None, callee: DefId(0:150 ~ idna[bc6b]::uts46::is_passthrough_ascii_label), callee_span: idna/src/uts46.rs:1109:29: 1109:55 (#0), callee_path: "uts46::is_passthrough_ascii_label", constraint_depth: 2 }
The code is Ok(
    "is_passthrough_ascii_label",
)
The code is Ok(
    "label",
)
The code is Ok(
    "if seen_label {\n                    debug_assert_eq!(domain_name[passthrough_up_to], b'.');\n                    passthrough_up_to += 1;\n                }",
)
The code is Ok(
    "seen_label",
)
The code is Ok(
    "if $crate::cfg!(debug_assertions) {\n            $crate::assert_eq!($($arg)*);\n        }",
)
The code is Ok(
    "$crate::cfg!(debug_assertions)",
)
The code is Ok(
    "match (&$left, &$right) {\n            (left_val, right_val) => {\n                if !(*left_val == *right_val) {\n                    let kind = $crate::panicking::AssertKind::Eq;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }\n            }\n        }",
)
The code is Ok(
    "(&$left, &$right)",
)
The code is Ok(
    "&$left",
)
The code is Ok(
    "domain_name[passthrough_up_to]",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "passthrough_up_to",
)
The code is Ok(
    "&$right",
)
The code is Ok(
    "b'.'",
)
The code is Ok(
    "{\n                if !(*left_val == *right_val) {\n                    let kind = $crate::panicking::AssertKind::Eq;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }\n            }",
)
The code is Ok(
    "if !(*left_val == *right_val) {\n                    let kind = $crate::panicking::AssertKind::Eq;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }",
)
The code is Ok(
    "!(*left_val == *right_val)",
)
The code is Ok(
    "(*left_val == *right_val)",
)
The code is Ok(
    "*left_val",
)
The code is Ok(
    "left_val",
)
The code is Ok(
    "*right_val",
)
The code is Ok(
    "right_val",
)
The code is Ok(
    "$crate::panicking::AssertKind::Eq",
)
The code is Ok(
    "$crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None)",
)
resolved new call Call { call_expr: HirId(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost).128), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:51:21: 51:114 (#149), caller: Some(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost)), caller_span: None, callee: DefId(1:9590 ~ core[f118]::panicking::assert_failed), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:51:21: 51:53 (#149), callee_path: "core::panicking::assert_failed", constraint_depth: 4 }
The code is Ok(
    "$crate::panicking::assert_failed",
)
The code is Ok(
    "kind",
)
The code is Ok(
    "&*left_val",
)
The code is Ok(
    "*left_val",
)
The code is Ok(
    "left_val",
)
The code is Ok(
    "&*right_val",
)
The code is Ok(
    "*right_val",
)
The code is Ok(
    "right_val",
)
The code is Ok(
    "$crate::option::Option::None",
)
The code is Ok(
    "passthrough_up_to += 1",
)
The code is Ok(
    "1",
)
The code is Ok(
    "passthrough_up_to",
)
The code is Ok(
    "seen_label = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "seen_label",
)
The code is Ok(
    "passthrough_up_to += label.len()",
)
The code is Ok(
    "label.len()",
)
The code is Ok(
    "label",
)
The code is Ok(
    "passthrough_up_to",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "if seen_label {\n                if in_prefix {\n                    debug_assert_eq!(domain_name[passthrough_up_to], b'.');\n                    passthrough_up_to += 1;\n                } else {\n                    domain_buffer.push('.');\n                }\n            }",
)
The code is Ok(
    "seen_label",
)
The code is Ok(
    "if in_prefix {\n                    debug_assert_eq!(domain_name[passthrough_up_to], b'.');\n                    passthrough_up_to += 1;\n                } else {\n                    domain_buffer.push('.');\n                }",
)
The code is Ok(
    "in_prefix",
)
The code is Ok(
    "if $crate::cfg!(debug_assertions) {\n            $crate::assert_eq!($($arg)*);\n        }",
)
The code is Ok(
    "$crate::cfg!(debug_assertions)",
)
The code is Ok(
    "match (&$left, &$right) {\n            (left_val, right_val) => {\n                if !(*left_val == *right_val) {\n                    let kind = $crate::panicking::AssertKind::Eq;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }\n            }\n        }",
)
The code is Ok(
    "(&$left, &$right)",
)
The code is Ok(
    "&$left",
)
The code is Ok(
    "domain_name[passthrough_up_to]",
)
The code is Ok(
    "domain_name",
)
The code is Ok(
    "passthrough_up_to",
)
The code is Ok(
    "&$right",
)
The code is Ok(
    "b'.'",
)
The code is Ok(
    "{\n                if !(*left_val == *right_val) {\n                    let kind = $crate::panicking::AssertKind::Eq;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }\n            }",
)
The code is Ok(
    "if !(*left_val == *right_val) {\n                    let kind = $crate::panicking::AssertKind::Eq;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }",
)
The code is Ok(
    "!(*left_val == *right_val)",
)
The code is Ok(
    "(*left_val == *right_val)",
)
The code is Ok(
    "*left_val",
)
The code is Ok(
    "left_val",
)
The code is Ok(
    "*right_val",
)
The code is Ok(
    "right_val",
)
The code is Ok(
    "$crate::panicking::AssertKind::Eq",
)
The code is Ok(
    "$crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None)",
)
resolved new call Call { call_expr: HirId(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost).226), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:51:21: 51:114 (#152), caller: Some(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost)), caller_span: None, callee: DefId(1:9590 ~ core[f118]::panicking::assert_failed), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:51:21: 51:53 (#152), callee_path: "core::panicking::assert_failed", constraint_depth: 3 }
The code is Ok(
    "$crate::panicking::assert_failed",
)
The code is Ok(
    "kind",
)
The code is Ok(
    "&*left_val",
)
The code is Ok(
    "*left_val",
)
The code is Ok(
    "left_val",
)
The code is Ok(
    "&*right_val",
)
The code is Ok(
    "*right_val",
)
The code is Ok(
    "right_val",
)
The code is Ok(
    "$crate::option::Option::None",
)
The code is Ok(
    "passthrough_up_to += 1",
)
The code is Ok(
    "1",
)
The code is Ok(
    "passthrough_up_to",
)
The code is Ok(
    "domain_buffer.push('.')",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "'.'",
)
The code is Ok(
    "seen_label = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "seen_label",
)
The code is Ok(
    "in_prefix = false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "in_prefix",
)
The code is Ok(
    "current_label_start = domain_buffer.len()",
)
The code is Ok(
    "domain_buffer.len()",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "current_label_start",
)
The code is Ok(
    "if !label.is_empty() {\n                let (ascii, non_ascii) = split_ascii_fast_path_prefix(label);\n                let non_punycode_ascii_label = if non_ascii.is_empty() {\n                    if has_punycode_prefix(ascii) {\n                        if (ascii.last() != Some(&b'-'))\n                            && (ascii.len() - 4 <= PUNYCODE_DECODE_MAX_INPUT_LENGTH)\n                        {\n                            if let Ok(decode) =\n                                Decoder::default().decode::<u8, InternalCaller>(&ascii[4..])\n                            {\n                                // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                // characters.\n                                let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                label_buffer.extend(decode);\n\n                                if self.after_punycode_decode(\n                                    domain_buffer,\n                                    current_label_start,\n                                    &label_buffer,\n                                    deny_list_deny_dot,\n                                    fail_fast,\n                                    &mut had_errors,\n                                ) {\n                                    return (0, false, true);\n                                }\n\n                                if self.check_label(\n                                    hyphens,\n                                    &mut domain_buffer[current_label_start..],\n                                    fail_fast,\n                                    &mut had_errors,\n                                    true,\n                                    true,\n                                ) {\n                                    return (0, false, true);\n                                }\n                            } else {\n                                // Punycode failed\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                domain_buffer.push('\\u{FFFD}');\n                                let mut iter = ascii.iter();\n                                // Discard the first character that we replaced.\n                                let _ = iter.next();\n                                domain_buffer.extend(iter.map(|c| {\n                                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                                    // not matter.\n                                    apply_ascii_deny_list_to_potentially_upper_case_ascii(\n                                        *c, deny_list,\n                                    )\n                                }));\n                            };\n                            // If there were errors, we won't be trying to use this\n                            // anyway later, so it's fine to put it here unconditionally.\n                            already_punycode.push(AlreadyAsciiLabel::MixedCasePunycode(label));\n                            continue;\n                        } else if fail_fast {\n                            return (0, false, true);\n                        }\n                        // Else fall through to the complex path and rediscover error\n                        // there.\n                        false\n                    } else {\n                        true\n                    }\n                } else {\n                    false\n                };\n                for c in ascii.iter().map(|c| {\n                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                    // not matter.\n                    apply_ascii_deny_list_to_potentially_upper_case_ascii(*c, deny_list)\n                }) {\n                    if c == '\\u{FFFD}' {\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                    }\n                    domain_buffer.push(c);\n                }\n                if non_punycode_ascii_label {\n                    if hyphens != Hyphens::Allow\n                        && check_hyphens(\n                            &mut domain_buffer[current_label_start..],\n                            hyphens == Hyphens::CheckFirstLast,\n                            fail_fast,\n                            &mut had_errors,\n                        )\n                    {\n                        return (0, false, true);\n                    }\n                    already_punycode.push(if had_errors {\n                        AlreadyAsciiLabel::Other\n                    } else {\n                        AlreadyAsciiLabel::MixedCaseAscii(label)\n                    });\n                    continue;\n                }\n                already_punycode.push(AlreadyAsciiLabel::Other);\n                let mut first_needs_combining_mark_check = ascii.is_empty();\n                let mut needs_contextj_check = !non_ascii.is_empty();\n                let mut mapping = self\n                    .data\n                    .map_normalize(non_ascii.chars())\n                    .map(|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list));\n                loop {\n                    let n = mapping.next();\n                    match n {\n                        None | Some('.') => {\n                            if domain_buffer[current_label_start..]\n                                .starts_with(&['x', 'n', '-', '-'])\n                            {\n                                let mut punycode_precondition_failed = false;\n                                for c in domain_buffer[current_label_start + 4..].iter_mut() {\n                                    if !c.is_ascii() {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                }\n\n                                if let Some(last) = domain_buffer.last_mut() {\n                                    if *last == '-' {\n                                        // Either there's nothing after the \"xn--\" prefix\n                                        // and we got the last hyphen of \"xn--\", or there\n                                        // are no Punycode digits after the last delimiter\n                                        // which would result in Punycode decode outputting\n                                        // ASCII only.\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *last = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                } else {\n                                    unreachable!();\n                                }\n\n                                // Reject excessively long input\n                                // https://github.com/whatwg/url/issues/824\n                                // https://unicode-org.atlassian.net/browse/ICU-13727\n                                if domain_buffer.len() - current_label_start - 4\n                                    > PUNYCODE_DECODE_MAX_INPUT_LENGTH\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    domain_buffer[current_label_start\n                                        + 4\n                                        + PUNYCODE_DECODE_MAX_INPUT_LENGTH] = '\\u{FFFD}';\n                                    punycode_precondition_failed = true;\n                                }\n\n                                if !punycode_precondition_failed {\n                                    if let Ok(decode) = Decoder::default()\n                                        .decode::<char, InternalCaller>(\n                                            &domain_buffer[current_label_start + 4..],\n                                        )\n                                    {\n                                        first_needs_combining_mark_check = true;\n                                        needs_contextj_check = true;\n                                        // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                        // characters.\n                                        let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                        label_buffer.extend(decode);\n\n                                        domain_buffer.truncate(current_label_start);\n                                        if self.after_punycode_decode(\n                                            domain_buffer,\n                                            current_label_start,\n                                            &label_buffer,\n                                            deny_list_deny_dot,\n                                            fail_fast,\n                                            &mut had_errors,\n                                        ) {\n                                            return (0, false, true);\n                                        }\n                                    } else {\n                                        // Punycode failed\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        domain_buffer[current_label_start] = '\\u{FFFD}';\n                                        needs_contextj_check = false; // ASCII label\n                                        first_needs_combining_mark_check = false;\n                                    };\n                                } else {\n                                    first_needs_combining_mark_check = false;\n                                    needs_contextj_check = false; // Non-ASCII already turned to U+FFFD.\n                                }\n                            }\n                            if self.check_label(\n                                hyphens,\n                                &mut domain_buffer[current_label_start..],\n                                fail_fast,\n                                &mut had_errors,\n                                first_needs_combining_mark_check,\n                                needs_contextj_check,\n                            ) {\n                                return (0, false, true);\n                            }\n\n                            if n.is_none() {\n                                break;\n                            }\n                            domain_buffer.push('.');\n                            current_label_start = domain_buffer.len();\n                            first_needs_combining_mark_check = true;\n                            needs_contextj_check = true;\n                            already_punycode.push(AlreadyAsciiLabel::Other);\n                        }\n                        Some(c) => {\n                            if c == '\\u{FFFD}' {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                            }\n                            domain_buffer.push(c);\n                        }\n                    }\n                }\n            } else {\n                // Empty label\n                already_punycode.push(AlreadyAsciiLabel::MixedCaseAscii(label));\n            }",
)
The code is Ok(
    "!label.is_empty()",
)
The code is Ok(
    "label.is_empty()",
)
The code is Ok(
    "label",
)
The code is Ok(
    "split_ascii_fast_path_prefix(label)",
)
resolved new call Call { call_expr: HirId(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost).298), call_expr_span: idna/src/uts46.rs:1131:42: 1131:77 (#0), caller: Some(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost)), caller_span: None, callee: DefId(0:151 ~ idna[bc6b]::uts46::split_ascii_fast_path_prefix), callee_span: idna/src/uts46.rs:1131:42: 1131:70 (#0), callee_path: "uts46::split_ascii_fast_path_prefix", constraint_depth: 2 }
The code is Ok(
    "split_ascii_fast_path_prefix",
)
The code is Ok(
    "label",
)
The code is Ok(
    "if non_ascii.is_empty() {\n                    if has_punycode_prefix(ascii) {\n                        if (ascii.last() != Some(&b'-'))\n                            && (ascii.len() - 4 <= PUNYCODE_DECODE_MAX_INPUT_LENGTH)\n                        {\n                            if let Ok(decode) =\n                                Decoder::default().decode::<u8, InternalCaller>(&ascii[4..])\n                            {\n                                // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                // characters.\n                                let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                label_buffer.extend(decode);\n\n                                if self.after_punycode_decode(\n                                    domain_buffer,\n                                    current_label_start,\n                                    &label_buffer,\n                                    deny_list_deny_dot,\n                                    fail_fast,\n                                    &mut had_errors,\n                                ) {\n                                    return (0, false, true);\n                                }\n\n                                if self.check_label(\n                                    hyphens,\n                                    &mut domain_buffer[current_label_start..],\n                                    fail_fast,\n                                    &mut had_errors,\n                                    true,\n                                    true,\n                                ) {\n                                    return (0, false, true);\n                                }\n                            } else {\n                                // Punycode failed\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                domain_buffer.push('\\u{FFFD}');\n                                let mut iter = ascii.iter();\n                                // Discard the first character that we replaced.\n                                let _ = iter.next();\n                                domain_buffer.extend(iter.map(|c| {\n                                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                                    // not matter.\n                                    apply_ascii_deny_list_to_potentially_upper_case_ascii(\n                                        *c, deny_list,\n                                    )\n                                }));\n                            };\n                            // If there were errors, we won't be trying to use this\n                            // anyway later, so it's fine to put it here unconditionally.\n                            already_punycode.push(AlreadyAsciiLabel::MixedCasePunycode(label));\n                            continue;\n                        } else if fail_fast {\n                            return (0, false, true);\n                        }\n                        // Else fall through to the complex path and rediscover error\n                        // there.\n                        false\n                    } else {\n                        true\n                    }\n                } else {\n                    false\n                }",
)
The code is Ok(
    "non_ascii.is_empty()",
)
The code is Ok(
    "non_ascii",
)
The code is Ok(
    "if has_punycode_prefix(ascii) {\n                        if (ascii.last() != Some(&b'-'))\n                            && (ascii.len() - 4 <= PUNYCODE_DECODE_MAX_INPUT_LENGTH)\n                        {\n                            if let Ok(decode) =\n                                Decoder::default().decode::<u8, InternalCaller>(&ascii[4..])\n                            {\n                                // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                // characters.\n                                let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                label_buffer.extend(decode);\n\n                                if self.after_punycode_decode(\n                                    domain_buffer,\n                                    current_label_start,\n                                    &label_buffer,\n                                    deny_list_deny_dot,\n                                    fail_fast,\n                                    &mut had_errors,\n                                ) {\n                                    return (0, false, true);\n                                }\n\n                                if self.check_label(\n                                    hyphens,\n                                    &mut domain_buffer[current_label_start..],\n                                    fail_fast,\n                                    &mut had_errors,\n                                    true,\n                                    true,\n                                ) {\n                                    return (0, false, true);\n                                }\n                            } else {\n                                // Punycode failed\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                domain_buffer.push('\\u{FFFD}');\n                                let mut iter = ascii.iter();\n                                // Discard the first character that we replaced.\n                                let _ = iter.next();\n                                domain_buffer.extend(iter.map(|c| {\n                                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                                    // not matter.\n                                    apply_ascii_deny_list_to_potentially_upper_case_ascii(\n                                        *c, deny_list,\n                                    )\n                                }));\n                            };\n                            // If there were errors, we won't be trying to use this\n                            // anyway later, so it's fine to put it here unconditionally.\n                            already_punycode.push(AlreadyAsciiLabel::MixedCasePunycode(label));\n                            continue;\n                        } else if fail_fast {\n                            return (0, false, true);\n                        }\n                        // Else fall through to the complex path and rediscover error\n                        // there.\n                        false\n                    } else {\n                        true\n                    }",
)
The code is Ok(
    "has_punycode_prefix(ascii)",
)
resolved new call Call { call_expr: HirId(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost).315), call_expr_span: idna/src/uts46.rs:1133:24: 1133:50 (#0), caller: Some(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost)), caller_span: None, callee: DefId(0:147 ~ idna[bc6b]::uts46::has_punycode_prefix), callee_span: idna/src/uts46.rs:1133:24: 1133:43 (#0), callee_path: "uts46::has_punycode_prefix", constraint_depth: 3 }
The code is Ok(
    "has_punycode_prefix",
)
The code is Ok(
    "ascii",
)
The code is Ok(
    "if (ascii.last() != Some(&b'-'))\n                            && (ascii.len() - 4 <= PUNYCODE_DECODE_MAX_INPUT_LENGTH)\n                        {\n                            if let Ok(decode) =\n                                Decoder::default().decode::<u8, InternalCaller>(&ascii[4..])\n                            {\n                                // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                // characters.\n                                let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                label_buffer.extend(decode);\n\n                                if self.after_punycode_decode(\n                                    domain_buffer,\n                                    current_label_start,\n                                    &label_buffer,\n                                    deny_list_deny_dot,\n                                    fail_fast,\n                                    &mut had_errors,\n                                ) {\n                                    return (0, false, true);\n                                }\n\n                                if self.check_label(\n                                    hyphens,\n                                    &mut domain_buffer[current_label_start..],\n                                    fail_fast,\n                                    &mut had_errors,\n                                    true,\n                                    true,\n                                ) {\n                                    return (0, false, true);\n                                }\n                            } else {\n                                // Punycode failed\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                domain_buffer.push('\\u{FFFD}');\n                                let mut iter = ascii.iter();\n                                // Discard the first character that we replaced.\n                                let _ = iter.next();\n                                domain_buffer.extend(iter.map(|c| {\n                                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                                    // not matter.\n                                    apply_ascii_deny_list_to_potentially_upper_case_ascii(\n                                        *c, deny_list,\n                                    )\n                                }));\n                            };\n                            // If there were errors, we won't be trying to use this\n                            // anyway later, so it's fine to put it here unconditionally.\n                            already_punycode.push(AlreadyAsciiLabel::MixedCasePunycode(label));\n                            continue;\n                        } else if fail_fast {\n                            return (0, false, true);\n                        }",
)
The code is Ok(
    "(ascii.last() != Some(&b'-'))\n                            && (ascii.len() - 4 <= PUNYCODE_DECODE_MAX_INPUT_LENGTH)",
)
The code is Ok(
    "(ascii.last() != Some(&b'-'))",
)
The code is Ok(
    "ascii.last()",
)
The code is Ok(
    "ascii",
)
The code is Ok(
    "Some(&b'-')",
)
resolved new call Call { call_expr: HirId(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost).328), call_expr_span: idna/src/uts46.rs:1134:45: 1134:56 (#0), caller: Some(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost)), caller_span: None, callee: DefId(1:45302 ~ core[f118]::option::Option::Some::{constructor#0}), callee_span: idna/src/uts46.rs:1134:45: 1134:49 (#0), callee_path: "core::prelude::v1::Some", constraint_depth: 4 }
The code is Ok(
    "Some",
)
The code is Ok(
    "&b'-'",
)
The code is Ok(
    "b'-'",
)
The code is Ok(
    "(ascii.len() - 4 <= PUNYCODE_DECODE_MAX_INPUT_LENGTH)",
)
The code is Ok(
    "ascii.len() - 4",
)
The code is Ok(
    "ascii.len()",
)
The code is Ok(
    "ascii",
)
The code is Ok(
    "4",
)
The code is Ok(
    "PUNYCODE_DECODE_MAX_INPUT_LENGTH",
)
The code is Ok(
    "if let Ok(decode) =\n                                Decoder::default().decode::<u8, InternalCaller>(&ascii[4..])\n                            {\n                                // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                // characters.\n                                let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                label_buffer.extend(decode);\n\n                                if self.after_punycode_decode(\n                                    domain_buffer,\n                                    current_label_start,\n                                    &label_buffer,\n                                    deny_list_deny_dot,\n                                    fail_fast,\n                                    &mut had_errors,\n                                ) {\n                                    return (0, false, true);\n                                }\n\n                                if self.check_label(\n                                    hyphens,\n                                    &mut domain_buffer[current_label_start..],\n                                    fail_fast,\n                                    &mut had_errors,\n                                    true,\n                                    true,\n                                ) {\n                                    return (0, false, true);\n                                }\n                            } else {\n                                // Punycode failed\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                domain_buffer.push('\\u{FFFD}');\n                                let mut iter = ascii.iter();\n                                // Discard the first character that we replaced.\n                                let _ = iter.next();\n                                domain_buffer.extend(iter.map(|c| {\n                                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                                    // not matter.\n                                    apply_ascii_deny_list_to_potentially_upper_case_ascii(\n                                        *c, deny_list,\n                                    )\n                                }));\n                            }",
)
The code is Ok(
    "Decoder::default().decode::<u8, InternalCaller>(&ascii[4..])",
)
The code is Ok(
    "Decoder::default()",
)
The code is Ok(
    "Decoder::default",
)
The code is Ok(
    "&ascii[4..]",
)
The code is Ok(
    "ascii[4..]",
)
The code is Ok(
    "ascii",
)
The code is Ok(
    "4..",
)
The code is Ok(
    "4",
)
The code is Ok(
    "SmallVec::<[char; 59]>::new()",
)
The code is Ok(
    "SmallVec::<[char; 59]>::new",
)
The code is Ok(
    "59",
)
The code is Ok(
    "label_buffer.extend(decode)",
)
The code is Ok(
    "label_buffer",
)
The code is Ok(
    "decode",
)
The code is Ok(
    "if self.after_punycode_decode(\n                                    domain_buffer,\n                                    current_label_start,\n                                    &label_buffer,\n                                    deny_list_deny_dot,\n                                    fail_fast,\n                                    &mut had_errors,\n                                ) {\n                                    return (0, false, true);\n                                }",
)
The code is Ok(
    "self.after_punycode_decode(\n                                    domain_buffer,\n                                    current_label_start,\n                                    &label_buffer,\n                                    deny_list_deny_dot,\n                                    fail_fast,\n                                    &mut had_errors,\n                                )",
)
The code is Ok(
    "self",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "current_label_start",
)
The code is Ok(
    "&label_buffer",
)
The code is Ok(
    "label_buffer",
)
The code is Ok(
    "deny_list_deny_dot",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "&mut had_errors",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "return (0, false, true)",
)
The code is Ok(
    "(0, false, true)",
)
The code is Ok(
    "0",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "if self.check_label(\n                                    hyphens,\n                                    &mut domain_buffer[current_label_start..],\n                                    fail_fast,\n                                    &mut had_errors,\n                                    true,\n                                    true,\n                                ) {\n                                    return (0, false, true);\n                                }",
)
The code is Ok(
    "self.check_label(\n                                    hyphens,\n                                    &mut domain_buffer[current_label_start..],\n                                    fail_fast,\n                                    &mut had_errors,\n                                    true,\n                                    true,\n                                )",
)
The code is Ok(
    "self",
)
The code is Ok(
    "hyphens",
)
The code is Ok(
    "&mut domain_buffer[current_label_start..]",
)
The code is Ok(
    "domain_buffer[current_label_start..]",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "current_label_start..",
)
The code is Ok(
    "current_label_start",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "&mut had_errors",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "return (0, false, true)",
)
The code is Ok(
    "(0, false, true)",
)
The code is Ok(
    "0",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "if fail_fast {\n                                    return (0, false, true);\n                                }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return (0, false, true)",
)
The code is Ok(
    "(0, false, true)",
)
The code is Ok(
    "0",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "domain_buffer.push('\\u{FFFD}')",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "ascii.iter()",
)
The code is Ok(
    "ascii",
)
The code is Ok(
    "iter.next()",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "domain_buffer.extend(iter.map(|c| {\n                                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                                    // not matter.\n                                    apply_ascii_deny_list_to_potentially_upper_case_ascii(\n                                        *c, deny_list,\n                                    )\n                                }))",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "iter.map(|c| {\n                                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                                    // not matter.\n                                    apply_ascii_deny_list_to_potentially_upper_case_ascii(\n                                        *c, deny_list,\n                                    )\n                                })",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "|c| {\n                                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                                    // not matter.\n                                    apply_ascii_deny_list_to_potentially_upper_case_ascii(\n                                        *c, deny_list,\n                                    )\n                                }",
)
The code is Ok(
    "{\n                                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                                    // not matter.\n                                    apply_ascii_deny_list_to_potentially_upper_case_ascii(\n                                        *c, deny_list,\n                                    )\n                                }",
)
The code is Ok(
    "apply_ascii_deny_list_to_potentially_upper_case_ascii(\n                                        *c, deny_list,\n                                    )",
)
resolved new call Call { call_expr: HirId(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost).500), call_expr_span: idna/src/uts46.rs:1179:37: 1181:38 (#0), caller: Some(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost)), caller_span: None, callee: DefId(0:154 ~ idna[bc6b]::uts46::apply_ascii_deny_list_to_potentially_upper_case_ascii), callee_span: idna/src/uts46.rs:1179:37: 1179:90 (#0), callee_path: "uts46::apply_ascii_deny_list_to_potentially_upper_case_ascii", constraint_depth: 7 }
The code is Ok(
    "apply_ascii_deny_list_to_potentially_upper_case_ascii",
)
The code is Ok(
    "*c",
)
The code is Ok(
    "c",
)
The code is Ok(
    "deny_list",
)
The code is Ok(
    "already_punycode.push(AlreadyAsciiLabel::MixedCasePunycode(label))",
)
The code is Ok(
    "already_punycode",
)
The code is Ok(
    "AlreadyAsciiLabel::MixedCasePunycode(label)",
)
resolved new call Call { call_expr: HirId(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost).517), call_expr_span: idna/src/uts46.rs:1186:51: 1186:94 (#0), caller: Some(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost)), caller_span: None, callee: DefId(0:368 ~ idna[bc6b]::uts46::AlreadyAsciiLabel::MixedCasePunycode::{constructor#0}), callee_span: idna/src/uts46.rs:1186:51: 1186:87 (#0), callee_path: "uts46::AlreadyAsciiLabel::MixedCasePunycode", constraint_depth: 6 }
The code is Ok(
    "AlreadyAsciiLabel::MixedCasePunycode",
)
The code is Ok(
    "label",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "{\n                            return (0, false, true);\n                        }",
)
The code is Ok(
    "return (0, false, true)",
)
The code is Ok(
    "(0, false, true)",
)
The code is Ok(
    "0",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "false",
)
The code is Ok(
    "for c in ascii.iter().map(|c| {\n                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                    // not matter.\n                    apply_ascii_deny_list_to_potentially_upper_case_ascii(*c, deny_list)\n                }) {\n                    if c == '\\u{FFFD}' {\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                    }\n                    domain_buffer.push(c);\n                }",
)
The code is Ok(
    "for c in ascii.iter().map(|c| {\n                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                    // not matter.\n                    apply_ascii_deny_list_to_potentially_upper_case_ascii(*c, deny_list)\n                }) {\n                    if c == '\\u{FFFD}' {\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                    }\n                    domain_buffer.push(c);\n                }",
)
into Match call
The code is Ok(
    "ascii.iter().map(|c| {\n                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                    // not matter.\n                    apply_ascii_deny_list_to_potentially_upper_case_ascii(*c, deny_list)\n                })",
)
LangItem path: idna/src/uts46.rs:1200:26: 1204:19 (#496)
The code is Ok(
    "ascii.iter().map(|c| {\n                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                    // not matter.\n                    apply_ascii_deny_list_to_potentially_upper_case_ascii(*c, deny_list)\n                })",
)
The code is Ok(
    "ascii.iter().map(|c| {\n                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                    // not matter.\n                    apply_ascii_deny_list_to_potentially_upper_case_ascii(*c, deny_list)\n                })",
)
The code is Ok(
    "ascii.iter()",
)
The code is Ok(
    "ascii",
)
The code is Ok(
    "|c| {\n                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                    // not matter.\n                    apply_ascii_deny_list_to_potentially_upper_case_ascii(*c, deny_list)\n                }",
)
The code is Ok(
    "{\n                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                    // not matter.\n                    apply_ascii_deny_list_to_potentially_upper_case_ascii(*c, deny_list)\n                }",
)
The code is Ok(
    "apply_ascii_deny_list_to_potentially_upper_case_ascii(*c, deny_list)",
)
resolved new call Call { call_expr: HirId(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost).564), call_expr_span: idna/src/uts46.rs:1203:21: 1203:89 (#0), caller: Some(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost)), caller_span: None, callee: DefId(0:154 ~ idna[bc6b]::uts46::apply_ascii_deny_list_to_potentially_upper_case_ascii), callee_span: idna/src/uts46.rs:1203:21: 1203:74 (#0), callee_path: "uts46::apply_ascii_deny_list_to_potentially_upper_case_ascii", constraint_depth: 3 }
The code is Ok(
    "apply_ascii_deny_list_to_potentially_upper_case_ascii",
)
The code is Ok(
    "*c",
)
The code is Ok(
    "c",
)
The code is Ok(
    "deny_list",
)
The code is Ok(
    "for c in ascii.iter().map(|c| {\n                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                    // not matter.\n                    apply_ascii_deny_list_to_potentially_upper_case_ascii(*c, deny_list)\n                }) {\n                    if c == '\\u{FFFD}' {\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                    }\n                    domain_buffer.push(c);\n                }",
)
The code is Ok(
    "ascii.iter().map(|c| {\n                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                    // not matter.\n                    apply_ascii_deny_list_to_potentially_upper_case_ascii(*c, deny_list)\n                })",
)
into Match call
is inner Match
The code is Ok(
    "ascii.iter().map(|c| {\n                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                    // not matter.\n                    apply_ascii_deny_list_to_potentially_upper_case_ascii(*c, deny_list)\n                })",
)
LangItem path: idna/src/uts46.rs:1200:26: 1204:19 (#496)
The code is Ok(
    "ascii.iter().map(|c| {\n                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                    // not matter.\n                    apply_ascii_deny_list_to_potentially_upper_case_ascii(*c, deny_list)\n                })",
)
The code is Ok(
    "ascii.iter().map(|c| {\n                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                    // not matter.\n                    apply_ascii_deny_list_to_potentially_upper_case_ascii(*c, deny_list)\n                })",
)
The code is Ok(
    "ascii.iter().map(|c| {\n                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                    // not matter.\n                    apply_ascii_deny_list_to_potentially_upper_case_ascii(*c, deny_list)\n                })",
)
The code is Ok(
    "for c in ascii.iter().map(|c| {\n                    // Can't have dot here, so `deny_list` vs `deny_list_deny_dot` does\n                    // not matter.\n                    apply_ascii_deny_list_to_potentially_upper_case_ascii(*c, deny_list)\n                }) {\n                    if c == '\\u{FFFD}' {\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                    }\n                    domain_buffer.push(c);\n                }",
)
The code is Ok(
    "{\n                    if c == '\\u{FFFD}' {\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                    }\n                    domain_buffer.push(c);\n                }",
)
The code is Ok(
    "if c == '\\u{FFFD}' {\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                    }",
)
The code is Ok(
    "c == '\\u{FFFD}'",
)
The code is Ok(
    "c",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "if fail_fast {\n                            return (0, false, true);\n                        }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return (0, false, true)",
)
The code is Ok(
    "(0, false, true)",
)
The code is Ok(
    "0",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "domain_buffer.push(c)",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "c",
)
The code is Ok(
    "if non_punycode_ascii_label {\n                    if hyphens != Hyphens::Allow\n                        && check_hyphens(\n                            &mut domain_buffer[current_label_start..],\n                            hyphens == Hyphens::CheckFirstLast,\n                            fail_fast,\n                            &mut had_errors,\n                        )\n                    {\n                        return (0, false, true);\n                    }\n                    already_punycode.push(if had_errors {\n                        AlreadyAsciiLabel::Other\n                    } else {\n                        AlreadyAsciiLabel::MixedCaseAscii(label)\n                    });\n                    continue;\n                }",
)
The code is Ok(
    "non_punycode_ascii_label",
)
The code is Ok(
    "if hyphens != Hyphens::Allow\n                        && check_hyphens(\n                            &mut domain_buffer[current_label_start..],\n                            hyphens == Hyphens::CheckFirstLast,\n                            fail_fast,\n                            &mut had_errors,\n                        )\n                    {\n                        return (0, false, true);\n                    }",
)
The code is Ok(
    "hyphens != Hyphens::Allow\n                        && check_hyphens(\n                            &mut domain_buffer[current_label_start..],\n                            hyphens == Hyphens::CheckFirstLast,\n                            fail_fast,\n                            &mut had_errors,\n                        )",
)
The code is Ok(
    "hyphens != Hyphens::Allow",
)
The code is Ok(
    "hyphens",
)
The code is Ok(
    "Hyphens::Allow",
)
The code is Ok(
    "check_hyphens(\n                            &mut domain_buffer[current_label_start..],\n                            hyphens == Hyphens::CheckFirstLast,\n                            fail_fast,\n                            &mut had_errors,\n                        )",
)
resolved new call Call { call_expr: HirId(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost).645), call_expr_span: idna/src/uts46.rs:1215:28: 1220:26 (#0), caller: Some(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost)), caller_span: None, callee: DefId(0:218 ~ idna[bc6b]::uts46::check_hyphens), callee_span: idna/src/uts46.rs:1215:28: 1215:41 (#0), callee_path: "uts46::check_hyphens", constraint_depth: 4 }
The code is Ok(
    "check_hyphens",
)
The code is Ok(
    "&mut domain_buffer[current_label_start..]",
)
The code is Ok(
    "domain_buffer[current_label_start..]",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "current_label_start..",
)
The code is Ok(
    "current_label_start",
)
The code is Ok(
    "hyphens == Hyphens::CheckFirstLast",
)
The code is Ok(
    "hyphens",
)
The code is Ok(
    "Hyphens::CheckFirstLast",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "&mut had_errors",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "return (0, false, true)",
)
The code is Ok(
    "(0, false, true)",
)
The code is Ok(
    "0",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "already_punycode.push(if had_errors {\n                        AlreadyAsciiLabel::Other\n                    } else {\n                        AlreadyAsciiLabel::MixedCaseAscii(label)\n                    })",
)
The code is Ok(
    "already_punycode",
)
The code is Ok(
    "if had_errors {\n                        AlreadyAsciiLabel::Other\n                    } else {\n                        AlreadyAsciiLabel::MixedCaseAscii(label)\n                    }",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "AlreadyAsciiLabel::Other",
)
The code is Ok(
    "AlreadyAsciiLabel::MixedCaseAscii(label)",
)
resolved new call Call { call_expr: HirId(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost).691), call_expr_span: idna/src/uts46.rs:1227:25: 1227:65 (#0), caller: Some(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost)), caller_span: None, callee: DefId(0:365 ~ idna[bc6b]::uts46::AlreadyAsciiLabel::MixedCaseAscii::{constructor#0}), callee_span: idna/src/uts46.rs:1227:25: 1227:58 (#0), callee_path: "uts46::AlreadyAsciiLabel::MixedCaseAscii", constraint_depth: 4 }
The code is Ok(
    "AlreadyAsciiLabel::MixedCaseAscii",
)
The code is Ok(
    "label",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "already_punycode.push(AlreadyAsciiLabel::Other)",
)
The code is Ok(
    "already_punycode",
)
The code is Ok(
    "AlreadyAsciiLabel::Other",
)
The code is Ok(
    "ascii.is_empty()",
)
The code is Ok(
    "ascii",
)
The code is Ok(
    "!non_ascii.is_empty()",
)
The code is Ok(
    "non_ascii.is_empty()",
)
The code is Ok(
    "non_ascii",
)
The code is Ok(
    "self\n                    .data\n                    .map_normalize(non_ascii.chars())\n                    .map(|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list))",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost).728),
    call_expr_span: idna/src/uts46.rs:1234:35: 1237:89 (#0),
    caller: Some(
        DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost),
    ),
    caller_span: None,
    callee: DefId(1:8518 ~ core[f118]::iter::traits::iterator::Iterator::map),
    callee_span: idna/src/uts46.rs:1234:35: 1237:89 (#0),
    callee_path: "core::iter::Iterator::map",
    constraint_depth: 2,
}
The code is Ok(
    "self\n                    .data\n                    .map_normalize(non_ascii.chars())",
)
The code is Ok(
    "self\n                    .data",
)
The code is Ok(
    "self",
)
The code is Ok(
    "non_ascii.chars()",
)
The code is Ok(
    "non_ascii",
)
The code is Ok(
    "|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list)",
)
The code is Ok(
    "apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list)",
)
resolved new call Call { call_expr: HirId(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost).742), call_expr_span: idna/src/uts46.rs:1237:30: 1237:88 (#0), caller: Some(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost)), caller_span: None, callee: DefId(0:153 ~ idna[bc6b]::uts46::apply_ascii_deny_list_to_lower_cased_unicode), callee_span: idna/src/uts46.rs:1237:30: 1237:74 (#0), callee_path: "uts46::apply_ascii_deny_list_to_lower_cased_unicode", constraint_depth: 2 }
The code is Ok(
    "apply_ascii_deny_list_to_lower_cased_unicode",
)
The code is Ok(
    "c",
)
The code is Ok(
    "deny_list",
)
The code is Ok(
    "loop {\n                    let n = mapping.next();\n                    match n {\n                        None | Some('.') => {\n                            if domain_buffer[current_label_start..]\n                                .starts_with(&['x', 'n', '-', '-'])\n                            {\n                                let mut punycode_precondition_failed = false;\n                                for c in domain_buffer[current_label_start + 4..].iter_mut() {\n                                    if !c.is_ascii() {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                }\n\n                                if let Some(last) = domain_buffer.last_mut() {\n                                    if *last == '-' {\n                                        // Either there's nothing after the \"xn--\" prefix\n                                        // and we got the last hyphen of \"xn--\", or there\n                                        // are no Punycode digits after the last delimiter\n                                        // which would result in Punycode decode outputting\n                                        // ASCII only.\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *last = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                } else {\n                                    unreachable!();\n                                }\n\n                                // Reject excessively long input\n                                // https://github.com/whatwg/url/issues/824\n                                // https://unicode-org.atlassian.net/browse/ICU-13727\n                                if domain_buffer.len() - current_label_start - 4\n                                    > PUNYCODE_DECODE_MAX_INPUT_LENGTH\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    domain_buffer[current_label_start\n                                        + 4\n                                        + PUNYCODE_DECODE_MAX_INPUT_LENGTH] = '\\u{FFFD}';\n                                    punycode_precondition_failed = true;\n                                }\n\n                                if !punycode_precondition_failed {\n                                    if let Ok(decode) = Decoder::default()\n                                        .decode::<char, InternalCaller>(\n                                            &domain_buffer[current_label_start + 4..],\n                                        )\n                                    {\n                                        first_needs_combining_mark_check = true;\n                                        needs_contextj_check = true;\n                                        // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                        // characters.\n                                        let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                        label_buffer.extend(decode);\n\n                                        domain_buffer.truncate(current_label_start);\n                                        if self.after_punycode_decode(\n                                            domain_buffer,\n                                            current_label_start,\n                                            &label_buffer,\n                                            deny_list_deny_dot,\n                                            fail_fast,\n                                            &mut had_errors,\n                                        ) {\n                                            return (0, false, true);\n                                        }\n                                    } else {\n                                        // Punycode failed\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        domain_buffer[current_label_start] = '\\u{FFFD}';\n                                        needs_contextj_check = false; // ASCII label\n                                        first_needs_combining_mark_check = false;\n                                    };\n                                } else {\n                                    first_needs_combining_mark_check = false;\n                                    needs_contextj_check = false; // Non-ASCII already turned to U+FFFD.\n                                }\n                            }\n                            if self.check_label(\n                                hyphens,\n                                &mut domain_buffer[current_label_start..],\n                                fail_fast,\n                                &mut had_errors,\n                                first_needs_combining_mark_check,\n                                needs_contextj_check,\n                            ) {\n                                return (0, false, true);\n                            }\n\n                            if n.is_none() {\n                                break;\n                            }\n                            domain_buffer.push('.');\n                            current_label_start = domain_buffer.len();\n                            first_needs_combining_mark_check = true;\n                            needs_contextj_check = true;\n                            already_punycode.push(AlreadyAsciiLabel::Other);\n                        }\n                        Some(c) => {\n                            if c == '\\u{FFFD}' {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                            }\n                            domain_buffer.push(c);\n                        }\n                    }\n                }",
)
The code is Ok(
    "mapping.next()",
)
The code is Ok(
    "mapping",
)
The code is Ok(
    "match n {\n                        None | Some('.') => {\n                            if domain_buffer[current_label_start..]\n                                .starts_with(&['x', 'n', '-', '-'])\n                            {\n                                let mut punycode_precondition_failed = false;\n                                for c in domain_buffer[current_label_start + 4..].iter_mut() {\n                                    if !c.is_ascii() {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                }\n\n                                if let Some(last) = domain_buffer.last_mut() {\n                                    if *last == '-' {\n                                        // Either there's nothing after the \"xn--\" prefix\n                                        // and we got the last hyphen of \"xn--\", or there\n                                        // are no Punycode digits after the last delimiter\n                                        // which would result in Punycode decode outputting\n                                        // ASCII only.\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *last = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                } else {\n                                    unreachable!();\n                                }\n\n                                // Reject excessively long input\n                                // https://github.com/whatwg/url/issues/824\n                                // https://unicode-org.atlassian.net/browse/ICU-13727\n                                if domain_buffer.len() - current_label_start - 4\n                                    > PUNYCODE_DECODE_MAX_INPUT_LENGTH\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    domain_buffer[current_label_start\n                                        + 4\n                                        + PUNYCODE_DECODE_MAX_INPUT_LENGTH] = '\\u{FFFD}';\n                                    punycode_precondition_failed = true;\n                                }\n\n                                if !punycode_precondition_failed {\n                                    if let Ok(decode) = Decoder::default()\n                                        .decode::<char, InternalCaller>(\n                                            &domain_buffer[current_label_start + 4..],\n                                        )\n                                    {\n                                        first_needs_combining_mark_check = true;\n                                        needs_contextj_check = true;\n                                        // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                        // characters.\n                                        let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                        label_buffer.extend(decode);\n\n                                        domain_buffer.truncate(current_label_start);\n                                        if self.after_punycode_decode(\n                                            domain_buffer,\n                                            current_label_start,\n                                            &label_buffer,\n                                            deny_list_deny_dot,\n                                            fail_fast,\n                                            &mut had_errors,\n                                        ) {\n                                            return (0, false, true);\n                                        }\n                                    } else {\n                                        // Punycode failed\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        domain_buffer[current_label_start] = '\\u{FFFD}';\n                                        needs_contextj_check = false; // ASCII label\n                                        first_needs_combining_mark_check = false;\n                                    };\n                                } else {\n                                    first_needs_combining_mark_check = false;\n                                    needs_contextj_check = false; // Non-ASCII already turned to U+FFFD.\n                                }\n                            }\n                            if self.check_label(\n                                hyphens,\n                                &mut domain_buffer[current_label_start..],\n                                fail_fast,\n                                &mut had_errors,\n                                first_needs_combining_mark_check,\n                                needs_contextj_check,\n                            ) {\n                                return (0, false, true);\n                            }\n\n                            if n.is_none() {\n                                break;\n                            }\n                            domain_buffer.push('.');\n                            current_label_start = domain_buffer.len();\n                            first_needs_combining_mark_check = true;\n                            needs_contextj_check = true;\n                            already_punycode.push(AlreadyAsciiLabel::Other);\n                        }\n                        Some(c) => {\n                            if c == '\\u{FFFD}' {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                            }\n                            domain_buffer.push(c);\n                        }\n                    }",
)
The code is Ok(
    "n",
)
The code is Ok(
    "'.'",
)
The code is Ok(
    "{\n                            if domain_buffer[current_label_start..]\n                                .starts_with(&['x', 'n', '-', '-'])\n                            {\n                                let mut punycode_precondition_failed = false;\n                                for c in domain_buffer[current_label_start + 4..].iter_mut() {\n                                    if !c.is_ascii() {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                }\n\n                                if let Some(last) = domain_buffer.last_mut() {\n                                    if *last == '-' {\n                                        // Either there's nothing after the \"xn--\" prefix\n                                        // and we got the last hyphen of \"xn--\", or there\n                                        // are no Punycode digits after the last delimiter\n                                        // which would result in Punycode decode outputting\n                                        // ASCII only.\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *last = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                } else {\n                                    unreachable!();\n                                }\n\n                                // Reject excessively long input\n                                // https://github.com/whatwg/url/issues/824\n                                // https://unicode-org.atlassian.net/browse/ICU-13727\n                                if domain_buffer.len() - current_label_start - 4\n                                    > PUNYCODE_DECODE_MAX_INPUT_LENGTH\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    domain_buffer[current_label_start\n                                        + 4\n                                        + PUNYCODE_DECODE_MAX_INPUT_LENGTH] = '\\u{FFFD}';\n                                    punycode_precondition_failed = true;\n                                }\n\n                                if !punycode_precondition_failed {\n                                    if let Ok(decode) = Decoder::default()\n                                        .decode::<char, InternalCaller>(\n                                            &domain_buffer[current_label_start + 4..],\n                                        )\n                                    {\n                                        first_needs_combining_mark_check = true;\n                                        needs_contextj_check = true;\n                                        // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                        // characters.\n                                        let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                        label_buffer.extend(decode);\n\n                                        domain_buffer.truncate(current_label_start);\n                                        if self.after_punycode_decode(\n                                            domain_buffer,\n                                            current_label_start,\n                                            &label_buffer,\n                                            deny_list_deny_dot,\n                                            fail_fast,\n                                            &mut had_errors,\n                                        ) {\n                                            return (0, false, true);\n                                        }\n                                    } else {\n                                        // Punycode failed\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        domain_buffer[current_label_start] = '\\u{FFFD}';\n                                        needs_contextj_check = false; // ASCII label\n                                        first_needs_combining_mark_check = false;\n                                    };\n                                } else {\n                                    first_needs_combining_mark_check = false;\n                                    needs_contextj_check = false; // Non-ASCII already turned to U+FFFD.\n                                }\n                            }\n                            if self.check_label(\n                                hyphens,\n                                &mut domain_buffer[current_label_start..],\n                                fail_fast,\n                                &mut had_errors,\n                                first_needs_combining_mark_check,\n                                needs_contextj_check,\n                            ) {\n                                return (0, false, true);\n                            }\n\n                            if n.is_none() {\n                                break;\n                            }\n                            domain_buffer.push('.');\n                            current_label_start = domain_buffer.len();\n                            first_needs_combining_mark_check = true;\n                            needs_contextj_check = true;\n                            already_punycode.push(AlreadyAsciiLabel::Other);\n                        }",
)
The code is Ok(
    "if domain_buffer[current_label_start..]\n                                .starts_with(&['x', 'n', '-', '-'])\n                            {\n                                let mut punycode_precondition_failed = false;\n                                for c in domain_buffer[current_label_start + 4..].iter_mut() {\n                                    if !c.is_ascii() {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                }\n\n                                if let Some(last) = domain_buffer.last_mut() {\n                                    if *last == '-' {\n                                        // Either there's nothing after the \"xn--\" prefix\n                                        // and we got the last hyphen of \"xn--\", or there\n                                        // are no Punycode digits after the last delimiter\n                                        // which would result in Punycode decode outputting\n                                        // ASCII only.\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *last = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                } else {\n                                    unreachable!();\n                                }\n\n                                // Reject excessively long input\n                                // https://github.com/whatwg/url/issues/824\n                                // https://unicode-org.atlassian.net/browse/ICU-13727\n                                if domain_buffer.len() - current_label_start - 4\n                                    > PUNYCODE_DECODE_MAX_INPUT_LENGTH\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    domain_buffer[current_label_start\n                                        + 4\n                                        + PUNYCODE_DECODE_MAX_INPUT_LENGTH] = '\\u{FFFD}';\n                                    punycode_precondition_failed = true;\n                                }\n\n                                if !punycode_precondition_failed {\n                                    if let Ok(decode) = Decoder::default()\n                                        .decode::<char, InternalCaller>(\n                                            &domain_buffer[current_label_start + 4..],\n                                        )\n                                    {\n                                        first_needs_combining_mark_check = true;\n                                        needs_contextj_check = true;\n                                        // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                        // characters.\n                                        let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                        label_buffer.extend(decode);\n\n                                        domain_buffer.truncate(current_label_start);\n                                        if self.after_punycode_decode(\n                                            domain_buffer,\n                                            current_label_start,\n                                            &label_buffer,\n                                            deny_list_deny_dot,\n                                            fail_fast,\n                                            &mut had_errors,\n                                        ) {\n                                            return (0, false, true);\n                                        }\n                                    } else {\n                                        // Punycode failed\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        domain_buffer[current_label_start] = '\\u{FFFD}';\n                                        needs_contextj_check = false; // ASCII label\n                                        first_needs_combining_mark_check = false;\n                                    };\n                                } else {\n                                    first_needs_combining_mark_check = false;\n                                    needs_contextj_check = false; // Non-ASCII already turned to U+FFFD.\n                                }\n                            }",
)
The code is Ok(
    "domain_buffer[current_label_start..]\n                                .starts_with(&['x', 'n', '-', '-'])",
)
The code is Ok(
    "domain_buffer[current_label_start..]",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "current_label_start..",
)
The code is Ok(
    "current_label_start",
)
The code is Ok(
    "&['x', 'n', '-', '-']",
)
The code is Ok(
    "['x', 'n', '-', '-']",
)
The code is Ok(
    "'x'",
)
The code is Ok(
    "'n'",
)
The code is Ok(
    "'-'",
)
The code is Ok(
    "'-'",
)
The code is Ok(
    "false",
)
The code is Ok(
    "for c in domain_buffer[current_label_start + 4..].iter_mut() {\n                                    if !c.is_ascii() {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                }",
)
The code is Ok(
    "for c in domain_buffer[current_label_start + 4..].iter_mut() {\n                                    if !c.is_ascii() {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                }",
)
into Match call
The code is Ok(
    "domain_buffer[current_label_start + 4..].iter_mut()",
)
LangItem path: idna/src/uts46.rs:1246:42: 1246:93 (#505)
The code is Ok(
    "domain_buffer[current_label_start + 4..].iter_mut()",
)
The code is Ok(
    "domain_buffer[current_label_start + 4..].iter_mut()",
)
The code is Ok(
    "domain_buffer[current_label_start + 4..]",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "current_label_start + 4..",
)
The code is Ok(
    "current_label_start + 4",
)
The code is Ok(
    "current_label_start",
)
The code is Ok(
    "4",
)
The code is Ok(
    "for c in domain_buffer[current_label_start + 4..].iter_mut() {\n                                    if !c.is_ascii() {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                }",
)
The code is Ok(
    "domain_buffer[current_label_start + 4..].iter_mut()",
)
into Match call
is inner Match
The code is Ok(
    "domain_buffer[current_label_start + 4..].iter_mut()",
)
LangItem path: idna/src/uts46.rs:1246:42: 1246:93 (#505)
The code is Ok(
    "domain_buffer[current_label_start + 4..].iter_mut()",
)
The code is Ok(
    "domain_buffer[current_label_start + 4..].iter_mut()",
)
The code is Ok(
    "domain_buffer[current_label_start + 4..].iter_mut()",
)
The code is Ok(
    "for c in domain_buffer[current_label_start + 4..].iter_mut() {\n                                    if !c.is_ascii() {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                }",
)
The code is Ok(
    "{\n                                    if !c.is_ascii() {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                }",
)
The code is Ok(
    "if !c.is_ascii() {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }",
)
The code is Ok(
    "!c.is_ascii()",
)
The code is Ok(
    "c.is_ascii()",
)
The code is Ok(
    "c",
)
The code is Ok(
    "if fail_fast {\n                                            return (0, false, true);\n                                        }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return (0, false, true)",
)
The code is Ok(
    "(0, false, true)",
)
The code is Ok(
    "0",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "*c = '\\u{FFFD}'",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "*c",
)
The code is Ok(
    "c",
)
The code is Ok(
    "punycode_precondition_failed = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "punycode_precondition_failed",
)
The code is Ok(
    "if let Some(last) = domain_buffer.last_mut() {\n                                    if *last == '-' {\n                                        // Either there's nothing after the \"xn--\" prefix\n                                        // and we got the last hyphen of \"xn--\", or there\n                                        // are no Punycode digits after the last delimiter\n                                        // which would result in Punycode decode outputting\n                                        // ASCII only.\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *last = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                } else {\n                                    unreachable!();\n                                }",
)
The code is Ok(
    "domain_buffer.last_mut()",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "if *last == '-' {\n                                        // Either there's nothing after the \"xn--\" prefix\n                                        // and we got the last hyphen of \"xn--\", or there\n                                        // are no Punycode digits after the last delimiter\n                                        // which would result in Punycode decode outputting\n                                        // ASCII only.\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *last = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }",
)
The code is Ok(
    "*last == '-'",
)
The code is Ok(
    "*last",
)
The code is Ok(
    "last",
)
The code is Ok(
    "'-'",
)
The code is Ok(
    "if fail_fast {\n                                            return (0, false, true);\n                                        }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return (0, false, true)",
)
The code is Ok(
    "(0, false, true)",
)
The code is Ok(
    "0",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "*last = '\\u{FFFD}'",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "*last",
)
The code is Ok(
    "last",
)
The code is Ok(
    "punycode_precondition_failed = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "punycode_precondition_failed",
)
The code is Ok(
    "$crate::panicking::panic(\"internal error: entered unreachable code\")",
)
resolved new call Call { call_expr: HirId(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost).917), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:118:9: 118:77 (#155), caller: Some(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:118:9: 118:33 (#155), callee_path: "core::panicking::panic", constraint_depth: 5 }
The code is Ok(
    "$crate::panicking::panic",
)
The code is Ok(
    "\"internal error: entered unreachable code\"",
)
The code is Ok(
    "if domain_buffer.len() - current_label_start - 4\n                                    > PUNYCODE_DECODE_MAX_INPUT_LENGTH\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    domain_buffer[current_label_start\n                                        + 4\n                                        + PUNYCODE_DECODE_MAX_INPUT_LENGTH] = '\\u{FFFD}';\n                                    punycode_precondition_failed = true;\n                                }",
)
The code is Ok(
    "domain_buffer.len() - current_label_start - 4\n                                    > PUNYCODE_DECODE_MAX_INPUT_LENGTH",
)
The code is Ok(
    "domain_buffer.len() - current_label_start - 4",
)
The code is Ok(
    "domain_buffer.len() - current_label_start",
)
The code is Ok(
    "domain_buffer.len()",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "current_label_start",
)
The code is Ok(
    "4",
)
The code is Ok(
    "PUNYCODE_DECODE_MAX_INPUT_LENGTH",
)
The code is Ok(
    "if fail_fast {\n                                        return (0, false, true);\n                                    }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return (0, false, true)",
)
The code is Ok(
    "(0, false, true)",
)
The code is Ok(
    "0",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "domain_buffer[current_label_start\n                                        + 4\n                                        + PUNYCODE_DECODE_MAX_INPUT_LENGTH] = '\\u{FFFD}'",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "domain_buffer[current_label_start\n                                        + 4\n                                        + PUNYCODE_DECODE_MAX_INPUT_LENGTH]",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "current_label_start\n                                        + 4\n                                        + PUNYCODE_DECODE_MAX_INPUT_LENGTH",
)
The code is Ok(
    "current_label_start\n                                        + 4",
)
The code is Ok(
    "current_label_start",
)
The code is Ok(
    "4",
)
The code is Ok(
    "PUNYCODE_DECODE_MAX_INPUT_LENGTH",
)
The code is Ok(
    "punycode_precondition_failed = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "punycode_precondition_failed",
)
The code is Ok(
    "if !punycode_precondition_failed {\n                                    if let Ok(decode) = Decoder::default()\n                                        .decode::<char, InternalCaller>(\n                                            &domain_buffer[current_label_start + 4..],\n                                        )\n                                    {\n                                        first_needs_combining_mark_check = true;\n                                        needs_contextj_check = true;\n                                        // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                        // characters.\n                                        let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                        label_buffer.extend(decode);\n\n                                        domain_buffer.truncate(current_label_start);\n                                        if self.after_punycode_decode(\n                                            domain_buffer,\n                                            current_label_start,\n                                            &label_buffer,\n                                            deny_list_deny_dot,\n                                            fail_fast,\n                                            &mut had_errors,\n                                        ) {\n                                            return (0, false, true);\n                                        }\n                                    } else {\n                                        // Punycode failed\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        domain_buffer[current_label_start] = '\\u{FFFD}';\n                                        needs_contextj_check = false; // ASCII label\n                                        first_needs_combining_mark_check = false;\n                                    };\n                                } else {\n                                    first_needs_combining_mark_check = false;\n                                    needs_contextj_check = false; // Non-ASCII already turned to U+FFFD.\n                                }",
)
The code is Ok(
    "!punycode_precondition_failed",
)
The code is Ok(
    "punycode_precondition_failed",
)
The code is Ok(
    "if let Ok(decode) = Decoder::default()\n                                        .decode::<char, InternalCaller>(\n                                            &domain_buffer[current_label_start + 4..],\n                                        )\n                                    {\n                                        first_needs_combining_mark_check = true;\n                                        needs_contextj_check = true;\n                                        // 63 ASCII characters is the max length for a valid DNS label and xn-- takes 4\n                                        // characters.\n                                        let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                        label_buffer.extend(decode);\n\n                                        domain_buffer.truncate(current_label_start);\n                                        if self.after_punycode_decode(\n                                            domain_buffer,\n                                            current_label_start,\n                                            &label_buffer,\n                                            deny_list_deny_dot,\n                                            fail_fast,\n                                            &mut had_errors,\n                                        ) {\n                                            return (0, false, true);\n                                        }\n                                    } else {\n                                        // Punycode failed\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        domain_buffer[current_label_start] = '\\u{FFFD}';\n                                        needs_contextj_check = false; // ASCII label\n                                        first_needs_combining_mark_check = false;\n                                    }",
)
The code is Ok(
    "Decoder::default()\n                                        .decode::<char, InternalCaller>(\n                                            &domain_buffer[current_label_start + 4..],\n                                        )",
)
The code is Ok(
    "Decoder::default()",
)
The code is Ok(
    "Decoder::default",
)
The code is Ok(
    "&domain_buffer[current_label_start + 4..]",
)
The code is Ok(
    "domain_buffer[current_label_start + 4..]",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "current_label_start + 4..",
)
The code is Ok(
    "current_label_start + 4",
)
The code is Ok(
    "current_label_start",
)
The code is Ok(
    "4",
)
The code is Ok(
    "first_needs_combining_mark_check = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "first_needs_combining_mark_check",
)
The code is Ok(
    "needs_contextj_check = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "needs_contextj_check",
)
The code is Ok(
    "SmallVec::<[char; 59]>::new()",
)
The code is Ok(
    "SmallVec::<[char; 59]>::new",
)
The code is Ok(
    "59",
)
The code is Ok(
    "label_buffer.extend(decode)",
)
The code is Ok(
    "label_buffer",
)
The code is Ok(
    "decode",
)
The code is Ok(
    "domain_buffer.truncate(current_label_start)",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "current_label_start",
)
The code is Ok(
    "if self.after_punycode_decode(\n                                            domain_buffer,\n                                            current_label_start,\n                                            &label_buffer,\n                                            deny_list_deny_dot,\n                                            fail_fast,\n                                            &mut had_errors,\n                                        ) {\n                                            return (0, false, true);\n                                        }",
)
The code is Ok(
    "self.after_punycode_decode(\n                                            domain_buffer,\n                                            current_label_start,\n                                            &label_buffer,\n                                            deny_list_deny_dot,\n                                            fail_fast,\n                                            &mut had_errors,\n                                        )",
)
The code is Ok(
    "self",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "current_label_start",
)
The code is Ok(
    "&label_buffer",
)
The code is Ok(
    "label_buffer",
)
The code is Ok(
    "deny_list_deny_dot",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "&mut had_errors",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "return (0, false, true)",
)
The code is Ok(
    "(0, false, true)",
)
The code is Ok(
    "0",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "if fail_fast {\n                                            return (0, false, true);\n                                        }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return (0, false, true)",
)
The code is Ok(
    "(0, false, true)",
)
The code is Ok(
    "0",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "domain_buffer[current_label_start] = '\\u{FFFD}'",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "domain_buffer[current_label_start]",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "current_label_start",
)
The code is Ok(
    "needs_contextj_check = false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "needs_contextj_check",
)
The code is Ok(
    "first_needs_combining_mark_check = false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "first_needs_combining_mark_check",
)
The code is Ok(
    "first_needs_combining_mark_check = false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "first_needs_combining_mark_check",
)
The code is Ok(
    "needs_contextj_check = false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "needs_contextj_check",
)
The code is Ok(
    "if self.check_label(\n                                hyphens,\n                                &mut domain_buffer[current_label_start..],\n                                fail_fast,\n                                &mut had_errors,\n                                first_needs_combining_mark_check,\n                                needs_contextj_check,\n                            ) {\n                                return (0, false, true);\n                            }",
)
The code is Ok(
    "self.check_label(\n                                hyphens,\n                                &mut domain_buffer[current_label_start..],\n                                fail_fast,\n                                &mut had_errors,\n                                first_needs_combining_mark_check,\n                                needs_contextj_check,\n                            )",
)
The code is Ok(
    "self",
)
The code is Ok(
    "hyphens",
)
The code is Ok(
    "&mut domain_buffer[current_label_start..]",
)
The code is Ok(
    "domain_buffer[current_label_start..]",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "current_label_start..",
)
The code is Ok(
    "current_label_start",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "&mut had_errors",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "first_needs_combining_mark_check",
)
The code is Ok(
    "needs_contextj_check",
)
The code is Ok(
    "return (0, false, true)",
)
The code is Ok(
    "(0, false, true)",
)
The code is Ok(
    "0",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "if n.is_none() {\n                                break;\n                            }",
)
The code is Ok(
    "n.is_none()",
)
The code is Ok(
    "n",
)
The code is Ok(
    "break",
)
The code is Ok(
    "domain_buffer.push('.')",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "'.'",
)
The code is Ok(
    "current_label_start = domain_buffer.len()",
)
The code is Ok(
    "domain_buffer.len()",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "current_label_start",
)
The code is Ok(
    "first_needs_combining_mark_check = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "first_needs_combining_mark_check",
)
The code is Ok(
    "needs_contextj_check = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "needs_contextj_check",
)
The code is Ok(
    "already_punycode.push(AlreadyAsciiLabel::Other)",
)
The code is Ok(
    "already_punycode",
)
The code is Ok(
    "AlreadyAsciiLabel::Other",
)
The code is Ok(
    "{\n                            if c == '\\u{FFFD}' {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                            }\n                            domain_buffer.push(c);\n                        }",
)
The code is Ok(
    "if c == '\\u{FFFD}' {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                            }",
)
The code is Ok(
    "c == '\\u{FFFD}'",
)
The code is Ok(
    "c",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "if fail_fast {\n                                    return (0, false, true);\n                                }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return (0, false, true)",
)
The code is Ok(
    "(0, false, true)",
)
The code is Ok(
    "0",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "domain_buffer.push(c)",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "c",
)
The code is Ok(
    "already_punycode.push(AlreadyAsciiLabel::MixedCaseAscii(label))",
)
The code is Ok(
    "already_punycode",
)
The code is Ok(
    "AlreadyAsciiLabel::MixedCaseAscii(label)",
)
resolved new call Call { call_expr: HirId(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost).1260), call_expr_span: idna/src/uts46.rs:1363:39: 1363:79 (#0), caller: Some(DefId(0:199 ~ idna[bc6b]::uts46::{impl#4}::process_innermost)), caller_span: None, callee: DefId(0:365 ~ idna[bc6b]::uts46::AlreadyAsciiLabel::MixedCaseAscii::{constructor#0}), callee_span: idna/src/uts46.rs:1363:39: 1363:72 (#0), callee_path: "uts46::AlreadyAsciiLabel::MixedCaseAscii", constraint_depth: 2 }
The code is Ok(
    "AlreadyAsciiLabel::MixedCaseAscii",
)
The code is Ok(
    "label",
)
The code is Ok(
    "self.is_bidi(domain_buffer)",
)
The code is Ok(
    "self",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "if is_bidi {\n            for label in domain_buffer.split_mut(|c| *c == '.') {\n                if let Some((first, tail)) = label.split_first_mut() {\n                    let first_bc = self.data.bidi_class(*first);\n                    if !FIRST_BC_MASK.intersects(first_bc.to_mask()) {\n                        // Neither RTL label nor LTR label\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                        *first = '\\u{FFFD}';\n                        continue;\n                    }\n                    let is_ltr = first_bc.is_ltr();\n                    // Trim NSM\n                    let mut middle = tail;\n                    #[allow(clippy::while_let_loop)]\n                    loop {\n                        if let Some((last, prior)) = middle.split_last_mut() {\n                            let last_bc = self.data.bidi_class(*last);\n                            if last_bc.is_nonspacing_mark() {\n                                middle = prior;\n                                continue;\n                            }\n                            let last_mask = if is_ltr { LAST_LTR_MASK } else { LAST_RTL_MASK };\n                            if !last_mask.intersects(last_bc.to_mask()) {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                *last = '\\u{FFFD}';\n                            }\n                            if is_ltr {\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_LTR_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    }\n                                }\n                            } else {\n                                let mut numeral_state = RtlNumeralState::Undecided;\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_RTL_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    } else {\n                                        match numeral_state {\n                                            RtlNumeralState::Undecided => {\n                                                if bc.is_european_number() {\n                                                    numeral_state = RtlNumeralState::European;\n                                                } else if bc.is_arabic_number() {\n                                                    numeral_state = RtlNumeralState::Arabic;\n                                                }\n                                            }\n                                            RtlNumeralState::European => {\n                                                if bc.is_arabic_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                            RtlNumeralState::Arabic => {\n                                                if bc.is_european_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                                if (numeral_state == RtlNumeralState::European\n                                    && last_bc.is_arabic_number())\n                                    || (numeral_state == RtlNumeralState::Arabic\n                                        && last_bc.is_european_number())\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    *last = '\\u{FFFD}';\n                                }\n                            }\n                            break;\n                        } else {\n                            // One-character label or label where\n                            // everything after the first character\n                            // is just non-spacing marks.\n                            break;\n                        }\n                    }\n                }\n            }\n        }",
)
The code is Ok(
    "is_bidi",
)
The code is Ok(
    "for label in domain_buffer.split_mut(|c| *c == '.') {\n                if let Some((first, tail)) = label.split_first_mut() {\n                    let first_bc = self.data.bidi_class(*first);\n                    if !FIRST_BC_MASK.intersects(first_bc.to_mask()) {\n                        // Neither RTL label nor LTR label\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                        *first = '\\u{FFFD}';\n                        continue;\n                    }\n                    let is_ltr = first_bc.is_ltr();\n                    // Trim NSM\n                    let mut middle = tail;\n                    #[allow(clippy::while_let_loop)]\n                    loop {\n                        if let Some((last, prior)) = middle.split_last_mut() {\n                            let last_bc = self.data.bidi_class(*last);\n                            if last_bc.is_nonspacing_mark() {\n                                middle = prior;\n                                continue;\n                            }\n                            let last_mask = if is_ltr { LAST_LTR_MASK } else { LAST_RTL_MASK };\n                            if !last_mask.intersects(last_bc.to_mask()) {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                *last = '\\u{FFFD}';\n                            }\n                            if is_ltr {\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_LTR_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    }\n                                }\n                            } else {\n                                let mut numeral_state = RtlNumeralState::Undecided;\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_RTL_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    } else {\n                                        match numeral_state {\n                                            RtlNumeralState::Undecided => {\n                                                if bc.is_european_number() {\n                                                    numeral_state = RtlNumeralState::European;\n                                                } else if bc.is_arabic_number() {\n                                                    numeral_state = RtlNumeralState::Arabic;\n                                                }\n                                            }\n                                            RtlNumeralState::European => {\n                                                if bc.is_arabic_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                            RtlNumeralState::Arabic => {\n                                                if bc.is_european_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                                if (numeral_state == RtlNumeralState::European\n                                    && last_bc.is_arabic_number())\n                                    || (numeral_state == RtlNumeralState::Arabic\n                                        && last_bc.is_european_number())\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    *last = '\\u{FFFD}';\n                                }\n                            }\n                            break;\n                        } else {\n                            // One-character label or label where\n                            // everything after the first character\n                            // is just non-spacing marks.\n                            break;\n                        }\n                    }\n                }\n            }",
)
The code is Ok(
    "for label in domain_buffer.split_mut(|c| *c == '.') {\n                if let Some((first, tail)) = label.split_first_mut() {\n                    let first_bc = self.data.bidi_class(*first);\n                    if !FIRST_BC_MASK.intersects(first_bc.to_mask()) {\n                        // Neither RTL label nor LTR label\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                        *first = '\\u{FFFD}';\n                        continue;\n                    }\n                    let is_ltr = first_bc.is_ltr();\n                    // Trim NSM\n                    let mut middle = tail;\n                    #[allow(clippy::while_let_loop)]\n                    loop {\n                        if let Some((last, prior)) = middle.split_last_mut() {\n                            let last_bc = self.data.bidi_class(*last);\n                            if last_bc.is_nonspacing_mark() {\n                                middle = prior;\n                                continue;\n                            }\n                            let last_mask = if is_ltr { LAST_LTR_MASK } else { LAST_RTL_MASK };\n                            if !last_mask.intersects(last_bc.to_mask()) {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                *last = '\\u{FFFD}';\n                            }\n                            if is_ltr {\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_LTR_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    }\n                                }\n                            } else {\n                                let mut numeral_state = RtlNumeralState::Undecided;\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_RTL_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    } else {\n                                        match numeral_state {\n                                            RtlNumeralState::Undecided => {\n                                                if bc.is_european_number() {\n                                                    numeral_state = RtlNumeralState::European;\n                                                } else if bc.is_arabic_number() {\n                                                    numeral_state = RtlNumeralState::Arabic;\n                                                }\n                                            }\n                                            RtlNumeralState::European => {\n                                                if bc.is_arabic_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                            RtlNumeralState::Arabic => {\n                                                if bc.is_european_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                                if (numeral_state == RtlNumeralState::European\n                                    && last_bc.is_arabic_number())\n                                    || (numeral_state == RtlNumeralState::Arabic\n                                        && last_bc.is_european_number())\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    *last = '\\u{FFFD}';\n                                }\n                            }\n                            break;\n                        } else {\n                            // One-character label or label where\n                            // everything after the first character\n                            // is just non-spacing marks.\n                            break;\n                        }\n                    }\n                }\n            }",
)
into Match call
The code is Ok(
    "domain_buffer.split_mut(|c| *c == '.')",
)
LangItem path: idna/src/uts46.rs:1369:26: 1369:64 (#522)
The code is Ok(
    "domain_buffer.split_mut(|c| *c == '.')",
)
The code is Ok(
    "domain_buffer.split_mut(|c| *c == '.')",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "|c| *c == '.'",
)
The code is Ok(
    "*c == '.'",
)
The code is Ok(
    "*c",
)
The code is Ok(
    "c",
)
The code is Ok(
    "'.'",
)
The code is Ok(
    "for label in domain_buffer.split_mut(|c| *c == '.') {\n                if let Some((first, tail)) = label.split_first_mut() {\n                    let first_bc = self.data.bidi_class(*first);\n                    if !FIRST_BC_MASK.intersects(first_bc.to_mask()) {\n                        // Neither RTL label nor LTR label\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                        *first = '\\u{FFFD}';\n                        continue;\n                    }\n                    let is_ltr = first_bc.is_ltr();\n                    // Trim NSM\n                    let mut middle = tail;\n                    #[allow(clippy::while_let_loop)]\n                    loop {\n                        if let Some((last, prior)) = middle.split_last_mut() {\n                            let last_bc = self.data.bidi_class(*last);\n                            if last_bc.is_nonspacing_mark() {\n                                middle = prior;\n                                continue;\n                            }\n                            let last_mask = if is_ltr { LAST_LTR_MASK } else { LAST_RTL_MASK };\n                            if !last_mask.intersects(last_bc.to_mask()) {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                *last = '\\u{FFFD}';\n                            }\n                            if is_ltr {\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_LTR_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    }\n                                }\n                            } else {\n                                let mut numeral_state = RtlNumeralState::Undecided;\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_RTL_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    } else {\n                                        match numeral_state {\n                                            RtlNumeralState::Undecided => {\n                                                if bc.is_european_number() {\n                                                    numeral_state = RtlNumeralState::European;\n                                                } else if bc.is_arabic_number() {\n                                                    numeral_state = RtlNumeralState::Arabic;\n                                                }\n                                            }\n                                            RtlNumeralState::European => {\n                                                if bc.is_arabic_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                            RtlNumeralState::Arabic => {\n                                                if bc.is_european_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                                if (numeral_state == RtlNumeralState::European\n                                    && last_bc.is_arabic_number())\n                                    || (numeral_state == RtlNumeralState::Arabic\n                                        && last_bc.is_european_number())\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    *last = '\\u{FFFD}';\n                                }\n                            }\n                            break;\n                        } else {\n                            // One-character label or label where\n                            // everything after the first character\n                            // is just non-spacing marks.\n                            break;\n                        }\n                    }\n                }\n            }",
)
The code is Ok(
    "domain_buffer.split_mut(|c| *c == '.')",
)
into Match call
is inner Match
The code is Ok(
    "domain_buffer.split_mut(|c| *c == '.')",
)
LangItem path: idna/src/uts46.rs:1369:26: 1369:64 (#522)
The code is Ok(
    "domain_buffer.split_mut(|c| *c == '.')",
)
The code is Ok(
    "domain_buffer.split_mut(|c| *c == '.')",
)
The code is Ok(
    "domain_buffer.split_mut(|c| *c == '.')",
)
The code is Ok(
    "for label in domain_buffer.split_mut(|c| *c == '.') {\n                if let Some((first, tail)) = label.split_first_mut() {\n                    let first_bc = self.data.bidi_class(*first);\n                    if !FIRST_BC_MASK.intersects(first_bc.to_mask()) {\n                        // Neither RTL label nor LTR label\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                        *first = '\\u{FFFD}';\n                        continue;\n                    }\n                    let is_ltr = first_bc.is_ltr();\n                    // Trim NSM\n                    let mut middle = tail;\n                    #[allow(clippy::while_let_loop)]\n                    loop {\n                        if let Some((last, prior)) = middle.split_last_mut() {\n                            let last_bc = self.data.bidi_class(*last);\n                            if last_bc.is_nonspacing_mark() {\n                                middle = prior;\n                                continue;\n                            }\n                            let last_mask = if is_ltr { LAST_LTR_MASK } else { LAST_RTL_MASK };\n                            if !last_mask.intersects(last_bc.to_mask()) {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                *last = '\\u{FFFD}';\n                            }\n                            if is_ltr {\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_LTR_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    }\n                                }\n                            } else {\n                                let mut numeral_state = RtlNumeralState::Undecided;\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_RTL_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    } else {\n                                        match numeral_state {\n                                            RtlNumeralState::Undecided => {\n                                                if bc.is_european_number() {\n                                                    numeral_state = RtlNumeralState::European;\n                                                } else if bc.is_arabic_number() {\n                                                    numeral_state = RtlNumeralState::Arabic;\n                                                }\n                                            }\n                                            RtlNumeralState::European => {\n                                                if bc.is_arabic_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                            RtlNumeralState::Arabic => {\n                                                if bc.is_european_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                                if (numeral_state == RtlNumeralState::European\n                                    && last_bc.is_arabic_number())\n                                    || (numeral_state == RtlNumeralState::Arabic\n                                        && last_bc.is_european_number())\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    *last = '\\u{FFFD}';\n                                }\n                            }\n                            break;\n                        } else {\n                            // One-character label or label where\n                            // everything after the first character\n                            // is just non-spacing marks.\n                            break;\n                        }\n                    }\n                }\n            }",
)
The code is Ok(
    "{\n                if let Some((first, tail)) = label.split_first_mut() {\n                    let first_bc = self.data.bidi_class(*first);\n                    if !FIRST_BC_MASK.intersects(first_bc.to_mask()) {\n                        // Neither RTL label nor LTR label\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                        *first = '\\u{FFFD}';\n                        continue;\n                    }\n                    let is_ltr = first_bc.is_ltr();\n                    // Trim NSM\n                    let mut middle = tail;\n                    #[allow(clippy::while_let_loop)]\n                    loop {\n                        if let Some((last, prior)) = middle.split_last_mut() {\n                            let last_bc = self.data.bidi_class(*last);\n                            if last_bc.is_nonspacing_mark() {\n                                middle = prior;\n                                continue;\n                            }\n                            let last_mask = if is_ltr { LAST_LTR_MASK } else { LAST_RTL_MASK };\n                            if !last_mask.intersects(last_bc.to_mask()) {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                *last = '\\u{FFFD}';\n                            }\n                            if is_ltr {\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_LTR_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    }\n                                }\n                            } else {\n                                let mut numeral_state = RtlNumeralState::Undecided;\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_RTL_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    } else {\n                                        match numeral_state {\n                                            RtlNumeralState::Undecided => {\n                                                if bc.is_european_number() {\n                                                    numeral_state = RtlNumeralState::European;\n                                                } else if bc.is_arabic_number() {\n                                                    numeral_state = RtlNumeralState::Arabic;\n                                                }\n                                            }\n                                            RtlNumeralState::European => {\n                                                if bc.is_arabic_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                            RtlNumeralState::Arabic => {\n                                                if bc.is_european_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                                if (numeral_state == RtlNumeralState::European\n                                    && last_bc.is_arabic_number())\n                                    || (numeral_state == RtlNumeralState::Arabic\n                                        && last_bc.is_european_number())\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    *last = '\\u{FFFD}';\n                                }\n                            }\n                            break;\n                        } else {\n                            // One-character label or label where\n                            // everything after the first character\n                            // is just non-spacing marks.\n                            break;\n                        }\n                    }\n                }\n            }",
)
The code is Ok(
    "if let Some((first, tail)) = label.split_first_mut() {\n                    let first_bc = self.data.bidi_class(*first);\n                    if !FIRST_BC_MASK.intersects(first_bc.to_mask()) {\n                        // Neither RTL label nor LTR label\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                        *first = '\\u{FFFD}';\n                        continue;\n                    }\n                    let is_ltr = first_bc.is_ltr();\n                    // Trim NSM\n                    let mut middle = tail;\n                    #[allow(clippy::while_let_loop)]\n                    loop {\n                        if let Some((last, prior)) = middle.split_last_mut() {\n                            let last_bc = self.data.bidi_class(*last);\n                            if last_bc.is_nonspacing_mark() {\n                                middle = prior;\n                                continue;\n                            }\n                            let last_mask = if is_ltr { LAST_LTR_MASK } else { LAST_RTL_MASK };\n                            if !last_mask.intersects(last_bc.to_mask()) {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                *last = '\\u{FFFD}';\n                            }\n                            if is_ltr {\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_LTR_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    }\n                                }\n                            } else {\n                                let mut numeral_state = RtlNumeralState::Undecided;\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_RTL_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    } else {\n                                        match numeral_state {\n                                            RtlNumeralState::Undecided => {\n                                                if bc.is_european_number() {\n                                                    numeral_state = RtlNumeralState::European;\n                                                } else if bc.is_arabic_number() {\n                                                    numeral_state = RtlNumeralState::Arabic;\n                                                }\n                                            }\n                                            RtlNumeralState::European => {\n                                                if bc.is_arabic_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                            RtlNumeralState::Arabic => {\n                                                if bc.is_european_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                                if (numeral_state == RtlNumeralState::European\n                                    && last_bc.is_arabic_number())\n                                    || (numeral_state == RtlNumeralState::Arabic\n                                        && last_bc.is_european_number())\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    *last = '\\u{FFFD}';\n                                }\n                            }\n                            break;\n                        } else {\n                            // One-character label or label where\n                            // everything after the first character\n                            // is just non-spacing marks.\n                            break;\n                        }\n                    }\n                }",
)
The code is Ok(
    "label.split_first_mut()",
)
The code is Ok(
    "label",
)
The code is Ok(
    "self.data.bidi_class(*first)",
)
The code is Ok(
    "self.data",
)
The code is Ok(
    "self",
)
The code is Ok(
    "*first",
)
The code is Ok(
    "first",
)
The code is Ok(
    "if !FIRST_BC_MASK.intersects(first_bc.to_mask()) {\n                        // Neither RTL label nor LTR label\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                        *first = '\\u{FFFD}';\n                        continue;\n                    }",
)
The code is Ok(
    "!FIRST_BC_MASK.intersects(first_bc.to_mask())",
)
The code is Ok(
    "FIRST_BC_MASK.intersects(first_bc.to_mask())",
)
The code is Ok(
    "FIRST_BC_MASK",
)
The code is Ok(
    "first_bc.to_mask()",
)
The code is Ok(
    "first_bc",
)
The code is Ok(
    "if fail_fast {\n                            return (0, false, true);\n                        }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return (0, false, true)",
)
The code is Ok(
    "(0, false, true)",
)
The code is Ok(
    "0",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "*first = '\\u{FFFD}'",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "*first",
)
The code is Ok(
    "first",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "first_bc.is_ltr()",
)
The code is Ok(
    "first_bc",
)
The code is Ok(
    "tail",
)
The code is Ok(
    "loop {\n                        if let Some((last, prior)) = middle.split_last_mut() {\n                            let last_bc = self.data.bidi_class(*last);\n                            if last_bc.is_nonspacing_mark() {\n                                middle = prior;\n                                continue;\n                            }\n                            let last_mask = if is_ltr { LAST_LTR_MASK } else { LAST_RTL_MASK };\n                            if !last_mask.intersects(last_bc.to_mask()) {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                *last = '\\u{FFFD}';\n                            }\n                            if is_ltr {\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_LTR_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    }\n                                }\n                            } else {\n                                let mut numeral_state = RtlNumeralState::Undecided;\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_RTL_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    } else {\n                                        match numeral_state {\n                                            RtlNumeralState::Undecided => {\n                                                if bc.is_european_number() {\n                                                    numeral_state = RtlNumeralState::European;\n                                                } else if bc.is_arabic_number() {\n                                                    numeral_state = RtlNumeralState::Arabic;\n                                                }\n                                            }\n                                            RtlNumeralState::European => {\n                                                if bc.is_arabic_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                            RtlNumeralState::Arabic => {\n                                                if bc.is_european_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                                if (numeral_state == RtlNumeralState::European\n                                    && last_bc.is_arabic_number())\n                                    || (numeral_state == RtlNumeralState::Arabic\n                                        && last_bc.is_european_number())\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    *last = '\\u{FFFD}';\n                                }\n                            }\n                            break;\n                        } else {\n                            // One-character label or label where\n                            // everything after the first character\n                            // is just non-spacing marks.\n                            break;\n                        }\n                    }",
)
The code is Ok(
    "if let Some((last, prior)) = middle.split_last_mut() {\n                            let last_bc = self.data.bidi_class(*last);\n                            if last_bc.is_nonspacing_mark() {\n                                middle = prior;\n                                continue;\n                            }\n                            let last_mask = if is_ltr { LAST_LTR_MASK } else { LAST_RTL_MASK };\n                            if !last_mask.intersects(last_bc.to_mask()) {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                *last = '\\u{FFFD}';\n                            }\n                            if is_ltr {\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_LTR_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    }\n                                }\n                            } else {\n                                let mut numeral_state = RtlNumeralState::Undecided;\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_RTL_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    } else {\n                                        match numeral_state {\n                                            RtlNumeralState::Undecided => {\n                                                if bc.is_european_number() {\n                                                    numeral_state = RtlNumeralState::European;\n                                                } else if bc.is_arabic_number() {\n                                                    numeral_state = RtlNumeralState::Arabic;\n                                                }\n                                            }\n                                            RtlNumeralState::European => {\n                                                if bc.is_arabic_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                            RtlNumeralState::Arabic => {\n                                                if bc.is_european_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                                if (numeral_state == RtlNumeralState::European\n                                    && last_bc.is_arabic_number())\n                                    || (numeral_state == RtlNumeralState::Arabic\n                                        && last_bc.is_european_number())\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    *last = '\\u{FFFD}';\n                                }\n                            }\n                            break;\n                        } else {\n                            // One-character label or label where\n                            // everything after the first character\n                            // is just non-spacing marks.\n                            break;\n                        }",
)
The code is Ok(
    "middle.split_last_mut()",
)
The code is Ok(
    "middle",
)
The code is Ok(
    "self.data.bidi_class(*last)",
)
The code is Ok(
    "self.data",
)
The code is Ok(
    "self",
)
The code is Ok(
    "*last",
)
The code is Ok(
    "last",
)
The code is Ok(
    "if last_bc.is_nonspacing_mark() {\n                                middle = prior;\n                                continue;\n                            }",
)
The code is Ok(
    "last_bc.is_nonspacing_mark()",
)
The code is Ok(
    "last_bc",
)
The code is Ok(
    "middle = prior",
)
The code is Ok(
    "prior",
)
The code is Ok(
    "middle",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "if is_ltr { LAST_LTR_MASK } else { LAST_RTL_MASK }",
)
The code is Ok(
    "is_ltr",
)
The code is Ok(
    "LAST_LTR_MASK",
)
The code is Ok(
    "LAST_RTL_MASK",
)
The code is Ok(
    "if !last_mask.intersects(last_bc.to_mask()) {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                *last = '\\u{FFFD}';\n                            }",
)
The code is Ok(
    "!last_mask.intersects(last_bc.to_mask())",
)
The code is Ok(
    "last_mask.intersects(last_bc.to_mask())",
)
The code is Ok(
    "last_mask",
)
The code is Ok(
    "last_bc.to_mask()",
)
The code is Ok(
    "last_bc",
)
The code is Ok(
    "if fail_fast {\n                                    return (0, false, true);\n                                }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return (0, false, true)",
)
The code is Ok(
    "(0, false, true)",
)
The code is Ok(
    "0",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "*last = '\\u{FFFD}'",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "*last",
)
The code is Ok(
    "last",
)
The code is Ok(
    "if is_ltr {\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_LTR_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    }\n                                }\n                            } else {\n                                let mut numeral_state = RtlNumeralState::Undecided;\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_RTL_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    } else {\n                                        match numeral_state {\n                                            RtlNumeralState::Undecided => {\n                                                if bc.is_european_number() {\n                                                    numeral_state = RtlNumeralState::European;\n                                                } else if bc.is_arabic_number() {\n                                                    numeral_state = RtlNumeralState::Arabic;\n                                                }\n                                            }\n                                            RtlNumeralState::European => {\n                                                if bc.is_arabic_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                            RtlNumeralState::Arabic => {\n                                                if bc.is_european_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                                if (numeral_state == RtlNumeralState::European\n                                    && last_bc.is_arabic_number())\n                                    || (numeral_state == RtlNumeralState::Arabic\n                                        && last_bc.is_european_number())\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    *last = '\\u{FFFD}';\n                                }\n                            }",
)
The code is Ok(
    "is_ltr",
)
The code is Ok(
    "for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_LTR_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    }\n                                }",
)
The code is Ok(
    "for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_LTR_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    }\n                                }",
)
into Match call
The code is Ok(
    "prior.iter_mut()",
)
LangItem path: idna/src/uts46.rs:1401:42: 1401:58 (#532)
The code is Ok(
    "prior.iter_mut()",
)
The code is Ok(
    "prior.iter_mut()",
)
The code is Ok(
    "prior",
)
The code is Ok(
    "for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_LTR_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    }\n                                }",
)
The code is Ok(
    "prior.iter_mut()",
)
into Match call
is inner Match
The code is Ok(
    "prior.iter_mut()",
)
LangItem path: idna/src/uts46.rs:1401:42: 1401:58 (#532)
The code is Ok(
    "prior.iter_mut()",
)
The code is Ok(
    "prior.iter_mut()",
)
The code is Ok(
    "prior.iter_mut()",
)
The code is Ok(
    "for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_LTR_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    }\n                                }",
)
The code is Ok(
    "{\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_LTR_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    }\n                                }",
)
The code is Ok(
    "self.data.bidi_class(*c)",
)
The code is Ok(
    "self.data",
)
The code is Ok(
    "self",
)
The code is Ok(
    "*c",
)
The code is Ok(
    "c",
)
The code is Ok(
    "if !MIDDLE_LTR_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    }",
)
The code is Ok(
    "!MIDDLE_LTR_MASK.intersects(bc.to_mask())",
)
The code is Ok(
    "MIDDLE_LTR_MASK.intersects(bc.to_mask())",
)
The code is Ok(
    "MIDDLE_LTR_MASK",
)
The code is Ok(
    "bc.to_mask()",
)
The code is Ok(
    "bc",
)
The code is Ok(
    "if fail_fast {\n                                            return (0, false, true);\n                                        }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return (0, false, true)",
)
The code is Ok(
    "(0, false, true)",
)
The code is Ok(
    "0",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "*c = '\\u{FFFD}'",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "*c",
)
The code is Ok(
    "c",
)
The code is Ok(
    "RtlNumeralState::Undecided",
)
The code is Ok(
    "for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_RTL_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    } else {\n                                        match numeral_state {\n                                            RtlNumeralState::Undecided => {\n                                                if bc.is_european_number() {\n                                                    numeral_state = RtlNumeralState::European;\n                                                } else if bc.is_arabic_number() {\n                                                    numeral_state = RtlNumeralState::Arabic;\n                                                }\n                                            }\n                                            RtlNumeralState::European => {\n                                                if bc.is_arabic_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                            RtlNumeralState::Arabic => {\n                                                if bc.is_european_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                        }\n                                    }\n                                }",
)
The code is Ok(
    "for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_RTL_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    } else {\n                                        match numeral_state {\n                                            RtlNumeralState::Undecided => {\n                                                if bc.is_european_number() {\n                                                    numeral_state = RtlNumeralState::European;\n                                                } else if bc.is_arabic_number() {\n                                                    numeral_state = RtlNumeralState::Arabic;\n                                                }\n                                            }\n                                            RtlNumeralState::European => {\n                                                if bc.is_arabic_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                            RtlNumeralState::Arabic => {\n                                                if bc.is_european_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                        }\n                                    }\n                                }",
)
into Match call
The code is Ok(
    "prior.iter_mut()",
)
LangItem path: idna/src/uts46.rs:1413:42: 1413:58 (#537)
The code is Ok(
    "prior.iter_mut()",
)
The code is Ok(
    "prior.iter_mut()",
)
The code is Ok(
    "prior",
)
The code is Ok(
    "for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_RTL_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    } else {\n                                        match numeral_state {\n                                            RtlNumeralState::Undecided => {\n                                                if bc.is_european_number() {\n                                                    numeral_state = RtlNumeralState::European;\n                                                } else if bc.is_arabic_number() {\n                                                    numeral_state = RtlNumeralState::Arabic;\n                                                }\n                                            }\n                                            RtlNumeralState::European => {\n                                                if bc.is_arabic_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                            RtlNumeralState::Arabic => {\n                                                if bc.is_european_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                        }\n                                    }\n                                }",
)
The code is Ok(
    "prior.iter_mut()",
)
into Match call
is inner Match
The code is Ok(
    "prior.iter_mut()",
)
LangItem path: idna/src/uts46.rs:1413:42: 1413:58 (#537)
The code is Ok(
    "prior.iter_mut()",
)
The code is Ok(
    "prior.iter_mut()",
)
The code is Ok(
    "prior.iter_mut()",
)
The code is Ok(
    "for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_RTL_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    } else {\n                                        match numeral_state {\n                                            RtlNumeralState::Undecided => {\n                                                if bc.is_european_number() {\n                                                    numeral_state = RtlNumeralState::European;\n                                                } else if bc.is_arabic_number() {\n                                                    numeral_state = RtlNumeralState::Arabic;\n                                                }\n                                            }\n                                            RtlNumeralState::European => {\n                                                if bc.is_arabic_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                            RtlNumeralState::Arabic => {\n                                                if bc.is_european_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                        }\n                                    }\n                                }",
)
The code is Ok(
    "{\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_RTL_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    } else {\n                                        match numeral_state {\n                                            RtlNumeralState::Undecided => {\n                                                if bc.is_european_number() {\n                                                    numeral_state = RtlNumeralState::European;\n                                                } else if bc.is_arabic_number() {\n                                                    numeral_state = RtlNumeralState::Arabic;\n                                                }\n                                            }\n                                            RtlNumeralState::European => {\n                                                if bc.is_arabic_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                            RtlNumeralState::Arabic => {\n                                                if bc.is_european_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                        }\n                                    }\n                                }",
)
The code is Ok(
    "self.data.bidi_class(*c)",
)
The code is Ok(
    "self.data",
)
The code is Ok(
    "self",
)
The code is Ok(
    "*c",
)
The code is Ok(
    "c",
)
The code is Ok(
    "if !MIDDLE_RTL_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    } else {\n                                        match numeral_state {\n                                            RtlNumeralState::Undecided => {\n                                                if bc.is_european_number() {\n                                                    numeral_state = RtlNumeralState::European;\n                                                } else if bc.is_arabic_number() {\n                                                    numeral_state = RtlNumeralState::Arabic;\n                                                }\n                                            }\n                                            RtlNumeralState::European => {\n                                                if bc.is_arabic_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                            RtlNumeralState::Arabic => {\n                                                if bc.is_european_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                        }\n                                    }",
)
The code is Ok(
    "!MIDDLE_RTL_MASK.intersects(bc.to_mask())",
)
The code is Ok(
    "MIDDLE_RTL_MASK.intersects(bc.to_mask())",
)
The code is Ok(
    "MIDDLE_RTL_MASK",
)
The code is Ok(
    "bc.to_mask()",
)
The code is Ok(
    "bc",
)
The code is Ok(
    "if fail_fast {\n                                            return (0, false, true);\n                                        }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return (0, false, true)",
)
The code is Ok(
    "(0, false, true)",
)
The code is Ok(
    "0",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "*c = '\\u{FFFD}'",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "*c",
)
The code is Ok(
    "c",
)
The code is Ok(
    "match numeral_state {\n                                            RtlNumeralState::Undecided => {\n                                                if bc.is_european_number() {\n                                                    numeral_state = RtlNumeralState::European;\n                                                } else if bc.is_arabic_number() {\n                                                    numeral_state = RtlNumeralState::Arabic;\n                                                }\n                                            }\n                                            RtlNumeralState::European => {\n                                                if bc.is_arabic_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                            RtlNumeralState::Arabic => {\n                                                if bc.is_european_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                        }",
)
The code is Ok(
    "numeral_state",
)
The code is Ok(
    "{\n                                                if bc.is_european_number() {\n                                                    numeral_state = RtlNumeralState::European;\n                                                } else if bc.is_arabic_number() {\n                                                    numeral_state = RtlNumeralState::Arabic;\n                                                }\n                                            }",
)
The code is Ok(
    "if bc.is_european_number() {\n                                                    numeral_state = RtlNumeralState::European;\n                                                } else if bc.is_arabic_number() {\n                                                    numeral_state = RtlNumeralState::Arabic;\n                                                }",
)
The code is Ok(
    "bc.is_european_number()",
)
The code is Ok(
    "bc",
)
The code is Ok(
    "numeral_state = RtlNumeralState::European",
)
The code is Ok(
    "RtlNumeralState::European",
)
The code is Ok(
    "numeral_state",
)
The code is Ok(
    "bc.is_arabic_number()",
)
The code is Ok(
    "bc.is_arabic_number()",
)
The code is Ok(
    "bc",
)
The code is Ok(
    "{\n                                                    numeral_state = RtlNumeralState::Arabic;\n                                                }",
)
The code is Ok(
    "numeral_state = RtlNumeralState::Arabic",
)
The code is Ok(
    "RtlNumeralState::Arabic",
)
The code is Ok(
    "numeral_state",
)
The code is Ok(
    "{\n                                                if bc.is_arabic_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }",
)
The code is Ok(
    "if bc.is_arabic_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }",
)
The code is Ok(
    "bc.is_arabic_number()",
)
The code is Ok(
    "bc",
)
The code is Ok(
    "if fail_fast {\n                                                        return (0, false, true);\n                                                    }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return (0, false, true)",
)
The code is Ok(
    "(0, false, true)",
)
The code is Ok(
    "0",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "*c = '\\u{FFFD}'",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "*c",
)
The code is Ok(
    "c",
)
The code is Ok(
    "{\n                                                if bc.is_european_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }",
)
The code is Ok(
    "if bc.is_european_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }",
)
The code is Ok(
    "bc.is_european_number()",
)
The code is Ok(
    "bc",
)
The code is Ok(
    "if fail_fast {\n                                                        return (0, false, true);\n                                                    }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return (0, false, true)",
)
The code is Ok(
    "(0, false, true)",
)
The code is Ok(
    "0",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "*c = '\\u{FFFD}'",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "*c",
)
The code is Ok(
    "c",
)
The code is Ok(
    "if (numeral_state == RtlNumeralState::European\n                                    && last_bc.is_arabic_number())\n                                    || (numeral_state == RtlNumeralState::Arabic\n                                        && last_bc.is_european_number())\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    *last = '\\u{FFFD}';\n                                }",
)
The code is Ok(
    "(numeral_state == RtlNumeralState::European\n                                    && last_bc.is_arabic_number())\n                                    || (numeral_state == RtlNumeralState::Arabic\n                                        && last_bc.is_european_number())",
)
The code is Ok(
    "(numeral_state == RtlNumeralState::European\n                                    && last_bc.is_arabic_number())",
)
The code is Ok(
    "numeral_state == RtlNumeralState::European",
)
The code is Ok(
    "numeral_state",
)
The code is Ok(
    "RtlNumeralState::European",
)
The code is Ok(
    "last_bc.is_arabic_number()",
)
The code is Ok(
    "last_bc",
)
The code is Ok(
    "(numeral_state == RtlNumeralState::Arabic\n                                        && last_bc.is_european_number())",
)
The code is Ok(
    "numeral_state == RtlNumeralState::Arabic",
)
The code is Ok(
    "numeral_state",
)
The code is Ok(
    "RtlNumeralState::Arabic",
)
The code is Ok(
    "last_bc.is_european_number()",
)
The code is Ok(
    "last_bc",
)
The code is Ok(
    "if fail_fast {\n                                        return (0, false, true);\n                                    }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return (0, false, true)",
)
The code is Ok(
    "(0, false, true)",
)
The code is Ok(
    "0",
)
The code is Ok(
    "false",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "*last = '\\u{FFFD}'",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "*last",
)
The code is Ok(
    "last",
)
The code is Ok(
    "break",
)
The code is Ok(
    "break",
)
The code is Ok(
    "(passthrough_up_to, is_bidi, had_errors)",
)
The code is Ok(
    "passthrough_up_to",
)
The code is Ok(
    "is_bidi",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "253",
)
The code is Ok(
    "{\n        for c in self\n            .data\n            .normalize_validate(label_buffer.iter().copied())\n            .map(|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list_deny_dot))\n        {\n            if c == '\\u{FFFD}' {\n                if fail_fast {\n                    return true;\n                }\n                *had_errors = true;\n            }\n            domain_buffer.push(c);\n        }\n        let normalized = &mut domain_buffer[current_label_start..];\n        if let Err(()) =\n            normalized\n                .iter_mut()\n                .zip(label_buffer.iter())\n                .try_for_each(|(norm_c, decoded_c)| {\n                    if *norm_c == *decoded_c {\n                        Ok(())\n                    } else {\n                        // Mark the first difference\n                        *norm_c = '\\u{FFFD}';\n                        Err(())\n                    }\n                })\n        {\n            if fail_fast {\n                return true;\n            }\n            *had_errors = true;\n        }\n        false\n    }",
)
The code is Ok(
    "for c in self\n            .data\n            .normalize_validate(label_buffer.iter().copied())\n            .map(|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list_deny_dot))\n        {\n            if c == '\\u{FFFD}' {\n                if fail_fast {\n                    return true;\n                }\n                *had_errors = true;\n            }\n            domain_buffer.push(c);\n        }",
)
The code is Ok(
    "for c in self\n            .data\n            .normalize_validate(label_buffer.iter().copied())\n            .map(|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list_deny_dot))\n        {\n            if c == '\\u{FFFD}' {\n                if fail_fast {\n                    return true;\n                }\n                *had_errors = true;\n            }\n            domain_buffer.push(c);\n        }",
)
into Match call
The code is Ok(
    "self\n            .data\n            .normalize_validate(label_buffer.iter().copied())\n            .map(|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list_deny_dot))",
)
LangItem path: idna/src/uts46.rs:1488:18: 1491:90 (#550)
The code is Ok(
    "self\n            .data\n            .normalize_validate(label_buffer.iter().copied())\n            .map(|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list_deny_dot))",
)
The code is Ok(
    "self\n            .data\n            .normalize_validate(label_buffer.iter().copied())\n            .map(|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list_deny_dot))",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:210 ~ idna[bc6b]::uts46::{impl#4}::after_punycode_decode).15),
    call_expr_span: idna/src/uts46.rs:1488:18: 1491:90 (#0),
    caller: Some(
        DefId(0:210 ~ idna[bc6b]::uts46::{impl#4}::after_punycode_decode),
    ),
    caller_span: None,
    callee: DefId(1:8518 ~ core[f118]::iter::traits::iterator::Iterator::map),
    callee_span: idna/src/uts46.rs:1488:18: 1491:90 (#0),
    callee_path: "core::iter::Iterator::map",
    constraint_depth: 1,
}
The code is Ok(
    "self\n            .data\n            .normalize_validate(label_buffer.iter().copied())",
)
The code is Ok(
    "self\n            .data",
)
The code is Ok(
    "self",
)
The code is Ok(
    "label_buffer.iter().copied()",
)
The code is Ok(
    "label_buffer.iter()",
)
The code is Ok(
    "label_buffer",
)
The code is Ok(
    "|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list_deny_dot)",
)
The code is Ok(
    "apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list_deny_dot)",
)
resolved new call Call { call_expr: HirId(DefId(0:210 ~ idna[bc6b]::uts46::{impl#4}::after_punycode_decode).31), call_expr_span: idna/src/uts46.rs:1491:22: 1491:89 (#0), caller: Some(DefId(0:210 ~ idna[bc6b]::uts46::{impl#4}::after_punycode_decode)), caller_span: None, callee: DefId(0:153 ~ idna[bc6b]::uts46::apply_ascii_deny_list_to_lower_cased_unicode), callee_span: idna/src/uts46.rs:1491:22: 1491:66 (#0), callee_path: "uts46::apply_ascii_deny_list_to_lower_cased_unicode", constraint_depth: 1 }
The code is Ok(
    "apply_ascii_deny_list_to_lower_cased_unicode",
)
The code is Ok(
    "c",
)
The code is Ok(
    "deny_list_deny_dot",
)
The code is Ok(
    "for c in self\n            .data\n            .normalize_validate(label_buffer.iter().copied())\n            .map(|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list_deny_dot))\n        {\n            if c == '\\u{FFFD}' {\n                if fail_fast {\n                    return true;\n                }\n                *had_errors = true;\n            }\n            domain_buffer.push(c);\n        }",
)
The code is Ok(
    "self\n            .data\n            .normalize_validate(label_buffer.iter().copied())\n            .map(|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list_deny_dot))",
)
into Match call
is inner Match
The code is Ok(
    "self\n            .data\n            .normalize_validate(label_buffer.iter().copied())\n            .map(|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list_deny_dot))",
)
LangItem path: idna/src/uts46.rs:1488:18: 1491:90 (#550)
The code is Ok(
    "self\n            .data\n            .normalize_validate(label_buffer.iter().copied())\n            .map(|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list_deny_dot))",
)
The code is Ok(
    "self\n            .data\n            .normalize_validate(label_buffer.iter().copied())\n            .map(|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list_deny_dot))",
)
The code is Ok(
    "self\n            .data\n            .normalize_validate(label_buffer.iter().copied())\n            .map(|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list_deny_dot))",
)
The code is Ok(
    "for c in self\n            .data\n            .normalize_validate(label_buffer.iter().copied())\n            .map(|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list_deny_dot))\n        {\n            if c == '\\u{FFFD}' {\n                if fail_fast {\n                    return true;\n                }\n                *had_errors = true;\n            }\n            domain_buffer.push(c);\n        }",
)
The code is Ok(
    "{\n            if c == '\\u{FFFD}' {\n                if fail_fast {\n                    return true;\n                }\n                *had_errors = true;\n            }\n            domain_buffer.push(c);\n        }",
)
The code is Ok(
    "if c == '\\u{FFFD}' {\n                if fail_fast {\n                    return true;\n                }\n                *had_errors = true;\n            }",
)
The code is Ok(
    "c == '\\u{FFFD}'",
)
The code is Ok(
    "c",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "if fail_fast {\n                    return true;\n                }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "*had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "*had_errors",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "domain_buffer.push(c)",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "c",
)
The code is Ok(
    "&mut domain_buffer[current_label_start..]",
)
The code is Ok(
    "domain_buffer[current_label_start..]",
)
The code is Ok(
    "domain_buffer",
)
The code is Ok(
    "current_label_start..",
)
The code is Ok(
    "current_label_start",
)
The code is Ok(
    "if let Err(()) =\n            normalized\n                .iter_mut()\n                .zip(label_buffer.iter())\n                .try_for_each(|(norm_c, decoded_c)| {\n                    if *norm_c == *decoded_c {\n                        Ok(())\n                    } else {\n                        // Mark the first difference\n                        *norm_c = '\\u{FFFD}';\n                        Err(())\n                    }\n                })\n        {\n            if fail_fast {\n                return true;\n            }\n            *had_errors = true;\n        }",
)
The code is Ok(
    "normalized\n                .iter_mut()\n                .zip(label_buffer.iter())\n                .try_for_each(|(norm_c, decoded_c)| {\n                    if *norm_c == *decoded_c {\n                        Ok(())\n                    } else {\n                        // Mark the first difference\n                        *norm_c = '\\u{FFFD}';\n                        Err(())\n                    }\n                })",
)
The code is Ok(
    "normalized\n                .iter_mut()\n                .zip(label_buffer.iter())",
)
The code is Ok(
    "normalized\n                .iter_mut()",
)
The code is Ok(
    "normalized",
)
The code is Ok(
    "label_buffer.iter()",
)
The code is Ok(
    "label_buffer",
)
The code is Ok(
    "|(norm_c, decoded_c)| {\n                    if *norm_c == *decoded_c {\n                        Ok(())\n                    } else {\n                        // Mark the first difference\n                        *norm_c = '\\u{FFFD}';\n                        Err(())\n                    }\n                }",
)
The code is Ok(
    "{\n                    if *norm_c == *decoded_c {\n                        Ok(())\n                    } else {\n                        // Mark the first difference\n                        *norm_c = '\\u{FFFD}';\n                        Err(())\n                    }\n                }",
)
The code is Ok(
    "if *norm_c == *decoded_c {\n                        Ok(())\n                    } else {\n                        // Mark the first difference\n                        *norm_c = '\\u{FFFD}';\n                        Err(())\n                    }",
)
The code is Ok(
    "*norm_c == *decoded_c",
)
The code is Ok(
    "*norm_c",
)
The code is Ok(
    "norm_c",
)
The code is Ok(
    "*decoded_c",
)
The code is Ok(
    "decoded_c",
)
The code is Ok(
    "Ok(())",
)
resolved new call Call { call_expr: HirId(DefId(0:210 ~ idna[bc6b]::uts46::{impl#4}::after_punycode_decode).139), call_expr_span: idna/src/uts46.rs:1508:25: 1508:31 (#0), caller: Some(DefId(0:210 ~ idna[bc6b]::uts46::{impl#4}::after_punycode_decode)), caller_span: None, callee: DefId(1:45569 ~ core[f118]::result::Result::Ok::{constructor#0}), callee_span: idna/src/uts46.rs:1508:25: 1508:27 (#0), callee_path: "core::prelude::v1::Ok", constraint_depth: 1 }
The code is Ok(
    "Ok",
)
The code is Ok(
    "()",
)
The code is Ok(
    "*norm_c = '\\u{FFFD}'",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "*norm_c",
)
The code is Ok(
    "norm_c",
)
The code is Ok(
    "Err(())",
)
resolved new call Call { call_expr: HirId(DefId(0:210 ~ idna[bc6b]::uts46::{impl#4}::after_punycode_decode).152), call_expr_span: idna/src/uts46.rs:1512:25: 1512:32 (#0), caller: Some(DefId(0:210 ~ idna[bc6b]::uts46::{impl#4}::after_punycode_decode)), caller_span: None, callee: DefId(1:45572 ~ core[f118]::result::Result::Err::{constructor#0}), callee_span: idna/src/uts46.rs:1512:25: 1512:28 (#0), callee_path: "core::prelude::v1::Err", constraint_depth: 1 }
The code is Ok(
    "Err",
)
The code is Ok(
    "()",
)
The code is Ok(
    "if fail_fast {\n                return true;\n            }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "*had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "*had_errors",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "false",
)
The code is Ok(
    "{\n        if hyphens != Hyphens::Allow\n            && check_hyphens(\n                mut_label,\n                hyphens == Hyphens::CheckFirstLast,\n                fail_fast,\n                had_errors,\n            )\n        {\n            return true;\n        }\n        if first_needs_combining_mark_check {\n            if let Some(first) = mut_label.first_mut() {\n                if self.data.is_mark(*first) {\n                    if fail_fast {\n                        return true;\n                    }\n                    *had_errors = true;\n                    *first = '\\u{FFFD}';\n                }\n            }\n        }\n        if needs_contextj_check {\n            // ContextJ\n            for i in 0..mut_label.len() {\n                let c = mut_label[i];\n                if !in_inclusive_range_char(c, '\\u{200C}', '\\u{200D}') {\n                    continue;\n                }\n                let (head, joiner_and_tail) = mut_label.split_at_mut(i);\n\n                if let Some((joiner, tail)) = joiner_and_tail.split_first_mut() {\n                    if let Some(previous) = head.last() {\n                        if self.data.is_virama(*previous) {\n                            continue;\n                        }\n                    } else {\n                        // No preceding character\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                        continue;\n                    }\n                    if c == '\\u{200D}' {\n                        // ZWJ only has the virama rule\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                        continue;\n                    }\n                    debug_assert_eq!(c, '\\u{200C}');\n                    if !self.has_appropriately_joining_char(\n                        head.iter().rev().copied(),\n                        LEFT_OR_DUAL_JOINING_MASK,\n                    ) || !self.has_appropriately_joining_char(\n                        tail.iter().copied(),\n                        RIGHT_OR_DUAL_JOINING_MASK,\n                    ) {\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                    }\n                } else {\n                    debug_assert!(false);\n                }\n            }\n        }\n\n        if !is_ascii(mut_label) && mut_label.len() > PUNYCODE_ENCODE_MAX_INPUT_LENGTH {\n            // Limit quadratic behavior\n            // https://github.com/whatwg/url/issues/824\n            // https://unicode-org.atlassian.net/browse/ICU-13727\n            if fail_fast {\n                return true;\n            }\n            *had_errors = true;\n            mut_label[PUNYCODE_ENCODE_MAX_INPUT_LENGTH] = '\\u{FFFD}';\n        }\n        false\n    }",
)
The code is Ok(
    "if hyphens != Hyphens::Allow\n            && check_hyphens(\n                mut_label,\n                hyphens == Hyphens::CheckFirstLast,\n                fail_fast,\n                had_errors,\n            )\n        {\n            return true;\n        }",
)
The code is Ok(
    "hyphens != Hyphens::Allow\n            && check_hyphens(\n                mut_label,\n                hyphens == Hyphens::CheckFirstLast,\n                fail_fast,\n                had_errors,\n            )",
)
The code is Ok(
    "hyphens != Hyphens::Allow",
)
The code is Ok(
    "hyphens",
)
The code is Ok(
    "Hyphens::Allow",
)
The code is Ok(
    "check_hyphens(\n                mut_label,\n                hyphens == Hyphens::CheckFirstLast,\n                fail_fast,\n                had_errors,\n            )",
)
resolved new call Call { call_expr: HirId(DefId(0:214 ~ idna[bc6b]::uts46::{impl#4}::check_label).23), call_expr_span: idna/src/uts46.rs:1535:16: 1540:14 (#0), caller: Some(DefId(0:214 ~ idna[bc6b]::uts46::{impl#4}::check_label)), caller_span: None, callee: DefId(0:218 ~ idna[bc6b]::uts46::check_hyphens), callee_span: idna/src/uts46.rs:1535:16: 1535:29 (#0), callee_path: "uts46::check_hyphens", constraint_depth: 1 }
The code is Ok(
    "check_hyphens",
)
The code is Ok(
    "mut_label",
)
The code is Ok(
    "hyphens == Hyphens::CheckFirstLast",
)
The code is Ok(
    "hyphens",
)
The code is Ok(
    "Hyphens::CheckFirstLast",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "return true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "if first_needs_combining_mark_check {\n            if let Some(first) = mut_label.first_mut() {\n                if self.data.is_mark(*first) {\n                    if fail_fast {\n                        return true;\n                    }\n                    *had_errors = true;\n                    *first = '\\u{FFFD}';\n                }\n            }\n        }",
)
The code is Ok(
    "first_needs_combining_mark_check",
)
The code is Ok(
    "if let Some(first) = mut_label.first_mut() {\n                if self.data.is_mark(*first) {\n                    if fail_fast {\n                        return true;\n                    }\n                    *had_errors = true;\n                    *first = '\\u{FFFD}';\n                }\n            }",
)
The code is Ok(
    "mut_label.first_mut()",
)
The code is Ok(
    "mut_label",
)
The code is Ok(
    "if self.data.is_mark(*first) {\n                    if fail_fast {\n                        return true;\n                    }\n                    *had_errors = true;\n                    *first = '\\u{FFFD}';\n                }",
)
The code is Ok(
    "self.data.is_mark(*first)",
)
The code is Ok(
    "self.data",
)
The code is Ok(
    "self",
)
The code is Ok(
    "*first",
)
The code is Ok(
    "first",
)
The code is Ok(
    "if fail_fast {\n                        return true;\n                    }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "*had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "*had_errors",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "*first = '\\u{FFFD}'",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "*first",
)
The code is Ok(
    "first",
)
The code is Ok(
    "if needs_contextj_check {\n            // ContextJ\n            for i in 0..mut_label.len() {\n                let c = mut_label[i];\n                if !in_inclusive_range_char(c, '\\u{200C}', '\\u{200D}') {\n                    continue;\n                }\n                let (head, joiner_and_tail) = mut_label.split_at_mut(i);\n\n                if let Some((joiner, tail)) = joiner_and_tail.split_first_mut() {\n                    if let Some(previous) = head.last() {\n                        if self.data.is_virama(*previous) {\n                            continue;\n                        }\n                    } else {\n                        // No preceding character\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                        continue;\n                    }\n                    if c == '\\u{200D}' {\n                        // ZWJ only has the virama rule\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                        continue;\n                    }\n                    debug_assert_eq!(c, '\\u{200C}');\n                    if !self.has_appropriately_joining_char(\n                        head.iter().rev().copied(),\n                        LEFT_OR_DUAL_JOINING_MASK,\n                    ) || !self.has_appropriately_joining_char(\n                        tail.iter().copied(),\n                        RIGHT_OR_DUAL_JOINING_MASK,\n                    ) {\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                    }\n                } else {\n                    debug_assert!(false);\n                }\n            }\n        }",
)
The code is Ok(
    "needs_contextj_check",
)
The code is Ok(
    "for i in 0..mut_label.len() {\n                let c = mut_label[i];\n                if !in_inclusive_range_char(c, '\\u{200C}', '\\u{200D}') {\n                    continue;\n                }\n                let (head, joiner_and_tail) = mut_label.split_at_mut(i);\n\n                if let Some((joiner, tail)) = joiner_and_tail.split_first_mut() {\n                    if let Some(previous) = head.last() {\n                        if self.data.is_virama(*previous) {\n                            continue;\n                        }\n                    } else {\n                        // No preceding character\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                        continue;\n                    }\n                    if c == '\\u{200D}' {\n                        // ZWJ only has the virama rule\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                        continue;\n                    }\n                    debug_assert_eq!(c, '\\u{200C}');\n                    if !self.has_appropriately_joining_char(\n                        head.iter().rev().copied(),\n                        LEFT_OR_DUAL_JOINING_MASK,\n                    ) || !self.has_appropriately_joining_char(\n                        tail.iter().copied(),\n                        RIGHT_OR_DUAL_JOINING_MASK,\n                    ) {\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                    }\n                } else {\n                    debug_assert!(false);\n                }\n            }",
)
The code is Ok(
    "for i in 0..mut_label.len() {\n                let c = mut_label[i];\n                if !in_inclusive_range_char(c, '\\u{200C}', '\\u{200D}') {\n                    continue;\n                }\n                let (head, joiner_and_tail) = mut_label.split_at_mut(i);\n\n                if let Some((joiner, tail)) = joiner_and_tail.split_first_mut() {\n                    if let Some(previous) = head.last() {\n                        if self.data.is_virama(*previous) {\n                            continue;\n                        }\n                    } else {\n                        // No preceding character\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                        continue;\n                    }\n                    if c == '\\u{200D}' {\n                        // ZWJ only has the virama rule\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                        continue;\n                    }\n                    debug_assert_eq!(c, '\\u{200C}');\n                    if !self.has_appropriately_joining_char(\n                        head.iter().rev().copied(),\n                        LEFT_OR_DUAL_JOINING_MASK,\n                    ) || !self.has_appropriately_joining_char(\n                        tail.iter().copied(),\n                        RIGHT_OR_DUAL_JOINING_MASK,\n                    ) {\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                    }\n                } else {\n                    debug_assert!(false);\n                }\n            }",
)
into Match call
The code is Ok(
    "0..mut_label.len()",
)
LangItem path: idna/src/uts46.rs:1557:22: 1557:40 (#562)
The code is Ok(
    "0..mut_label.len()",
)
The code is Ok(
    "0..mut_label.len()",
)
The code is Ok(
    "0",
)
The code is Ok(
    "mut_label.len()",
)
The code is Ok(
    "mut_label",
)
The code is Ok(
    "for i in 0..mut_label.len() {\n                let c = mut_label[i];\n                if !in_inclusive_range_char(c, '\\u{200C}', '\\u{200D}') {\n                    continue;\n                }\n                let (head, joiner_and_tail) = mut_label.split_at_mut(i);\n\n                if let Some((joiner, tail)) = joiner_and_tail.split_first_mut() {\n                    if let Some(previous) = head.last() {\n                        if self.data.is_virama(*previous) {\n                            continue;\n                        }\n                    } else {\n                        // No preceding character\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                        continue;\n                    }\n                    if c == '\\u{200D}' {\n                        // ZWJ only has the virama rule\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                        continue;\n                    }\n                    debug_assert_eq!(c, '\\u{200C}');\n                    if !self.has_appropriately_joining_char(\n                        head.iter().rev().copied(),\n                        LEFT_OR_DUAL_JOINING_MASK,\n                    ) || !self.has_appropriately_joining_char(\n                        tail.iter().copied(),\n                        RIGHT_OR_DUAL_JOINING_MASK,\n                    ) {\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                    }\n                } else {\n                    debug_assert!(false);\n                }\n            }",
)
The code is Ok(
    "0..mut_label.len()",
)
into Match call
is inner Match
The code is Ok(
    "0..mut_label.len()",
)
LangItem path: idna/src/uts46.rs:1557:22: 1557:40 (#562)
The code is Ok(
    "0..mut_label.len()",
)
The code is Ok(
    "0..mut_label.len()",
)
The code is Ok(
    "0..mut_label.len()",
)
The code is Ok(
    "for i in 0..mut_label.len() {\n                let c = mut_label[i];\n                if !in_inclusive_range_char(c, '\\u{200C}', '\\u{200D}') {\n                    continue;\n                }\n                let (head, joiner_and_tail) = mut_label.split_at_mut(i);\n\n                if let Some((joiner, tail)) = joiner_and_tail.split_first_mut() {\n                    if let Some(previous) = head.last() {\n                        if self.data.is_virama(*previous) {\n                            continue;\n                        }\n                    } else {\n                        // No preceding character\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                        continue;\n                    }\n                    if c == '\\u{200D}' {\n                        // ZWJ only has the virama rule\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                        continue;\n                    }\n                    debug_assert_eq!(c, '\\u{200C}');\n                    if !self.has_appropriately_joining_char(\n                        head.iter().rev().copied(),\n                        LEFT_OR_DUAL_JOINING_MASK,\n                    ) || !self.has_appropriately_joining_char(\n                        tail.iter().copied(),\n                        RIGHT_OR_DUAL_JOINING_MASK,\n                    ) {\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                    }\n                } else {\n                    debug_assert!(false);\n                }\n            }",
)
The code is Ok(
    "{\n                let c = mut_label[i];\n                if !in_inclusive_range_char(c, '\\u{200C}', '\\u{200D}') {\n                    continue;\n                }\n                let (head, joiner_and_tail) = mut_label.split_at_mut(i);\n\n                if let Some((joiner, tail)) = joiner_and_tail.split_first_mut() {\n                    if let Some(previous) = head.last() {\n                        if self.data.is_virama(*previous) {\n                            continue;\n                        }\n                    } else {\n                        // No preceding character\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                        continue;\n                    }\n                    if c == '\\u{200D}' {\n                        // ZWJ only has the virama rule\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                        continue;\n                    }\n                    debug_assert_eq!(c, '\\u{200C}');\n                    if !self.has_appropriately_joining_char(\n                        head.iter().rev().copied(),\n                        LEFT_OR_DUAL_JOINING_MASK,\n                    ) || !self.has_appropriately_joining_char(\n                        tail.iter().copied(),\n                        RIGHT_OR_DUAL_JOINING_MASK,\n                    ) {\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                    }\n                } else {\n                    debug_assert!(false);\n                }\n            }",
)
The code is Ok(
    "mut_label[i]",
)
The code is Ok(
    "mut_label",
)
The code is Ok(
    "i",
)
The code is Ok(
    "if !in_inclusive_range_char(c, '\\u{200C}', '\\u{200D}') {\n                    continue;\n                }",
)
The code is Ok(
    "!in_inclusive_range_char(c, '\\u{200C}', '\\u{200D}')",
)
The code is Ok(
    "in_inclusive_range_char(c, '\\u{200C}', '\\u{200D}')",
)
resolved new call Call { call_expr: HirId(DefId(0:214 ~ idna[bc6b]::uts46::{impl#4}::check_label).126), call_expr_span: idna/src/uts46.rs:1559:21: 1559:71 (#0), caller: Some(DefId(0:214 ~ idna[bc6b]::uts46::{impl#4}::check_label)), caller_span: None, callee: DefId(0:149 ~ idna[bc6b]::uts46::in_inclusive_range_char), callee_span: idna/src/uts46.rs:1559:21: 1559:44 (#0), callee_path: "uts46::in_inclusive_range_char", constraint_depth: 1 }
The code is Ok(
    "in_inclusive_range_char",
)
The code is Ok(
    "c",
)
The code is Ok(
    "'\\u{200C}'",
)
The code is Ok(
    "'\\u{200D}'",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "mut_label.split_at_mut(i)",
)
The code is Ok(
    "mut_label",
)
The code is Ok(
    "i",
)
The code is Ok(
    "if let Some((joiner, tail)) = joiner_and_tail.split_first_mut() {\n                    if let Some(previous) = head.last() {\n                        if self.data.is_virama(*previous) {\n                            continue;\n                        }\n                    } else {\n                        // No preceding character\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                        continue;\n                    }\n                    if c == '\\u{200D}' {\n                        // ZWJ only has the virama rule\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                        continue;\n                    }\n                    debug_assert_eq!(c, '\\u{200C}');\n                    if !self.has_appropriately_joining_char(\n                        head.iter().rev().copied(),\n                        LEFT_OR_DUAL_JOINING_MASK,\n                    ) || !self.has_appropriately_joining_char(\n                        tail.iter().copied(),\n                        RIGHT_OR_DUAL_JOINING_MASK,\n                    ) {\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                    }\n                } else {\n                    debug_assert!(false);\n                }",
)
The code is Ok(
    "joiner_and_tail.split_first_mut()",
)
The code is Ok(
    "joiner_and_tail",
)
The code is Ok(
    "if let Some(previous) = head.last() {\n                        if self.data.is_virama(*previous) {\n                            continue;\n                        }\n                    } else {\n                        // No preceding character\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                        continue;\n                    }",
)
The code is Ok(
    "head.last()",
)
The code is Ok(
    "head",
)
The code is Ok(
    "if self.data.is_virama(*previous) {\n                            continue;\n                        }",
)
The code is Ok(
    "self.data.is_virama(*previous)",
)
The code is Ok(
    "self.data",
)
The code is Ok(
    "self",
)
The code is Ok(
    "*previous",
)
The code is Ok(
    "previous",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "if fail_fast {\n                            return true;\n                        }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "*had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "*had_errors",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "*joiner = '\\u{FFFD}'",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "*joiner",
)
The code is Ok(
    "joiner",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "if c == '\\u{200D}' {\n                        // ZWJ only has the virama rule\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                        continue;\n                    }",
)
The code is Ok(
    "c == '\\u{200D}'",
)
The code is Ok(
    "c",
)
The code is Ok(
    "'\\u{200D}'",
)
The code is Ok(
    "if fail_fast {\n                            return true;\n                        }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "*had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "*had_errors",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "*joiner = '\\u{FFFD}'",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "*joiner",
)
The code is Ok(
    "joiner",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "if $crate::cfg!(debug_assertions) {\n            $crate::assert_eq!($($arg)*);\n        }",
)
The code is Ok(
    "$crate::cfg!(debug_assertions)",
)
The code is Ok(
    "match (&$left, &$right) {\n            (left_val, right_val) => {\n                if !(*left_val == *right_val) {\n                    let kind = $crate::panicking::AssertKind::Eq;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }\n            }\n        }",
)
The code is Ok(
    "(&$left, &$right)",
)
The code is Ok(
    "&$left",
)
The code is Ok(
    "c",
)
The code is Ok(
    "&$right",
)
The code is Ok(
    "'\\u{200C}'",
)
The code is Ok(
    "{\n                if !(*left_val == *right_val) {\n                    let kind = $crate::panicking::AssertKind::Eq;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }\n            }",
)
The code is Ok(
    "if !(*left_val == *right_val) {\n                    let kind = $crate::panicking::AssertKind::Eq;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }",
)
The code is Ok(
    "!(*left_val == *right_val)",
)
The code is Ok(
    "(*left_val == *right_val)",
)
The code is Ok(
    "*left_val",
)
The code is Ok(
    "left_val",
)
The code is Ok(
    "*right_val",
)
The code is Ok(
    "right_val",
)
The code is Ok(
    "$crate::panicking::AssertKind::Eq",
)
The code is Ok(
    "$crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None)",
)
resolved new call Call { call_expr: HirId(DefId(0:214 ~ idna[bc6b]::uts46::{impl#4}::check_label).279), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:51:21: 51:114 (#158), caller: Some(DefId(0:214 ~ idna[bc6b]::uts46::{impl#4}::check_label)), caller_span: None, callee: DefId(1:9590 ~ core[f118]::panicking::assert_failed), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:51:21: 51:53 (#158), callee_path: "core::panicking::assert_failed", constraint_depth: 3 }
The code is Ok(
    "$crate::panicking::assert_failed",
)
The code is Ok(
    "kind",
)
The code is Ok(
    "&*left_val",
)
The code is Ok(
    "*left_val",
)
The code is Ok(
    "left_val",
)
The code is Ok(
    "&*right_val",
)
The code is Ok(
    "*right_val",
)
The code is Ok(
    "right_val",
)
The code is Ok(
    "$crate::option::Option::None",
)
The code is Ok(
    "if !self.has_appropriately_joining_char(\n                        head.iter().rev().copied(),\n                        LEFT_OR_DUAL_JOINING_MASK,\n                    ) || !self.has_appropriately_joining_char(\n                        tail.iter().copied(),\n                        RIGHT_OR_DUAL_JOINING_MASK,\n                    ) {\n                        if fail_fast {\n                            return true;\n                        }\n                        *had_errors = true;\n                        *joiner = '\\u{FFFD}';\n                    }",
)
The code is Ok(
    "!self.has_appropriately_joining_char(\n                        head.iter().rev().copied(),\n                        LEFT_OR_DUAL_JOINING_MASK,\n                    ) || !self.has_appropriately_joining_char(\n                        tail.iter().copied(),\n                        RIGHT_OR_DUAL_JOINING_MASK,\n                    )",
)
The code is Ok(
    "!self.has_appropriately_joining_char(\n                        head.iter().rev().copied(),\n                        LEFT_OR_DUAL_JOINING_MASK,\n                    )",
)
The code is Ok(
    "self.has_appropriately_joining_char(\n                        head.iter().rev().copied(),\n                        LEFT_OR_DUAL_JOINING_MASK,\n                    )",
)
The code is Ok(
    "self",
)
The code is Ok(
    "head.iter().rev().copied()",
)
The code is Ok(
    "head.iter().rev()",
)
The code is Ok(
    "head.iter()",
)
The code is Ok(
    "head",
)
The code is Ok(
    "LEFT_OR_DUAL_JOINING_MASK",
)
The code is Ok(
    "!self.has_appropriately_joining_char(\n                        tail.iter().copied(),\n                        RIGHT_OR_DUAL_JOINING_MASK,\n                    )",
)
The code is Ok(
    "self.has_appropriately_joining_char(\n                        tail.iter().copied(),\n                        RIGHT_OR_DUAL_JOINING_MASK,\n                    )",
)
The code is Ok(
    "self",
)
The code is Ok(
    "tail.iter().copied()",
)
The code is Ok(
    "tail.iter()",
)
The code is Ok(
    "tail",
)
The code is Ok(
    "RIGHT_OR_DUAL_JOINING_MASK",
)
The code is Ok(
    "if fail_fast {\n                            return true;\n                        }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "*had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "*had_errors",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "*joiner = '\\u{FFFD}'",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "*joiner",
)
The code is Ok(
    "joiner",
)
The code is Ok(
    "if $crate::cfg!(debug_assertions) {\n            $crate::assert!($($arg)*);\n        }",
)
The code is Ok(
    "$crate::cfg!(debug_assertions)",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "false",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
resolved new call Call { call_expr: HirId(DefId(0:214 ~ idna[bc6b]::uts46::{impl#4}::check_label).372), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:335:13: 335:38 (#161), caller: Some(DefId(0:214 ~ idna[bc6b]::uts46::{impl#4}::check_label)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:335:13: 335:13 (#161), callee_path: "core::panicking::panic", constraint_depth: 2 }
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "",
)
The code is Ok(
    "if !is_ascii(mut_label) && mut_label.len() > PUNYCODE_ENCODE_MAX_INPUT_LENGTH {\n            // Limit quadratic behavior\n            // https://github.com/whatwg/url/issues/824\n            // https://unicode-org.atlassian.net/browse/ICU-13727\n            if fail_fast {\n                return true;\n            }\n            *had_errors = true;\n            mut_label[PUNYCODE_ENCODE_MAX_INPUT_LENGTH] = '\\u{FFFD}';\n        }",
)
The code is Ok(
    "!is_ascii(mut_label) && mut_label.len() > PUNYCODE_ENCODE_MAX_INPUT_LENGTH",
)
The code is Ok(
    "!is_ascii(mut_label)",
)
The code is Ok(
    "is_ascii(mut_label)",
)
resolved new call Call { call_expr: HirId(DefId(0:214 ~ idna[bc6b]::uts46::{impl#4}::check_label).408), call_expr_span: idna/src/uts46.rs:1607:13: 1607:32 (#0), caller: Some(DefId(0:214 ~ idna[bc6b]::uts46::{impl#4}::check_label)), caller_span: None, callee: DefId(0:155 ~ idna[bc6b]::uts46::is_ascii), callee_span: idna/src/uts46.rs:1607:13: 1607:21 (#0), callee_path: "uts46::is_ascii", constraint_depth: 0 }
The code is Ok(
    "is_ascii",
)
The code is Ok(
    "mut_label",
)
The code is Ok(
    "mut_label.len() > PUNYCODE_ENCODE_MAX_INPUT_LENGTH",
)
The code is Ok(
    "mut_label.len()",
)
The code is Ok(
    "mut_label",
)
The code is Ok(
    "PUNYCODE_ENCODE_MAX_INPUT_LENGTH",
)
The code is Ok(
    "if fail_fast {\n                return true;\n            }",
)
The code is Ok(
    "fail_fast",
)
The code is Ok(
    "return true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "*had_errors = true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "*had_errors",
)
The code is Ok(
    "had_errors",
)
The code is Ok(
    "mut_label[PUNYCODE_ENCODE_MAX_INPUT_LENGTH] = '\\u{FFFD}'",
)
The code is Ok(
    "'\\u{FFFD}'",
)
The code is Ok(
    "mut_label[PUNYCODE_ENCODE_MAX_INPUT_LENGTH]",
)
The code is Ok(
    "mut_label",
)
The code is Ok(
    "PUNYCODE_ENCODE_MAX_INPUT_LENGTH",
)
The code is Ok(
    "false",
)
The code is Ok(
    "{\n        for c in iter {\n            let jt = self.data.joining_type(c);\n            if jt.to_mask().intersects(required_mask) {\n                return true;\n            }\n            if jt.is_transparent() {\n                continue;\n            }\n            return false;\n        }\n        false\n    }",
)
The code is Ok(
    "for c in iter {\n            let jt = self.data.joining_type(c);\n            if jt.to_mask().intersects(required_mask) {\n                return true;\n            }\n            if jt.is_transparent() {\n                continue;\n            }\n            return false;\n        }",
)
The code is Ok(
    "for c in iter {\n            let jt = self.data.joining_type(c);\n            if jt.to_mask().intersects(required_mask) {\n                return true;\n            }\n            if jt.is_transparent() {\n                continue;\n            }\n            return false;\n        }",
)
into Match call
The code is Ok(
    "iter",
)
LangItem path: idna/src/uts46.rs:1626:18: 1626:22 (#583)
The code is Ok(
    "iter",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "for c in iter {\n            let jt = self.data.joining_type(c);\n            if jt.to_mask().intersects(required_mask) {\n                return true;\n            }\n            if jt.is_transparent() {\n                continue;\n            }\n            return false;\n        }",
)
The code is Ok(
    "iter",
)
into Match call
is inner Match
The code is Ok(
    "iter",
)
LangItem path: idna/src/uts46.rs:1626:18: 1626:22 (#583)
The code is Ok(
    "iter",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "for c in iter {\n            let jt = self.data.joining_type(c);\n            if jt.to_mask().intersects(required_mask) {\n                return true;\n            }\n            if jt.is_transparent() {\n                continue;\n            }\n            return false;\n        }",
)
The code is Ok(
    "{\n            let jt = self.data.joining_type(c);\n            if jt.to_mask().intersects(required_mask) {\n                return true;\n            }\n            if jt.is_transparent() {\n                continue;\n            }\n            return false;\n        }",
)
The code is Ok(
    "self.data.joining_type(c)",
)
The code is Ok(
    "self.data",
)
The code is Ok(
    "self",
)
The code is Ok(
    "c",
)
The code is Ok(
    "if jt.to_mask().intersects(required_mask) {\n                return true;\n            }",
)
The code is Ok(
    "jt.to_mask().intersects(required_mask)",
)
The code is Ok(
    "jt.to_mask()",
)
The code is Ok(
    "jt",
)
The code is Ok(
    "required_mask",
)
The code is Ok(
    "return true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "if jt.is_transparent() {\n                continue;\n            }",
)
The code is Ok(
    "jt.is_transparent()",
)
The code is Ok(
    "jt",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "return false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "false",
)
The code is Ok(
    "{\n        for &c in buffer {\n            if c < '\\u{0590}' {\n                // Below Hebrew\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{0900}', '\\u{FB1C}') {\n                debug_assert_ne!(c, '\\u{200F}'); // disallowed\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{1F000}', '\\u{3FFFF}') {\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{FF00}', '\\u{107FF}') {\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{11000}', '\\u{1E7FF}') {\n                continue;\n            }\n            if RTL_MASK.intersects(self.data.bidi_class(c).to_mask()) {\n                return true;\n            }\n        }\n        false\n    }",
)
The code is Ok(
    "for &c in buffer {\n            if c < '\\u{0590}' {\n                // Below Hebrew\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{0900}', '\\u{FB1C}') {\n                debug_assert_ne!(c, '\\u{200F}'); // disallowed\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{1F000}', '\\u{3FFFF}') {\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{FF00}', '\\u{107FF}') {\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{11000}', '\\u{1E7FF}') {\n                continue;\n            }\n            if RTL_MASK.intersects(self.data.bidi_class(c).to_mask()) {\n                return true;\n            }\n        }",
)
The code is Ok(
    "for &c in buffer {\n            if c < '\\u{0590}' {\n                // Below Hebrew\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{0900}', '\\u{FB1C}') {\n                debug_assert_ne!(c, '\\u{200F}'); // disallowed\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{1F000}', '\\u{3FFFF}') {\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{FF00}', '\\u{107FF}') {\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{11000}', '\\u{1E7FF}') {\n                continue;\n            }\n            if RTL_MASK.intersects(self.data.bidi_class(c).to_mask()) {\n                return true;\n            }\n        }",
)
into Match call
The code is Ok(
    "buffer",
)
LangItem path: idna/src/uts46.rs:1641:19: 1641:25 (#588)
The code is Ok(
    "buffer",
)
The code is Ok(
    "buffer",
)
The code is Ok(
    "for &c in buffer {\n            if c < '\\u{0590}' {\n                // Below Hebrew\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{0900}', '\\u{FB1C}') {\n                debug_assert_ne!(c, '\\u{200F}'); // disallowed\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{1F000}', '\\u{3FFFF}') {\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{FF00}', '\\u{107FF}') {\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{11000}', '\\u{1E7FF}') {\n                continue;\n            }\n            if RTL_MASK.intersects(self.data.bidi_class(c).to_mask()) {\n                return true;\n            }\n        }",
)
The code is Ok(
    "buffer",
)
into Match call
is inner Match
The code is Ok(
    "buffer",
)
LangItem path: idna/src/uts46.rs:1641:19: 1641:25 (#588)
The code is Ok(
    "buffer",
)
The code is Ok(
    "buffer",
)
The code is Ok(
    "buffer",
)
The code is Ok(
    "for &c in buffer {\n            if c < '\\u{0590}' {\n                // Below Hebrew\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{0900}', '\\u{FB1C}') {\n                debug_assert_ne!(c, '\\u{200F}'); // disallowed\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{1F000}', '\\u{3FFFF}') {\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{FF00}', '\\u{107FF}') {\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{11000}', '\\u{1E7FF}') {\n                continue;\n            }\n            if RTL_MASK.intersects(self.data.bidi_class(c).to_mask()) {\n                return true;\n            }\n        }",
)
The code is Ok(
    "{\n            if c < '\\u{0590}' {\n                // Below Hebrew\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{0900}', '\\u{FB1C}') {\n                debug_assert_ne!(c, '\\u{200F}'); // disallowed\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{1F000}', '\\u{3FFFF}') {\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{FF00}', '\\u{107FF}') {\n                continue;\n            }\n            if in_inclusive_range_char(c, '\\u{11000}', '\\u{1E7FF}') {\n                continue;\n            }\n            if RTL_MASK.intersects(self.data.bidi_class(c).to_mask()) {\n                return true;\n            }\n        }",
)
The code is Ok(
    "if c < '\\u{0590}' {\n                // Below Hebrew\n                continue;\n            }",
)
The code is Ok(
    "c < '\\u{0590}'",
)
The code is Ok(
    "c",
)
The code is Ok(
    "'\\u{0590}'",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "if in_inclusive_range_char(c, '\\u{0900}', '\\u{FB1C}') {\n                debug_assert_ne!(c, '\\u{200F}'); // disallowed\n                continue;\n            }",
)
The code is Ok(
    "in_inclusive_range_char(c, '\\u{0900}', '\\u{FB1C}')",
)
resolved new call Call { call_expr: HirId(DefId(0:217 ~ idna[bc6b]::uts46::{impl#4}::is_bidi).27), call_expr_span: idna/src/uts46.rs:1646:16: 1646:66 (#0), caller: Some(DefId(0:217 ~ idna[bc6b]::uts46::{impl#4}::is_bidi)), caller_span: None, callee: DefId(0:149 ~ idna[bc6b]::uts46::in_inclusive_range_char), callee_span: idna/src/uts46.rs:1646:16: 1646:39 (#0), callee_path: "uts46::in_inclusive_range_char", constraint_depth: 1 }
The code is Ok(
    "in_inclusive_range_char",
)
The code is Ok(
    "c",
)
The code is Ok(
    "'\\u{0900}'",
)
The code is Ok(
    "'\\u{FB1C}'",
)
The code is Ok(
    "if $crate::cfg!(debug_assertions) {\n            $crate::assert_ne!($($arg)*);\n        }",
)
The code is Ok(
    "$crate::cfg!(debug_assertions)",
)
The code is Ok(
    "match (&$left, &$right) {\n            (left_val, right_val) => {\n                if *left_val == *right_val {\n                    let kind = $crate::panicking::AssertKind::Ne;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }\n            }\n        }",
)
The code is Ok(
    "(&$left, &$right)",
)
The code is Ok(
    "&$left",
)
The code is Ok(
    "c",
)
The code is Ok(
    "&$right",
)
The code is Ok(
    "'\\u{200F}'",
)
The code is Ok(
    "{\n                if *left_val == *right_val {\n                    let kind = $crate::panicking::AssertKind::Ne;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }\n            }",
)
The code is Ok(
    "if *left_val == *right_val {\n                    let kind = $crate::panicking::AssertKind::Ne;\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);\n                }",
)
The code is Ok(
    "*left_val == *right_val",
)
The code is Ok(
    "*left_val",
)
The code is Ok(
    "left_val",
)
The code is Ok(
    "*right_val",
)
The code is Ok(
    "right_val",
)
The code is Ok(
    "$crate::panicking::AssertKind::Ne",
)
The code is Ok(
    "$crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None)",
)
resolved new call Call { call_expr: HirId(DefId(0:217 ~ idna[bc6b]::uts46::{impl#4}::is_bidi).67), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:107:21: 107:114 (#165), caller: Some(DefId(0:217 ~ idna[bc6b]::uts46::{impl#4}::is_bidi)), caller_span: None, callee: DefId(1:9590 ~ core[f118]::panicking::assert_failed), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:107:21: 107:53 (#165), callee_path: "core::panicking::assert_failed", constraint_depth: 3 }
The code is Ok(
    "$crate::panicking::assert_failed",
)
The code is Ok(
    "kind",
)
The code is Ok(
    "&*left_val",
)
The code is Ok(
    "*left_val",
)
The code is Ok(
    "left_val",
)
The code is Ok(
    "&*right_val",
)
The code is Ok(
    "*right_val",
)
The code is Ok(
    "right_val",
)
The code is Ok(
    "$crate::option::Option::None",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "if in_inclusive_range_char(c, '\\u{1F000}', '\\u{3FFFF}') {\n                continue;\n            }",
)
The code is Ok(
    "in_inclusive_range_char(c, '\\u{1F000}', '\\u{3FFFF}')",
)
resolved new call Call { call_expr: HirId(DefId(0:217 ~ idna[bc6b]::uts46::{impl#4}::is_bidi).101), call_expr_span: idna/src/uts46.rs:1650:16: 1650:68 (#0), caller: Some(DefId(0:217 ~ idna[bc6b]::uts46::{impl#4}::is_bidi)), caller_span: None, callee: DefId(0:149 ~ idna[bc6b]::uts46::in_inclusive_range_char), callee_span: idna/src/uts46.rs:1650:16: 1650:39 (#0), callee_path: "uts46::in_inclusive_range_char", constraint_depth: 1 }
The code is Ok(
    "in_inclusive_range_char",
)
The code is Ok(
    "c",
)
The code is Ok(
    "'\\u{1F000}'",
)
The code is Ok(
    "'\\u{3FFFF}'",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "if in_inclusive_range_char(c, '\\u{FF00}', '\\u{107FF}') {\n                continue;\n            }",
)
The code is Ok(
    "in_inclusive_range_char(c, '\\u{FF00}', '\\u{107FF}')",
)
resolved new call Call { call_expr: HirId(DefId(0:217 ~ idna[bc6b]::uts46::{impl#4}::is_bidi).115), call_expr_span: idna/src/uts46.rs:1653:16: 1653:67 (#0), caller: Some(DefId(0:217 ~ idna[bc6b]::uts46::{impl#4}::is_bidi)), caller_span: None, callee: DefId(0:149 ~ idna[bc6b]::uts46::in_inclusive_range_char), callee_span: idna/src/uts46.rs:1653:16: 1653:39 (#0), callee_path: "uts46::in_inclusive_range_char", constraint_depth: 1 }
The code is Ok(
    "in_inclusive_range_char",
)
The code is Ok(
    "c",
)
The code is Ok(
    "'\\u{FF00}'",
)
The code is Ok(
    "'\\u{107FF}'",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "if in_inclusive_range_char(c, '\\u{11000}', '\\u{1E7FF}') {\n                continue;\n            }",
)
The code is Ok(
    "in_inclusive_range_char(c, '\\u{11000}', '\\u{1E7FF}')",
)
resolved new call Call { call_expr: HirId(DefId(0:217 ~ idna[bc6b]::uts46::{impl#4}::is_bidi).129), call_expr_span: idna/src/uts46.rs:1656:16: 1656:68 (#0), caller: Some(DefId(0:217 ~ idna[bc6b]::uts46::{impl#4}::is_bidi)), caller_span: None, callee: DefId(0:149 ~ idna[bc6b]::uts46::in_inclusive_range_char), callee_span: idna/src/uts46.rs:1656:16: 1656:39 (#0), callee_path: "uts46::in_inclusive_range_char", constraint_depth: 1 }
The code is Ok(
    "in_inclusive_range_char",
)
The code is Ok(
    "c",
)
The code is Ok(
    "'\\u{11000}'",
)
The code is Ok(
    "'\\u{1E7FF}'",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "if RTL_MASK.intersects(self.data.bidi_class(c).to_mask()) {\n                return true;\n            }",
)
The code is Ok(
    "RTL_MASK.intersects(self.data.bidi_class(c).to_mask())",
)
The code is Ok(
    "RTL_MASK",
)
The code is Ok(
    "self.data.bidi_class(c).to_mask()",
)
The code is Ok(
    "self.data.bidi_class(c)",
)
The code is Ok(
    "self.data",
)
The code is Ok(
    "self",
)
The code is Ok(
    "c",
)
The code is Ok(
    "return true",
)
The code is Ok(
    "true",
)
The code is Ok(
    "false",
)
The code is Ok(
    "{\n        Err(e)\n    }",
)
The code is Ok(
    "Err(e)",
)
resolved new call Call { call_expr: HirId(DefId(0:223 ~ idna[bc6b]::{impl#0}::from).3), call_expr_span: idna/src/lib.rs:70:9: 70:15 (#0), caller: Some(DefId(0:223 ~ idna[bc6b]::{impl#0}::from)), caller_span: None, callee: DefId(1:45572 ~ core[f118]::result::Result::Err::{constructor#0}), callee_span: idna/src/lib.rs:70:9: 70:12 (#0), callee_path: "core::prelude::v1::Err", constraint_depth: 0 }
The code is Ok(
    "Err",
)
The code is Ok(
    "e",
)
The code is Ok(
    "{\n        core::fmt::Debug::fmt(self, f)\n    }",
)
The code is Ok(
    "core::fmt::Debug::fmt(self, f)",
)
resolved new call Call { call_expr: HirId(DefId(0:226 ~ idna[bc6b]::{impl#2}::fmt).5), call_expr_span: idna/src/lib.rs:82:9: 82:39 (#0), caller: Some(DefId(0:226 ~ idna[bc6b]::{impl#2}::fmt)), caller_span: None, callee: DefId(1:10655 ~ core[f118]::fmt::Debug::fmt), callee_span: idna/src/lib.rs:82:9: 82:30 (#0), callee_path: "core::fmt::Debug::fmt", constraint_depth: 0 }
The code is Ok(
    "core::fmt::Debug::fmt",
)
The code is Ok(
    "self",
)
The code is Ok(
    "f",
)
Functions:
  Function: uts46::has_punycode_prefix, Span: idna/src/uts46.rs:118:1: 130:2 (#0)
  Function: uts46::in_inclusive_range_char, Span: idna/src/uts46.rs:138:1: 140:2 (#0)
  Function: uts46::classify_for_punycode, Span: idna/src/uts46.rs:248:1: 267:2 (#0)
  Function: <deprecated::Config as core::default::Default>::default, Span: idna/src/deprecated.rs:144:5: 152:6 (#0)
  Function: deprecated::Config::to_unicode, Span: idna/src/deprecated.rs:242:5: 247:6 (#0)
  Function: uts46::glyphless_mask, Span: idna/src/uts46.rs:72:1: 82:2 (#0)
  Function: deprecated::Config::to_ascii, Span: idna/src/deprecated.rs:235:5: 239:6 (#0)
  Function: <punycode::Decode<'_, T, C> as core::iter::Iterator>::next, Span: idna/src/punycode.rs:283:5: 304:6 (#0)
  Function: <punycode::Decode<'_, T, C> as core::iter::Iterator>::size_hint, Span: idna/src/punycode.rs:306:5: 309:6 (#0)
  Function: deprecated::Config::transitional_processing, Span: idna/src/deprecated.rs:172:5: 175:6 (#0)
  Function: uts46::apply_ascii_deny_list_to_potentially_upper_case_ascii, Span: idna/src/uts46.rs:220:1: 228:2 (#0)
  Function: uts46::check_hyphens, Span: idna/src/uts46.rs:1667:1: 1703:2 (#0)
  Function: deprecated::Config::use_idna_2008_rules, Span: idna/src/deprecated.rs:211:5: 214:6 (#0)
  Function: uts46::AsciiDenyList::new, Span: idna/src/uts46.rs:294:5: 323:6 (#0)
  Function: uts46::Uts46::new, Span: idna/src/uts46.rs:503:5: 507:6 (#0)
  Function: uts46::Uts46::to_unicode, Span: idna/src/uts46.rs:592:5: 599:6 (#0)
  Function: punycode::decode, Span: idna/src/punycode.rs:62:1: 69:2 (#0)
  Function: <uts46::Uts46 as core::default::Default>::default, Span: idna/src/uts46.rs:495:5: 497:6 (#0)
  Function: domain_to_ascii_strict, Span: idna/src/lib.rs:139:1: 148:2 (#0)
  Function: <punycode::PunycodeEncodeError as core::convert::From<core::fmt::Error>>::from, Span: idna/src/punycode.rs:352:5: 354:6 (#0)
  Function: punycode::encode_str, Span: idna/src/punycode.rs:322:1: 330:2 (#0)
  Function: punycode::decode_to_string, Span: idna/src/punycode.rs:48:1: 55:2 (#0)
  Function: <char as punycode::PunycodeCodeUnit>::digit, Span: idna/src/punycode.rs:140:5: 148:6 (#0)
  Function: <char as punycode::PunycodeCodeUnit>::char_ascii_lower_case, Span: idna/src/punycode.rs:153:5: 156:6 (#0)
  Function: <uts46::ProcessingError as core::convert::From<core::fmt::Error>>::from, Span: idna/src/uts46.rs:436:5: 438:6 (#0)
  Function: uts46::Uts46::process_inner, Span: idna/src/uts46.rs:1031:5: 1067:6 (#0)
  Function: punycode::encode_into, Span: idna/src/punycode.rs:357:1: 455:2 (#0)
  Function: deprecated::Config::verify_dns_length, Span: idna/src/deprecated.rs:183:5: 186:6 (#0)
  Function: uts46::Uts46::process, Span: idna/src/uts46.rs:755:5: 1027:6 (#0)
  Function: <u8 as punycode::PunycodeCodeUnit>::is_ascii, Span: idna/src/punycode.rs:112:5: 114:6 (#0)
  Function: <u8 as punycode::PunycodeCodeUnit>::char_ascii_lower_case, Span: idna/src/punycode.rs:127:5: 129:6 (#0)
  Function: uts46::Uts46::check_label, Span: idna/src/uts46.rs:1525:5: 1618:6 (#0)
  Function: punycode::adapt, Span: idna/src/punycode.rs:31:1: 40:2 (#0)
  Function: domain_to_ascii_cow, Span: idna/src/lib.rs:105:1: 115:2 (#0)
  Function: uts46::apply_ascii_deny_list_to_lower_cased_unicode, Span: idna/src/uts46.rs:206:1: 216:2 (#0)
  Function: uts46::upper_case_mask, Span: idna/src/uts46.rs:56:1: 66:2 (#0)
  Function: uts46::Uts46::process_innermost, Span: idna/src/uts46.rs:1075:5: 1476:6 (#0)
  Function: punycode::value_to_digit, Span: idna/src/punycode.rs:458:1: 464:2 (#0)
  Function: uts46::is_ascii, Span: idna/src/uts46.rs:231:1: 238:2 (#0)
  Function: deprecated::map_transitional, Span: idna/src/deprecated.rs:25:1: 62:2 (#0)
  Function: deprecated::Idna::to_ascii, Span: idna/src/deprecated.rs:78:5: 105:6 (#0)
  Function: deprecated::Config::check_hyphens, Span: idna/src/deprecated.rs:199:5: 202:6 (#0)
  Function: uts46::Uts46::to_user_interface, Span: idna/src/uts46.rs:647:5: 673:6 (#0)
  Function: uts46::write_punycode_label, Span: idna/src/uts46.rs:108:1: 115:2 (#0)
  Function: uts46::in_inclusive_range8, Span: idna/src/uts46.rs:133:1: 135:2 (#0)
  Function: uts46::Uts46::has_appropriately_joining_char, Span: idna/src/uts46.rs:1621:5: 1637:6 (#0)
  Function: uts46::Uts46::is_bidi, Span: idna/src/uts46.rs:1640:5: 1664:6 (#0)
  Function: <impl core::convert::From<Errors> for core::result::Result<(), Errors>>::from, Span: idna/src/lib.rs:69:5: 71:6 (#0)
  Function: uts46::split_ascii_fast_path_prefix, Span: idna/src/uts46.rs:186:1: 202:2 (#0)
  Function: deprecated::Config::use_std3_ascii_rules, Span: idna/src/deprecated.rs:162:5: 165:6 (#0)
  Function: <char as punycode::PunycodeCodeUnit>::is_delimiter, Span: idna/src/punycode.rs:133:5: 135:6 (#0)
  Function: uts46::Uts46::after_punycode_decode, Span: idna/src/uts46.rs:1479:5: 1522:6 (#0)
  Function: uts46::is_passthrough_ascii_label, Span: idna/src/uts46.rs:143:1: 183:2 (#0)
  Function: punycode::encode, Span: idna/src/punycode.rs:336:1: 344:2 (#0)
  Function: deprecated::Idna::to_unicode, Span: idna/src/deprecated.rs:109:5: 128:6 (#0)
  Function: uts46::verify_dns_length, Span: idna/src/uts46.rs:463:1: 486:2 (#0)
  Function: <punycode::Decode<'_, T, C> as core::iter::ExactSizeIterator>::len, Span: idna/src/punycode.rs:313:5: 315:6 (#0)
  Function: <Errors as core::fmt::Display>::fmt, Span: idna/src/lib.rs:81:5: 83:6 (#0)
  Function: <u8 as punycode::PunycodeCodeUnit>::digit, Span: idna/src/punycode.rs:115:5: 123:6 (#0)
  Function: punycode::Decoder::decode, Span: idna/src/punycode.rs:166:5: 264:6 (#0)
  Function: uts46::ldh_mask, Span: idna/src/uts46.rs:91:1: 101:2 (#0)
  Function: <uts46::ProcessingError as core::convert::From<punycode::PunycodeEncodeError>>::from, Span: idna/src/uts46.rs:442:5: 446:6 (#0)
  Function: domain_to_unicode, Span: idna/src/lib.rs:164:1: 171:2 (#0)
  Function: <u8 as punycode::PunycodeCodeUnit>::is_delimiter, Span: idna/src/punycode.rs:109:5: 111:6 (#0)
  Function: <char as punycode::PunycodeCodeUnit>::char, Span: idna/src/punycode.rs:149:5: 152:6 (#0)
  Function: deprecated::Config::hyphens, Span: idna/src/deprecated.rs:226:5: 232:6 (#0)
  Function: <u8 as punycode::PunycodeCodeUnit>::char, Span: idna/src/punycode.rs:124:5: 126:6 (#0)
  Function: <char as punycode::PunycodeCodeUnit>::is_ascii, Span: idna/src/punycode.rs:136:5: 139:6 (#0)
  Function: domain_to_ascii, Span: idna/src/lib.rs:128:1: 130:2 (#0)
  Function: deprecated::Idna::new, Span: idna/src/deprecated.rs:72:5: 74:6 (#0)
  Function: deprecated::Config::deny_list, Span: idna/src/deprecated.rs:217:5: 223:6 (#0)
  Function: uts46::Uts46::to_ascii, Span: idna/src/uts46.rs:527:5: 568:6 (#0)

Method Declarations:
  Method Declaration: punycode::PunycodeCodeUnit::is_delimiter
  Method Declaration: punycode::PunycodeCodeUnit::char_ascii_lower_case
  Method Declaration: punycode::PunycodeCodeUnit::char
  Method Declaration: punycode::PunycodeCodeUnit::is_ascii
  Method Declaration: punycode::PunycodeCodeUnit::digit

Method Implementations:
  Method Implementation for punycode::PunycodeCodeUnit::digit: [DefId(0:71 ~ idna[bc6b]::punycode::{impl#2}::digit), DefId(0:77 ~ idna[bc6b]::punycode::{impl#3}::digit)]
  Method Implementation for core::iter::Iterator::size_hint: [DefId(0:103 ~ idna[bc6b]::punycode::{impl#5}::size_hint)]
  Method Implementation for core::fmt::Display::fmt: [DefId(0:226 ~ idna[bc6b]::{impl#2}::fmt)]
  Method Implementation for core::iter::ExactSizeIterator::len: [DefId(0:107 ~ idna[bc6b]::punycode::{impl#6}::len)]
  Method Implementation for core::convert::From::from: [DefId(0:118 ~ idna[bc6b]::punycode::{impl#7}::from), DefId(0:163 ~ idna[bc6b]::uts46::{impl#1}::from), DefId(0:165 ~ idna[bc6b]::uts46::{impl#2}::from), DefId(0:223 ~ idna[bc6b]::{impl#0}::from)]
  Method Implementation for punycode::PunycodeCodeUnit::is_ascii: [DefId(0:70 ~ idna[bc6b]::punycode::{impl#2}::is_ascii), DefId(0:76 ~ idna[bc6b]::punycode::{impl#3}::is_ascii)]
  Method Implementation for punycode::PunycodeCodeUnit::char: [DefId(0:72 ~ idna[bc6b]::punycode::{impl#2}::char), DefId(0:78 ~ idna[bc6b]::punycode::{impl#3}::char)]
  Method Implementation for punycode::PunycodeCodeUnit::is_delimiter: [DefId(0:69 ~ idna[bc6b]::punycode::{impl#2}::is_delimiter), DefId(0:75 ~ idna[bc6b]::punycode::{impl#3}::is_delimiter)]
  Method Implementation for punycode::PunycodeCodeUnit::char_ascii_lower_case: [DefId(0:73 ~ idna[bc6b]::punycode::{impl#2}::char_ascii_lower_case), DefId(0:79 ~ idna[bc6b]::punycode::{impl#3}::char_ascii_lower_case)]
  Method Implementation for core::default::Default::default: [DefId(0:23 ~ idna[bc6b]::deprecated::{impl#1}::default), DefId(0:171 ~ idna[bc6b]::uts46::{impl#3}::default)]
  Method Implementation for core::iter::Iterator::next: [DefId(0:102 ~ idna[bc6b]::punycode::{impl#5}::next)]

Static Calls:
punycode::decode --- punycode::Decoder::default (Constraint Depth: 0)
punycode::Decoder::decode --- punycode::adapt (Constraint Depth: 0)
uts46::Uts46::to_ascii --- core::prelude::v1::Ok (Constraint Depth: 3)
<char as punycode::PunycodeCodeUnit>::char --- core::panicking::panic (Constraint Depth: 1)
deprecated::map_transitional --- std::borrow::Cow::Owned (Constraint Depth: 2)
uts46::Uts46::process --- core::str::from_utf8_unchecked (Constraint Depth: 1)
uts46::Uts46::check_label --- uts46::check_hyphens (Constraint Depth: 1)
uts46::Uts46::to_ascii --- std::borrow::Cow::Borrowed (Constraint Depth: 1)
uts46::Uts46::process_innermost --- uts46::apply_ascii_deny_list_to_lower_cased_unicode (Constraint Depth: 2)
deprecated::Idna::to_ascii --- Errors::default (Constraint Depth: 1)
uts46::Uts46::process_innermost --- uts46::has_punycode_prefix (Constraint Depth: 3)
uts46::Uts46::to_user_interface --- uts46::Uts46::process (Constraint Depth: 1)
domain_to_ascii_strict --- uts46::Uts46::to_ascii (Constraint Depth: 0)
uts46::Uts46::to_ascii --- std::string::String::new (Constraint Depth: 0)
uts46::Uts46::is_bidi --- core::panicking::assert_failed (Constraint Depth: 3)
uts46::Uts46::process --- core::panicking::assert_failed (Constraint Depth: 2)
uts46::Uts46::process_innermost --- core::prelude::v1::Some (Constraint Depth: 4)
<impl core::convert::From<Errors> for core::result::Result<(), Errors>>::from --- core::prelude::v1::Err (Constraint Depth: 0)
Unknown Caller --- uts46::glyphless_mask (Constraint Depth: 0)
uts46::Uts46::process_innermost --- core::panicking::assert_failed (Constraint Depth: 3)
uts46::Uts46::process_innermost --- punycode::Decoder::decode (Constraint Depth: 5)
uts46::write_punycode_label --- punycode::encode_into (Constraint Depth: 0)
uts46::Uts46::process_innermost --- uts46::check_hyphens (Constraint Depth: 4)
deprecated::Idna::to_unicode --- uts46::Uts46::new (Constraint Depth: 1)
uts46::AsciiDenyList::new --- core::panicking::panic (Constraint Depth: 2)
uts46::Uts46::to_user_interface --- core::str::from_utf8_unchecked (Constraint Depth: 1)
uts46::Uts46::after_punycode_decode --- core::prelude::v1::Err (Constraint Depth: 1)
uts46::Uts46::to_ascii --- core::str::from_utf8_unchecked (Constraint Depth: 1)
uts46::Uts46::check_label --- uts46::is_ascii (Constraint Depth: 0)
punycode::decode_to_string --- punycode::Decoder::decode (Constraint Depth: 0)
uts46::Uts46::process_innermost --- uts46::Uts46::after_punycode_decode (Constraint Depth: 6)
uts46::Uts46::process_innermost --- core::panicking::panic (Constraint Depth: 5)
uts46::Uts46::process_innermost --- punycode::Decoder::default (Constraint Depth: 5)
uts46::Uts46::process_innermost --- uts46::apply_ascii_deny_list_to_potentially_upper_case_ascii (Constraint Depth: 3)
uts46::Uts46::is_bidi --- uts46::in_inclusive_range_char (Constraint Depth: 1)
uts46::Uts46::process --- uts46::is_ascii (Constraint Depth: 1)
uts46::Uts46::process --- uts46::write_punycode_label (Constraint Depth: 1)
uts46::Uts46::process --- core::prelude::v1::Ok (Constraint Depth: 0)
Unknown Caller --- uts46::AsciiDenyList::new (Constraint Depth: 0)
punycode::decode --- core::prelude::v1::Some (Constraint Depth: 0)
uts46::verify_dns_length --- core::panicking::panic (Constraint Depth: 1)
deprecated::Idna::to_ascii --- uts46::Uts46::new (Constraint Depth: 1)
deprecated::Idna::to_ascii --- uts46::verify_dns_length (Constraint Depth: 2)
deprecated::Idna::to_unicode --- deprecated::Config::deny_list (Constraint Depth: 1)
<char as punycode::PunycodeCodeUnit>::digit --- core::prelude::v1::Some (Constraint Depth: 0)
uts46::Uts46::check_label --- uts46::Uts46::has_appropriately_joining_char (Constraint Depth: 1)
domain_to_ascii_cow --- uts46::Uts46::new (Constraint Depth: 0)
uts46::Uts46::to_ascii --- std::borrow::Cow::Owned (Constraint Depth: 1)
uts46::Uts46::process --- smallvec::SmallVec::new (Constraint Depth: 0)
punycode::Decoder::decode --- core::prelude::v1::Err (Constraint Depth: 1)
punycode::encode_str --- std::string::String::with_capacity (Constraint Depth: 0)
punycode::decode_to_string --- punycode::Decoder::default (Constraint Depth: 0)
uts46::Uts46::to_ascii --- core::panicking::panic (Constraint Depth: 1)
uts46::Uts46::process_innermost --- uts46::Uts46::is_bidi (Constraint Depth: 0)
deprecated::Config::to_unicode --- std::string::String::with_capacity (Constraint Depth: 0)
deprecated::Config::to_unicode --- deprecated::Idna::to_unicode (Constraint Depth: 0)
punycode::encode_into --- punycode::adapt (Constraint Depth: 3)
uts46::Uts46::check_label --- uts46::in_inclusive_range_char (Constraint Depth: 1)
uts46::Uts46::to_ascii --- core::prelude::v1::Err (Constraint Depth: 1)
deprecated::Idna::to_unicode --- deprecated::map_transitional (Constraint Depth: 0)
uts46::Uts46::process_innermost --- smallvec::SmallVec::new (Constraint Depth: 6)
uts46::Uts46::to_user_interface --- core::panicking::panic (Constraint Depth: 1)
uts46::Uts46::process --- core::prelude::v1::Err (Constraint Depth: 1)
<char as punycode::PunycodeCodeUnit>::is_ascii --- core::panicking::panic (Constraint Depth: 1)
punycode::encode_str --- punycode::encode_into (Constraint Depth: 0)
deprecated::Idna::to_ascii --- uts46::Uts46::process (Constraint Depth: 1)
uts46::Uts46::new --- idna_adapter::Adapter::new (Constraint Depth: 0)
punycode::encode_into --- punycode::value_to_digit (Constraint Depth: 3)
domain_to_ascii --- domain_to_ascii_cow (Constraint Depth: 0)
uts46::is_passthrough_ascii_label --- core::prelude::v1::Some (Constraint Depth: 1)
deprecated::map_transitional --- std::string::String::with_capacity (Constraint Depth: 2)
uts46::Uts46::to_user_interface --- core::prelude::v1::Ok (Constraint Depth: 1)
punycode::encode_into --- core::prelude::v1::Ok (Constraint Depth: 0)
uts46::Uts46::process_innermost --- uts46::Uts46::check_label (Constraint Depth: 3)
uts46::Uts46::process_innermost --- uts46::AlreadyAsciiLabel::MixedCaseAscii (Constraint Depth: 2)
uts46::Uts46::check_label --- core::panicking::assert_failed (Constraint Depth: 3)
punycode::encode --- punycode::encode_into (Constraint Depth: 0)
uts46::Uts46::to_user_interface --- core::prelude::v1::Err (Constraint Depth: 1)
<punycode::Decode<'_, T, C> as core::iter::Iterator>::size_hint --- core::prelude::v1::Some (Constraint Depth: 0)
uts46::Uts46::process_inner --- uts46::Uts46::process_innermost (Constraint Depth: 1)
deprecated::Idna::to_unicode --- uts46::Uts46::process (Constraint Depth: 1)
deprecated::Config::use_idna_2008_rules --- core::panicking::panic (Constraint Depth: 1)
uts46::Uts46::to_user_interface --- std::borrow::Cow::Owned (Constraint Depth: 1)
punycode::Decoder::decode --- core::prelude::v1::Ok (Constraint Depth: 0)
uts46::Uts46::to_ascii --- uts46::Uts46::process (Constraint Depth: 1)
uts46::Uts46::process --- uts46::Uts46::process_inner (Constraint Depth: 0)
uts46::Uts46::process_innermost --- uts46::is_passthrough_ascii_label (Constraint Depth: 2)
deprecated::Idna::to_ascii --- core::panicking::panic (Constraint Depth: 1)
uts46::Uts46::to_user_interface --- std::string::String::new (Constraint Depth: 0)
uts46::Uts46::after_punycode_decode --- core::prelude::v1::Ok (Constraint Depth: 1)
uts46::Uts46::process_innermost --- uts46::split_ascii_fast_path_prefix (Constraint Depth: 2)
deprecated::Idna::to_unicode --- core::panicking::panic (Constraint Depth: 1)
<punycode::Decode<'_, T, C> as core::iter::Iterator>::next --- core::prelude::v1::Some (Constraint Depth: 1)
uts46::apply_ascii_deny_list_to_potentially_upper_case_ascii --- uts46::in_inclusive_range8 (Constraint Depth: 0)
uts46::Uts46::to_ascii --- Errors::default (Constraint Depth: 1)
uts46::Uts46::to_user_interface --- Errors::default (Constraint Depth: 1)
uts46::is_passthrough_ascii_label --- uts46::in_inclusive_range8 (Constraint Depth: 1)
punycode::decode_to_string --- core::prelude::v1::Some (Constraint Depth: 0)
deprecated::Idna::to_ascii --- deprecated::Config::hyphens (Constraint Depth: 1)
uts46::Uts46::to_ascii --- uts46::verify_dns_length (Constraint Depth: 2)
uts46::Uts46::to_unicode --- uts46::Uts46::to_user_interface (Constraint Depth: 0)
deprecated::Idna::to_ascii --- core::prelude::v1::Ok (Constraint Depth: 1)
deprecated::Config::to_unicode --- deprecated::Idna::new (Constraint Depth: 0)
deprecated::Config::to_ascii --- deprecated::Idna::to_ascii (Constraint Depth: 0)
<uts46::ProcessingError as core::convert::From<punycode::PunycodeEncodeError>>::from --- core::panicking::unreachable_display (Constraint Depth: 0)
uts46::write_punycode_label --- core::prelude::v1::Ok (Constraint Depth: 0)
<u8 as punycode::PunycodeCodeUnit>::digit --- core::prelude::v1::Some (Constraint Depth: 0)
uts46::Uts46::to_user_interface --- std::borrow::Cow::Borrowed (Constraint Depth: 1)
deprecated::Idna::to_unicode --- deprecated::Config::hyphens (Constraint Depth: 1)
domain_to_unicode --- uts46::Uts46::to_unicode (Constraint Depth: 0)
<Errors as core::fmt::Display>::fmt --- core::fmt::Debug::fmt (Constraint Depth: 0)
uts46::Uts46::process --- uts46::classify_for_punycode (Constraint Depth: 1)
uts46::Uts46::after_punycode_decode --- uts46::apply_ascii_deny_list_to_lower_cased_unicode (Constraint Depth: 1)
uts46::Uts46::process_innermost --- uts46::AlreadyAsciiLabel::MixedCasePunycode (Constraint Depth: 6)
punycode::encode --- std::string::String::with_capacity (Constraint Depth: 0)
deprecated::Idna::to_unicode --- core::prelude::v1::Ok (Constraint Depth: 1)
deprecated::Idna::to_ascii --- deprecated::Config::deny_list (Constraint Depth: 1)
uts46::Uts46::process_inner --- uts46::in_inclusive_range8 (Constraint Depth: 1)
Unknown Caller --- uts46::upper_case_mask (Constraint Depth: 0)
punycode::value_to_digit --- core::panicking::panic (Constraint Depth: 1)
deprecated::Idna::to_ascii --- deprecated::map_transitional (Constraint Depth: 0)
deprecated::Idna::to_ascii --- core::prelude::v1::Err (Constraint Depth: 1)
deprecated::Config::to_ascii --- deprecated::Idna::new (Constraint Depth: 0)
deprecated::Idna::to_unicode --- core::prelude::v1::Err (Constraint Depth: 1)
deprecated::Idna::to_unicode --- Errors::default (Constraint Depth: 1)
uts46::Uts46::check_label --- core::panicking::panic (Constraint Depth: 2)
punycode::Decoder::decode --- core::char::from_u32 (Constraint Depth: 1)
domain_to_unicode --- uts46::Uts46::new (Constraint Depth: 0)
deprecated::Config::to_ascii --- std::string::String::with_capacity (Constraint Depth: 0)
Unknown Caller --- uts46::ldh_mask (Constraint Depth: 0)
uts46::Uts46::process --- core::panicking::panic (Constraint Depth: 1)
deprecated::map_transitional --- std::borrow::Cow::Borrowed (Constraint Depth: 0)
punycode::decode --- punycode::Decoder::decode (Constraint Depth: 0)
domain_to_ascii_strict --- uts46::Uts46::new (Constraint Depth: 0)
domain_to_ascii_cow --- uts46::Uts46::to_ascii (Constraint Depth: 0)

Dynamic Calls:
<punycode::Decode<'_, T, C> as core::iter::Iterator>::next --- punycode::PunycodeCodeUnit::char (Constraint Depth: 2)
uts46::Uts46::after_punycode_decode --- core::iter::Iterator::map (Constraint Depth: 1)
punycode::Decoder::decode --- punycode::PunycodeCodeUnit::is_ascii (Constraint Depth: 1)
uts46::Uts46::process --- core::fmt::Write::write_char (Constraint Depth: 1)
punycode::encode_into --- core::fmt::Write::write_char (Constraint Depth: 1)
punycode::encode_into --- core::clone::Clone::clone (Constraint Depth: 1)
<punycode::Decode<'_, T, C> as core::iter::Iterator>::next --- punycode::PunycodeCodeUnit::char_ascii_lower_case (Constraint Depth: 2)
punycode::Decoder::decode --- punycode::PunycodeCodeUnit::digit (Constraint Depth: 0)
uts46::Uts46::process --- core::fmt::Write::write_str (Constraint Depth: 1)
punycode::encode_into --- core::iter::Iterator::map (Constraint Depth: 1)
uts46::write_punycode_label --- core::fmt::Write::write_str (Constraint Depth: 0)
punycode::Decoder::decode --- punycode::PunycodeCodeUnit::is_delimiter (Constraint Depth: 0)
uts46::Uts46::process_innermost --- core::iter::Iterator::map (Constraint Depth: 2)

Non Local Calls:
uts46::check_hyphens --- core::slice::<impl [T]>::len (Constraint Depth: 0)
uts46::Uts46::after_punycode_decode --- core::iter::Iterator::copied (Constraint Depth: 1)
uts46::Uts46::check_label --- core::slice::<impl [T]>::first_mut (Constraint Depth: 1)
<punycode::Decode<'_, T, C> as core::iter::Iterator>::next --- core::slice::<impl [T]>::get (Constraint Depth: 1)
uts46::Uts46::process --- core::slice::<impl [T]>::iter (Constraint Depth: 0)
uts46::Uts46::process --- core::num::<impl u8>::to_ascii_lowercase (Constraint Depth: 2)
punycode::Decoder::decode --- core::option::Option::<T>::ok_or (Constraint Depth: 0)
uts46::Uts46::process_innermost --- idna_adapter::BidiClass::is_european_number (Constraint Depth: 6)
uts46::Uts46::process_innermost --- idna_adapter::BidiClass::to_mask (Constraint Depth: 3)
deprecated::Idna::to_ascii --- core::str::<impl str>::as_bytes (Constraint Depth: 1)
punycode::Decoder::decode --- core::num::<impl u32>::checked_add (Constraint Depth: 0)
uts46::Uts46::process_innermost --- core::slice::<impl [T]>::split_first_mut (Constraint Depth: 2)
uts46::Uts46::process --- core::slice::<impl [T]>::split (Constraint Depth: 1)
punycode::Decoder::decode --- std::slice::<impl [T]>::sort_by_key (Constraint Depth: 0)
punycode::encode_str --- core::result::Result::<T, E>::ok (Constraint Depth: 0)
uts46::Uts46::process --- <core::slice::Iter<'a, T> as core::iter::Iterator>::position (Constraint Depth: 1)
uts46::classify_for_punycode --- <core::iter::Copied<I> as core::iter::Iterator>::next (Constraint Depth: 0)
punycode::decode --- core::iter::Iterator::collect (Constraint Depth: 0)
uts46::AsciiDenyList::new --- core::slice::<impl [T]>::len (Constraint Depth: 0)
uts46::Uts46::process --- core::num::<impl u8>::is_ascii_uppercase (Constraint Depth: 1)
deprecated::Idna::to_unicode --- core::str::<impl str>::as_bytes (Constraint Depth: 1)
uts46::Uts46::after_punycode_decode --- core::iter::Iterator::zip (Constraint Depth: 0)
uts46::split_ascii_fast_path_prefix --- core::slice::<impl [T]>::split_at (Constraint Depth: 2)
domain_to_ascii_strict --- std::borrow::Cow::<'_, B>::into_owned (Constraint Depth: 0)
deprecated::Idna::to_unicode --- std::string::String::push_str (Constraint Depth: 1)
uts46::Uts46::process --- <core::slice::Iter<'a, T> as core::iter::Iterator>::next (Constraint Depth: 1)
domain_to_ascii_strict --- core::result::Result::<T, E>::map (Constraint Depth: 0)
uts46::Uts46::process_innermost --- core::slice::<impl [T]>::split_last_mut (Constraint Depth: 3)
deprecated::Config::to_unicode --- core::str::<impl str>::len (Constraint Depth: 0)
domain_to_ascii --- std::borrow::Cow::<'_, B>::into_owned (Constraint Depth: 0)
uts46::in_inclusive_range_char --- core::num::<impl u32>::wrapping_sub (Constraint Depth: 0)
uts46::Uts46::process_innermost --- smallvec::SmallVec::<A>::push (Constraint Depth: 1)
punycode::encode --- core::iter::Iterator::copied (Constraint Depth: 0)
uts46::Uts46::process --- core::slice::<impl [T]>::strip_suffix (Constraint Depth: 0)
uts46::Uts46::process_innermost --- smallvec::SmallVec::<A>::len (Constraint Depth: 1)
uts46::Uts46::process_innermost --- idna_adapter::BidiClass::is_nonspacing_mark (Constraint Depth: 4)
uts46::Uts46::after_punycode_decode --- core::iter::Iterator::try_for_each (Constraint Depth: 0)
uts46::verify_dns_length --- core::slice::<impl [T]>::is_empty (Constraint Depth: 1)
punycode::encode_into --- core::iter::Iterator::min (Constraint Depth: 1)
uts46::Uts46::process_innermost --- core::slice::<impl [T]>::split_mut (Constraint Depth: 2)
uts46::Uts46::process_innermost --- idna_adapter::BidiClassMask::intersects (Constraint Depth: 3)
uts46::classify_for_punycode --- core::iter::Iterator::copied (Constraint Depth: 0)
uts46::Uts46::process --- core::slice::<impl [T]>::contains (Constraint Depth: 1)
<u8 as punycode::PunycodeCodeUnit>::char_ascii_lower_case --- core::num::<impl u8>::to_ascii_lowercase (Constraint Depth: 0)
uts46::Uts46::process_inner --- core::slice::Iter::<'a, T>::as_slice (Constraint Depth: 1)
punycode::encode_into --- core::iter::Iterator::filter (Constraint Depth: 1)
punycode::Decoder::decode --- smallvec::SmallVec::<A>::len (Constraint Depth: 0)
<punycode::Decode<'_, T, C> as core::iter::Iterator>::next --- core::slice::<impl [T]>::len (Constraint Depth: 1)
uts46::Uts46::process_inner --- <core::slice::Iter<'a, T> as core::iter::Iterator>::next (Constraint Depth: 0)
uts46::Uts46::process_innermost --- core::slice::<impl [T]>::iter (Constraint Depth: 3)
uts46::Uts46::check_label --- idna_adapter::Adapter::is_mark (Constraint Depth: 2)
uts46::Uts46::check_label --- core::slice::<impl [T]>::len (Constraint Depth: 1)
uts46::is_ascii --- core::char::methods::<impl char>::is_ascii (Constraint Depth: 1)
deprecated::map_transitional --- core::str::<impl str>::chars (Constraint Depth: 0)
uts46::Uts46::check_label --- core::slice::<impl [T]>::last (Constraint Depth: 1)
uts46::Uts46::check_label --- idna_adapter::Adapter::is_virama (Constraint Depth: 2)
uts46::Uts46::process_innermost --- core::iter::Iterator::map (Constraint Depth: 3)
uts46::AsciiDenyList::new --- core::str::<impl str>::as_bytes (Constraint Depth: 0)
uts46::verify_dns_length --- core::slice::<impl [T]>::strip_suffix (Constraint Depth: 0)
uts46::Uts46::after_punycode_decode --- idna_adapter::Adapter::normalize_validate (Constraint Depth: 1)
domain_to_unicode --- core::str::<impl str>::as_bytes (Constraint Depth: 0)
uts46::is_ascii --- core::slice::<impl [T]>::iter (Constraint Depth: 1)
uts46::is_passthrough_ascii_label --- core::slice::<impl [T]>::split_first (Constraint Depth: 0)
uts46::split_ascii_fast_path_prefix --- <core::slice::Iter<'a, T> as core::iter::Iterator>::position (Constraint Depth: 0)
punycode::Decoder::decode --- <core::slice::Iter<'a, T> as core::iter::Iterator>::next (Constraint Depth: 1)
uts46::Uts46::process_innermost --- core::slice::<impl [T]>::last_mut (Constraint Depth: 4)
uts46::Uts46::has_appropriately_joining_char --- idna_adapter::JoiningType::is_transparent (Constraint Depth: 1)
uts46::Uts46::check_label --- core::slice::<impl [T]>::split_first_mut (Constraint Depth: 1)
uts46::split_ascii_fast_path_prefix --- core::slice::<impl [T]>::iter (Constraint Depth: 0)
punycode::encode_into --- core::char::methods::<impl char>::is_ascii (Constraint Depth: 1)
domain_to_unicode --- std::borrow::Cow::<'_, B>::into_owned (Constraint Depth: 0)
deprecated::Config::to_ascii --- core::str::<impl str>::len (Constraint Depth: 0)
deprecated::map_transitional --- std::string::String::push (Constraint Depth: 4)
punycode::encode_into --- core::num::<impl u32>::checked_mul (Constraint Depth: 1)
uts46::check_hyphens --- core::slice::<impl [T]>::last_mut (Constraint Depth: 0)
deprecated::map_transitional --- <core::str::Chars<'a> as core::iter::Iterator>::next (Constraint Depth: 0)
punycode::encode_into --- core::option::Option::<T>::ok_or (Constraint Depth: 1)
uts46::write_punycode_label --- core::iter::Iterator::copied (Constraint Depth: 0)
uts46::Uts46::process_innermost --- core::slice::<impl [T]>::last (Constraint Depth: 4)
uts46::in_inclusive_range8 --- core::num::<impl u8>::wrapping_sub (Constraint Depth: 0)
uts46::Uts46::check_label --- core::slice::<impl [T]>::iter (Constraint Depth: 1)
uts46::Uts46::is_bidi --- idna_adapter::BidiClassMask::intersects (Constraint Depth: 1)
domain_to_ascii --- core::str::<impl str>::as_bytes (Constraint Depth: 0)
uts46::Uts46::process --- core::slice::<impl [T]>::rsplit (Constraint Depth: 0)
uts46::Uts46::after_punycode_decode --- smallvec::SmallVec::<A>::push (Constraint Depth: 1)
punycode::Decoder::decode --- smallvec::SmallVec::<A>::push (Constraint Depth: 0)
punycode::decode_to_string --- core::str::<impl str>::as_bytes (Constraint Depth: 0)
uts46::Uts46::process_innermost --- idna_adapter::Adapter::bidi_class (Constraint Depth: 3)
uts46::Uts46::process_innermost --- <smallvec::SmallVec<A> as core::iter::Extend<<A as smallvec::Array>::Item>>::extend (Constraint Depth: 6)
uts46::has_punycode_prefix --- core::slice::<impl [T]>::len (Constraint Depth: 0)
punycode::decode_to_string --- core::iter::Iterator::collect (Constraint Depth: 0)
punycode::Decoder::decode --- core::slice::<impl [T]>::iter (Constraint Depth: 0)
punycode::encode --- core::slice::<impl [T]>::iter (Constraint Depth: 0)
domain_to_ascii_strict --- core::str::<impl str>::as_bytes (Constraint Depth: 0)
punycode::encode --- core::option::Option::<T>::map (Constraint Depth: 0)
uts46::Uts46::is_bidi --- idna_adapter::Adapter::bidi_class (Constraint Depth: 1)
uts46::verify_dns_length --- core::slice::<impl [T]>::split (Constraint Depth: 1)
punycode::decode_to_string --- core::result::Result::<T, E>::ok (Constraint Depth: 0)
punycode::Decoder::decode --- <core::slice::Iter<'a, T> as core::iter::Iterator>::rposition (Constraint Depth: 0)
uts46::Uts46::process_innermost --- core::option::Option::<T>::is_none (Constraint Depth: 3)
uts46::Uts46::process_innermost --- idna_adapter::Adapter::map_normalize (Constraint Depth: 2)
uts46::Uts46::after_punycode_decode --- core::slice::<impl [T]>::iter (Constraint Depth: 0)
punycode::encode_str --- core::str::<impl str>::chars (Constraint Depth: 0)
uts46::Uts46::process_inner --- <core::slice::Iter<'_, T> as core::clone::Clone>::clone (Constraint Depth: 0)
uts46::Uts46::process_innermost --- core::slice::<impl [T]>::starts_with (Constraint Depth: 3)
uts46::Uts46::process --- core::option::Option::<T>::unwrap (Constraint Depth: 0)
uts46::classify_for_punycode --- core::char::methods::<impl char>::is_ascii (Constraint Depth: 1)
uts46::Uts46::is_bidi --- idna_adapter::BidiClass::to_mask (Constraint Depth: 1)
punycode::encode --- core::result::Result::<T, E>::ok (Constraint Depth: 0)
uts46::Uts46::process_innermost --- <core::slice::Iter<'a, T> as core::iter::Iterator>::next (Constraint Depth: 7)
uts46::Uts46::has_appropriately_joining_char --- idna_adapter::JoiningType::to_mask (Constraint Depth: 1)
punycode::Decoder::decode --- <core::slice::Iter<'a, T> as core::iter::Iterator>::all (Constraint Depth: 1)
uts46::is_passthrough_ascii_label --- core::slice::<impl [T]>::last (Constraint Depth: 1)
uts46::Uts46::process_innermost --- core::slice::<impl [T]>::len (Constraint Depth: 0)
domain_to_ascii --- core::result::Result::<T, E>::map (Constraint Depth: 0)
uts46::verify_dns_length --- core::slice::<impl [T]>::len (Constraint Depth: 0)
uts46::split_ascii_fast_path_prefix --- core::num::<impl u8>::is_ascii (Constraint Depth: 0)
punycode::encode_str --- core::str::<impl str>::len (Constraint Depth: 0)
deprecated::map_transitional --- core::str::Chars::<'a>::as_str (Constraint Depth: 2)
punycode::encode_into --- core::option::Option::<T>::unwrap (Constraint Depth: 1)
punycode::encode_str --- core::option::Option::<T>::map (Constraint Depth: 0)
deprecated::Config::to_ascii --- core::result::Result::<T, E>::map (Constraint Depth: 0)
uts46::Uts46::after_punycode_decode --- core::slice::<impl [T]>::iter_mut (Constraint Depth: 0)
uts46::Uts46::process_innermost --- smallvec::SmallVec::<A>::truncate (Constraint Depth: 6)
punycode::Decoder::decode --- smallvec::SmallVec::<A>::clear (Constraint Depth: 0)
punycode::Decoder::decode --- core::slice::<impl [T]>::len (Constraint Depth: 0)
uts46::Uts46::process_innermost --- core::char::methods::<impl char>::is_ascii (Constraint Depth: 5)
uts46::check_hyphens --- core::slice::<impl [T]>::first_mut (Constraint Depth: 0)
deprecated::map_transitional --- <core::str::Chars<'a> as core::clone::Clone>::clone (Constraint Depth: 0)
<punycode::Decode<'_, T, C> as core::iter::Iterator>::next --- <core::slice::Iter<'a, T> as core::iter::Iterator>::next (Constraint Depth: 0)
deprecated::map_transitional --- std::string::String::push_str (Constraint Depth: 2)
punycode::encode --- core::slice::<impl [T]>::len (Constraint Depth: 0)
uts46::Uts46::process_inner --- core::slice::<impl [T]>::len (Constraint Depth: 1)
deprecated::map_transitional --- core::str::<impl str>::len (Constraint Depth: 2)
uts46::Uts46::process_innermost --- idna_adapter::BidiClass::is_ltr (Constraint Depth: 3)
uts46::Uts46::process_innermost --- <[u8] as utf8_iter::Utf8CharsEx>::chars (Constraint Depth: 2)
uts46::Uts46::process_innermost --- core::slice::<impl [T]>::iter_mut (Constraint Depth: 5)
punycode::decode --- core::str::<impl str>::as_bytes (Constraint Depth: 0)
deprecated::Idna::to_ascii --- std::string::String::push_str (Constraint Depth: 1)
uts46::Uts46::process_innermost --- core::slice::<impl [T]>::split (Constraint Depth: 1)
uts46::Uts46::process_innermost --- core::slice::<impl [T]>::is_empty (Constraint Depth: 1)
uts46::apply_ascii_deny_list_to_lower_cased_unicode --- core::num::<impl u128>::checked_shl (Constraint Depth: 0)
punycode::decode --- core::result::Result::<T, E>::ok (Constraint Depth: 0)
uts46::Uts46::process --- core::slice::<impl [T]>::len (Constraint Depth: 0)
uts46::verify_dns_length --- core::slice::ascii::<impl [u8]>::is_ascii (Constraint Depth: 0)
uts46::Uts46::process --- core::iter::Iterator::copied (Constraint Depth: 2)
uts46::classify_for_punycode --- core::slice::<impl [T]>::iter (Constraint Depth: 0)
uts46::Uts46::check_label --- core::slice::<impl [T]>::split_at_mut (Constraint Depth: 1)
uts46::Uts46::check_label --- core::iter::Iterator::copied (Constraint Depth: 1)
uts46::Uts46::check_label --- core::iter::Iterator::rev (Constraint Depth: 1)
uts46::write_punycode_label --- core::slice::<impl [T]>::iter (Constraint Depth: 0)
uts46::Uts46::process --- <core::slice::RSplit<'a, T, P> as core::iter::Iterator>::next (Constraint Depth: 0)
uts46::Uts46::has_appropriately_joining_char --- idna_adapter::Adapter::joining_type (Constraint Depth: 1)
punycode::encode_into --- core::num::<impl u32>::checked_add (Constraint Depth: 1)
uts46::Uts46::has_appropriately_joining_char --- idna_adapter::JoiningTypeMask::intersects (Constraint Depth: 1)
uts46::Uts46::process_innermost --- idna_adapter::BidiClass::is_arabic_number (Constraint Depth: 6)
uts46::Uts46::process_innermost --- <core::iter::Map<I, F> as core::iter::Iterator>::next (Constraint Depth: 2)
uts46::is_passthrough_ascii_label --- core::slice::<impl [T]>::len (Constraint Depth: 0)
punycode::Decoder::decode --- core::num::<impl u32>::checked_mul (Constraint Depth: 0)
uts46::Uts46::process_inner --- core::slice::<impl [T]>::iter (Constraint Depth: 0)
uts46::verify_dns_length --- core::str::<impl str>::as_bytes (Constraint Depth: 0)
uts46::Uts46::process --- core::slice::<impl [T]>::split_at (Constraint Depth: 1)
Target name: tests
Target test:tests is not supported
Target name: unit
Target test:unit is not supported
Target name: unitbis
Target test:unitbis is not supported
Target name: all
Target bench:all is not supported
