Target name: form_urlencoded
The code is Ok(
    "ASCII_RANGE_LEN / BITS_PER_CHUNK",
)
The code is Ok(
    "ASCII_RANGE_LEN",
)
The code is Ok(
    "BITS_PER_CHUNK",
)
The code is Ok(
    "0x80",
)
The code is Ok(
    "8 * mem::size_of::<Chunk>()",
)
The code is Ok(
    "8",
)
The code is Ok(
    "mem::size_of::<Chunk>()",
)
resolved new call Call { call_expr: HirId(DefId(0:26 ~ percent_encoding[b3a7]::ascii_set::BITS_PER_CHUNK).5), call_expr_span: percent_encoding/src/ascii_set.rs:36:35: 36:58 (#0), caller: None, caller_span: None, callee: DefId(1:2092 ~ core[f118]::mem::size_of), callee_span: percent_encoding/src/ascii_set.rs:36:35: 36:56 (#0), callee_path: "core::mem::size_of", constraint_depth: 0 }
The code is Ok(
    "mem::size_of::<Chunk>",
)
The code is Ok(
    "&AsciiSet {\n    mask: [\n        !0_u32, // C0: 0x00 to 0x1F (32 bits set)\n        0,\n        0,\n        1 << (0x7F_u32 % 32), // DEL: 0x7F (one bit set)\n    ],\n}",
)
The code is Ok(
    "AsciiSet {\n    mask: [\n        !0_u32, // C0: 0x00 to 0x1F (32 bits set)\n        0,\n        0,\n        1 << (0x7F_u32 % 32), // DEL: 0x7F (one bit set)\n    ],\n}",
)
The code is Ok(
    "[\n        !0_u32, // C0: 0x00 to 0x1F (32 bits set)\n        0,\n        0,\n        1 << (0x7F_u32 % 32), // DEL: 0x7F (one bit set)\n    ]",
)
The code is Ok(
    "!0_u32",
)
The code is Ok(
    "0_u32",
)
The code is Ok(
    "0",
)
The code is Ok(
    "0",
)
The code is Ok(
    "1 << (0x7F_u32 % 32)",
)
The code is Ok(
    "1",
)
The code is Ok(
    "(0x7F_u32 % 32)",
)
The code is Ok(
    "0x7F_u32",
)
The code is Ok(
    "32",
)
The code is Ok(
    "&CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')\n    .add(b'+')\n    .add(b',')\n    .add(b'-')\n    .add(b'.')\n    .add(b'/')\n    .add(b':')\n    .add(b';')\n    .add(b'<')\n    .add(b'=')\n    .add(b'>')\n    .add(b'?')\n    .add(b'@')\n    .add(b'[')\n    .add(b'\\\\')\n    .add(b']')\n    .add(b'^')\n    .add(b'_')\n    .add(b'`')\n    .add(b'{')\n    .add(b'|')\n    .add(b'}')\n    .add(b'~')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')\n    .add(b'+')\n    .add(b',')\n    .add(b'-')\n    .add(b'.')\n    .add(b'/')\n    .add(b':')\n    .add(b';')\n    .add(b'<')\n    .add(b'=')\n    .add(b'>')\n    .add(b'?')\n    .add(b'@')\n    .add(b'[')\n    .add(b'\\\\')\n    .add(b']')\n    .add(b'^')\n    .add(b'_')\n    .add(b'`')\n    .add(b'{')\n    .add(b'|')\n    .add(b'}')\n    .add(b'~')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')\n    .add(b'+')\n    .add(b',')\n    .add(b'-')\n    .add(b'.')\n    .add(b'/')\n    .add(b':')\n    .add(b';')\n    .add(b'<')\n    .add(b'=')\n    .add(b'>')\n    .add(b'?')\n    .add(b'@')\n    .add(b'[')\n    .add(b'\\\\')\n    .add(b']')\n    .add(b'^')\n    .add(b'_')\n    .add(b'`')\n    .add(b'{')\n    .add(b'|')\n    .add(b'}')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')\n    .add(b'+')\n    .add(b',')\n    .add(b'-')\n    .add(b'.')\n    .add(b'/')\n    .add(b':')\n    .add(b';')\n    .add(b'<')\n    .add(b'=')\n    .add(b'>')\n    .add(b'?')\n    .add(b'@')\n    .add(b'[')\n    .add(b'\\\\')\n    .add(b']')\n    .add(b'^')\n    .add(b'_')\n    .add(b'`')\n    .add(b'{')\n    .add(b'|')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')\n    .add(b'+')\n    .add(b',')\n    .add(b'-')\n    .add(b'.')\n    .add(b'/')\n    .add(b':')\n    .add(b';')\n    .add(b'<')\n    .add(b'=')\n    .add(b'>')\n    .add(b'?')\n    .add(b'@')\n    .add(b'[')\n    .add(b'\\\\')\n    .add(b']')\n    .add(b'^')\n    .add(b'_')\n    .add(b'`')\n    .add(b'{')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')\n    .add(b'+')\n    .add(b',')\n    .add(b'-')\n    .add(b'.')\n    .add(b'/')\n    .add(b':')\n    .add(b';')\n    .add(b'<')\n    .add(b'=')\n    .add(b'>')\n    .add(b'?')\n    .add(b'@')\n    .add(b'[')\n    .add(b'\\\\')\n    .add(b']')\n    .add(b'^')\n    .add(b'_')\n    .add(b'`')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')\n    .add(b'+')\n    .add(b',')\n    .add(b'-')\n    .add(b'.')\n    .add(b'/')\n    .add(b':')\n    .add(b';')\n    .add(b'<')\n    .add(b'=')\n    .add(b'>')\n    .add(b'?')\n    .add(b'@')\n    .add(b'[')\n    .add(b'\\\\')\n    .add(b']')\n    .add(b'^')\n    .add(b'_')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')\n    .add(b'+')\n    .add(b',')\n    .add(b'-')\n    .add(b'.')\n    .add(b'/')\n    .add(b':')\n    .add(b';')\n    .add(b'<')\n    .add(b'=')\n    .add(b'>')\n    .add(b'?')\n    .add(b'@')\n    .add(b'[')\n    .add(b'\\\\')\n    .add(b']')\n    .add(b'^')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')\n    .add(b'+')\n    .add(b',')\n    .add(b'-')\n    .add(b'.')\n    .add(b'/')\n    .add(b':')\n    .add(b';')\n    .add(b'<')\n    .add(b'=')\n    .add(b'>')\n    .add(b'?')\n    .add(b'@')\n    .add(b'[')\n    .add(b'\\\\')\n    .add(b']')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')\n    .add(b'+')\n    .add(b',')\n    .add(b'-')\n    .add(b'.')\n    .add(b'/')\n    .add(b':')\n    .add(b';')\n    .add(b'<')\n    .add(b'=')\n    .add(b'>')\n    .add(b'?')\n    .add(b'@')\n    .add(b'[')\n    .add(b'\\\\')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')\n    .add(b'+')\n    .add(b',')\n    .add(b'-')\n    .add(b'.')\n    .add(b'/')\n    .add(b':')\n    .add(b';')\n    .add(b'<')\n    .add(b'=')\n    .add(b'>')\n    .add(b'?')\n    .add(b'@')\n    .add(b'[')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')\n    .add(b'+')\n    .add(b',')\n    .add(b'-')\n    .add(b'.')\n    .add(b'/')\n    .add(b':')\n    .add(b';')\n    .add(b'<')\n    .add(b'=')\n    .add(b'>')\n    .add(b'?')\n    .add(b'@')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')\n    .add(b'+')\n    .add(b',')\n    .add(b'-')\n    .add(b'.')\n    .add(b'/')\n    .add(b':')\n    .add(b';')\n    .add(b'<')\n    .add(b'=')\n    .add(b'>')\n    .add(b'?')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')\n    .add(b'+')\n    .add(b',')\n    .add(b'-')\n    .add(b'.')\n    .add(b'/')\n    .add(b':')\n    .add(b';')\n    .add(b'<')\n    .add(b'=')\n    .add(b'>')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')\n    .add(b'+')\n    .add(b',')\n    .add(b'-')\n    .add(b'.')\n    .add(b'/')\n    .add(b':')\n    .add(b';')\n    .add(b'<')\n    .add(b'=')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')\n    .add(b'+')\n    .add(b',')\n    .add(b'-')\n    .add(b'.')\n    .add(b'/')\n    .add(b':')\n    .add(b';')\n    .add(b'<')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')\n    .add(b'+')\n    .add(b',')\n    .add(b'-')\n    .add(b'.')\n    .add(b'/')\n    .add(b':')\n    .add(b';')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')\n    .add(b'+')\n    .add(b',')\n    .add(b'-')\n    .add(b'.')\n    .add(b'/')\n    .add(b':')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')\n    .add(b'+')\n    .add(b',')\n    .add(b'-')\n    .add(b'.')\n    .add(b'/')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')\n    .add(b'+')\n    .add(b',')\n    .add(b'-')\n    .add(b'.')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')\n    .add(b'+')\n    .add(b',')\n    .add(b'-')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')\n    .add(b'+')\n    .add(b',')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')\n    .add(b'+')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')\n    .add(b'*')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')\n    .add(b')')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')\n    .add(b'(')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')\n    .add(b'\\'')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')\n    .add(b'&')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')\n    .add(b'%')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')\n    .add(b'$')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')\n    .add(b'#')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')\n    .add(b'\"')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')\n    .add(b'!')",
)
The code is Ok(
    "CONTROLS\n    .add(b' ')",
)
The code is Ok(
    "CONTROLS",
)
The code is Ok(
    "b' '",
)
The code is Ok(
    "b'!'",
)
The code is Ok(
    "b'\"'",
)
The code is Ok(
    "b'#'",
)
The code is Ok(
    "b'$'",
)
The code is Ok(
    "b'%'",
)
The code is Ok(
    "b'&'",
)
The code is Ok(
    "b'\\''",
)
The code is Ok(
    "b'('",
)
The code is Ok(
    "b')'",
)
The code is Ok(
    "b'*'",
)
The code is Ok(
    "b'+'",
)
The code is Ok(
    "b','",
)
The code is Ok(
    "b'-'",
)
The code is Ok(
    "b'.'",
)
The code is Ok(
    "b'/'",
)
The code is Ok(
    "b':'",
)
The code is Ok(
    "b';'",
)
The code is Ok(
    "b'<'",
)
The code is Ok(
    "b'='",
)
The code is Ok(
    "b'>'",
)
The code is Ok(
    "b'?'",
)
The code is Ok(
    "b'@'",
)
The code is Ok(
    "b'['",
)
The code is Ok(
    "b'\\\\'",
)
The code is Ok(
    "b']'",
)
The code is Ok(
    "b'^'",
)
The code is Ok(
    "b'_'",
)
The code is Ok(
    "b'`'",
)
The code is Ok(
    "b'{'",
)
The code is Ok(
    "b'|'",
)
The code is Ok(
    "b'}'",
)
The code is Ok(
    "b'~'",
)
The code is Ok(
    "{\n    static ENC_TABLE: &[u8; 768] = b\"\\\n      %00%01%02%03%04%05%06%07%08%09%0A%0B%0C%0D%0E%0F\\\n      %10%11%12%13%14%15%16%17%18%19%1A%1B%1C%1D%1E%1F\\\n      %20%21%22%23%24%25%26%27%28%29%2A%2B%2C%2D%2E%2F\\\n      %30%31%32%33%34%35%36%37%38%39%3A%3B%3C%3D%3E%3F\\\n      %40%41%42%43%44%45%46%47%48%49%4A%4B%4C%4D%4E%4F\\\n      %50%51%52%53%54%55%56%57%58%59%5A%5B%5C%5D%5E%5F\\\n      %60%61%62%63%64%65%66%67%68%69%6A%6B%6C%6D%6E%6F\\\n      %70%71%72%73%74%75%76%77%78%79%7A%7B%7C%7D%7E%7F\\\n      %80%81%82%83%84%85%86%87%88%89%8A%8B%8C%8D%8E%8F\\\n      %90%91%92%93%94%95%96%97%98%99%9A%9B%9C%9D%9E%9F\\\n      %A0%A1%A2%A3%A4%A5%A6%A7%A8%A9%AA%AB%AC%AD%AE%AF\\\n      %B0%B1%B2%B3%B4%B5%B6%B7%B8%B9%BA%BB%BC%BD%BE%BF\\\n      %C0%C1%C2%C3%C4%C5%C6%C7%C8%C9%CA%CB%CC%CD%CE%CF\\\n      %D0%D1%D2%D3%D4%D5%D6%D7%D8%D9%DA%DB%DC%DD%DE%DF\\\n      %E0%E1%E2%E3%E4%E5%E6%E7%E8%E9%EA%EB%EC%ED%EE%EF\\\n      %F0%F1%F2%F3%F4%F5%F6%F7%F8%F9%FA%FB%FC%FD%FE%FF\\\n      \";\n\n    let index = usize::from(byte) * 3;\n    // SAFETY: ENC_TABLE is ascii-only, so any subset of it should be\n    // ascii-only too, which is valid utf8.\n    unsafe { str::from_utf8_unchecked(&ENC_TABLE[index..index + 3]) }\n}",
)
The code is Ok(
    "usize::from(byte) * 3",
)
The code is Ok(
    "usize::from(byte)",
)
The code is Ok(
    "usize::from",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "3",
)
The code is Ok(
    "unsafe { str::from_utf8_unchecked(&ENC_TABLE[index..index + 3]) }",
)
The code is Ok(
    "str::from_utf8_unchecked(&ENC_TABLE[index..index + 3])",
)
resolved new call Call { call_expr: HirId(DefId(0:45 ~ percent_encoding[b3a7]::percent_encode_byte).17), call_expr_span: percent_encoding/src/lib.rs:96:14: 96:68 (#0), caller: Some(DefId(0:45 ~ percent_encoding[b3a7]::percent_encode_byte)), caller_span: None, callee: DefId(1:12976 ~ core[f118]::str::converts::from_utf8_unchecked), callee_span: percent_encoding/src/lib.rs:96:14: 96:38 (#0), callee_path: "core::str::from_utf8_unchecked", constraint_depth: 0 }
The code is Ok(
    "str::from_utf8_unchecked",
)
The code is Ok(
    "&ENC_TABLE[index..index + 3]",
)
The code is Ok(
    "ENC_TABLE[index..index + 3]",
)
The code is Ok(
    "ENC_TABLE",
)
The code is Ok(
    "index..index + 3",
)
The code is Ok(
    "index",
)
The code is Ok(
    "index + 3",
)
The code is Ok(
    "index",
)
The code is Ok(
    "3",
)
The code is Ok(
    "768",
)
The code is Ok(
    "b\"\\\n      %00%01%02%03%04%05%06%07%08%09%0A%0B%0C%0D%0E%0F\\\n      %10%11%12%13%14%15%16%17%18%19%1A%1B%1C%1D%1E%1F\\\n      %20%21%22%23%24%25%26%27%28%29%2A%2B%2C%2D%2E%2F\\\n      %30%31%32%33%34%35%36%37%38%39%3A%3B%3C%3D%3E%3F\\\n      %40%41%42%43%44%45%46%47%48%49%4A%4B%4C%4D%4E%4F\\\n      %50%51%52%53%54%55%56%57%58%59%5A%5B%5C%5D%5E%5F\\\n      %60%61%62%63%64%65%66%67%68%69%6A%6B%6C%6D%6E%6F\\\n      %70%71%72%73%74%75%76%77%78%79%7A%7B%7C%7D%7E%7F\\\n      %80%81%82%83%84%85%86%87%88%89%8A%8B%8C%8D%8E%8F\\\n      %90%91%92%93%94%95%96%97%98%99%9A%9B%9C%9D%9E%9F\\\n      %A0%A1%A2%A3%A4%A5%A6%A7%A8%A9%AA%AB%AC%AD%AE%AF\\\n      %B0%B1%B2%B3%B4%B5%B6%B7%B8%B9%BA%BB%BC%BD%BE%BF\\\n      %C0%C1%C2%C3%C4%C5%C6%C7%C8%C9%CA%CB%CC%CD%CE%CF\\\n      %D0%D1%D2%D3%D4%D5%D6%D7%D8%D9%DA%DB%DC%DD%DE%DF\\\n      %E0%E1%E2%E3%E4%E5%E6%E7%E8%E9%EA%EB%EC%ED%EE%EF\\\n      %F0%F1%F2%F3%F4%F5%F6%F7%F8%F9%FA%FB%FC%FD%FE%FF\\\n      \"",
)
The code is Ok(
    "{\n    PercentEncode {\n        bytes: input,\n        ascii_set,\n    }\n}",
)
The code is Ok(
    "PercentEncode {\n        bytes: input,\n        ascii_set,\n    }",
)
The code is Ok(
    "input",
)
The code is Ok(
    "ascii_set",
)
The code is Ok(
    "{\n    percent_encode(input.as_bytes(), ascii_set)\n}",
)
The code is Ok(
    "percent_encode(input.as_bytes(), ascii_set)",
)
resolved new call Call { call_expr: HirId(DefId(0:50 ~ percent_encoding[b3a7]::utf8_percent_encode).5), call_expr_span: percent_encoding/src/lib.rs:137:5: 137:48 (#0), caller: Some(DefId(0:50 ~ percent_encoding[b3a7]::utf8_percent_encode)), caller_span: None, callee: DefId(0:48 ~ percent_encoding[b3a7]::percent_encode), callee_span: percent_encoding/src/lib.rs:137:5: 137:19 (#0), callee_path: "percent_encode", constraint_depth: 0 }
The code is Ok(
    "percent_encode",
)
The code is Ok(
    "input.as_bytes()",
)
The code is Ok(
    "input",
)
The code is Ok(
    "ascii_set",
)
The code is Ok(
    "{\n    percent_decode(input.as_bytes())\n}",
)
The code is Ok(
    "percent_decode(input.as_bytes())",
)
resolved new call Call { call_expr: HirId(DefId(0:62 ~ percent_encoding[b3a7]::percent_decode_str).3), call_expr_span: percent_encoding/src/lib.rs:218:5: 218:37 (#0), caller: Some(DefId(0:62 ~ percent_encoding[b3a7]::percent_decode_str)), caller_span: None, callee: DefId(0:63 ~ percent_encoding[b3a7]::percent_decode), callee_span: percent_encoding/src/lib.rs:218:5: 218:19 (#0), callee_path: "percent_decode", constraint_depth: 0 }
The code is Ok(
    "percent_decode",
)
The code is Ok(
    "input.as_bytes()",
)
The code is Ok(
    "input",
)
The code is Ok(
    "{\n    PercentDecode {\n        bytes: input.iter(),\n    }\n}",
)
The code is Ok(
    "PercentDecode {\n        bytes: input.iter(),\n    }",
)
The code is Ok(
    "input.iter()",
)
The code is Ok(
    "input",
)
The code is Ok(
    "{\n    let mut cloned_iter = iter.clone();\n    let h = char::from(*cloned_iter.next()?).to_digit(16)?;\n    let l = char::from(*cloned_iter.next()?).to_digit(16)?;\n    *iter = cloned_iter;\n    Some(h as u8 * 0x10 + l as u8)\n}",
)
The code is Ok(
    "iter.clone()",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "char::from(*cloned_iter.next()?).to_digit(16)?",
)
into Match call
The code is Ok(
    "char::from(*cloned_iter.next()?).to_digit(16)?",
)
LangItem path: percent_encoding/src/lib.rs:254:13: 254:59 (#31)
The code is Ok(
    "char::from(*cloned_iter.next()?).to_digit(16)?",
)
The code is Ok(
    "char::from(*cloned_iter.next()?).to_digit(16)",
)
The code is Ok(
    "char::from(*cloned_iter.next()?)",
)
The code is Ok(
    "char::from",
)
The code is Ok(
    "*cloned_iter.next()?",
)
The code is Ok(
    "cloned_iter.next()?",
)
into Match call
The code is Ok(
    "cloned_iter.next()?",
)
LangItem path: percent_encoding/src/lib.rs:254:25: 254:44 (#33)
The code is Ok(
    "cloned_iter.next()?",
)
The code is Ok(
    "cloned_iter.next()",
)
The code is Ok(
    "cloned_iter",
)
The code is Ok(
    "?",
)
The code is Ok(
    "cloned_iter.next()?",
)
LangItem path: percent_encoding/src/lib.rs:254:43: 254:44 (#34)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "cloned_iter.next()?",
)
The code is Ok(
    "16",
)
The code is Ok(
    "?",
)
The code is Ok(
    "char::from(*cloned_iter.next()?).to_digit(16)?",
)
LangItem path: percent_encoding/src/lib.rs:254:58: 254:59 (#32)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "char::from(*cloned_iter.next()?).to_digit(16)?",
)
The code is Ok(
    "char::from(*cloned_iter.next()?).to_digit(16)?",
)
into Match call
The code is Ok(
    "char::from(*cloned_iter.next()?).to_digit(16)?",
)
LangItem path: percent_encoding/src/lib.rs:255:13: 255:59 (#35)
The code is Ok(
    "char::from(*cloned_iter.next()?).to_digit(16)?",
)
The code is Ok(
    "char::from(*cloned_iter.next()?).to_digit(16)",
)
The code is Ok(
    "char::from(*cloned_iter.next()?)",
)
The code is Ok(
    "char::from",
)
The code is Ok(
    "*cloned_iter.next()?",
)
The code is Ok(
    "cloned_iter.next()?",
)
into Match call
The code is Ok(
    "cloned_iter.next()?",
)
LangItem path: percent_encoding/src/lib.rs:255:25: 255:44 (#37)
The code is Ok(
    "cloned_iter.next()?",
)
The code is Ok(
    "cloned_iter.next()",
)
The code is Ok(
    "cloned_iter",
)
The code is Ok(
    "?",
)
The code is Ok(
    "cloned_iter.next()?",
)
LangItem path: percent_encoding/src/lib.rs:255:43: 255:44 (#38)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "cloned_iter.next()?",
)
The code is Ok(
    "16",
)
The code is Ok(
    "?",
)
The code is Ok(
    "char::from(*cloned_iter.next()?).to_digit(16)?",
)
LangItem path: percent_encoding/src/lib.rs:255:58: 255:59 (#36)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "char::from(*cloned_iter.next()?).to_digit(16)?",
)
The code is Ok(
    "*iter = cloned_iter",
)
The code is Ok(
    "cloned_iter",
)
The code is Ok(
    "*iter",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "Some(h as u8 * 0x10 + l as u8)",
)
resolved new call Call { call_expr: HirId(DefId(0:64 ~ percent_encoding[b3a7]::after_percent_sign).121), call_expr_span: percent_encoding/src/lib.rs:257:5: 257:35 (#0), caller: Some(DefId(0:64 ~ percent_encoding[b3a7]::after_percent_sign)), caller_span: None, callee: DefId(1:45302 ~ core[f118]::option::Option::Some::{constructor#0}), callee_span: percent_encoding/src/lib.rs:257:5: 257:9 (#0), callee_path: "core::prelude::v1::Some", constraint_depth: 0 }
The code is Ok(
    "Some",
)
The code is Ok(
    "h as u8 * 0x10 + l as u8",
)
The code is Ok(
    "h as u8 * 0x10",
)
The code is Ok(
    "h as u8",
)
The code is Ok(
    "h",
)
The code is Ok(
    "0x10",
)
The code is Ok(
    "l as u8",
)
The code is Ok(
    "l",
)
The code is Ok(
    "{\n    // Note: This function is duplicated in `form_urlencoded/src/query_encoding.rs`.\n    match input {\n        Cow::Borrowed(bytes) => String::from_utf8_lossy(bytes),\n        Cow::Owned(bytes) => {\n            match String::from_utf8_lossy(&bytes) {\n                Cow::Borrowed(utf8) => {\n                    // If from_utf8_lossy returns a Cow::Borrowed, then we can\n                    // be sure our original bytes were valid UTF-8. This is because\n                    // if the bytes were invalid UTF-8 from_utf8_lossy would have\n                    // to allocate a new owned string to back the Cow so it could\n                    // replace invalid bytes with a placeholder.\n\n                    // First we do a debug_assert to confirm our description above.\n                    let raw_utf8: *const [u8] = utf8.as_bytes();\n                    debug_assert!(raw_utf8 == &*bytes as *const [u8]);\n\n                    // Given we know the original input bytes are valid UTF-8,\n                    // and we have ownership of those bytes, we re-use them and\n                    // return a Cow::Owned here.\n                    Cow::Owned(unsafe { String::from_utf8_unchecked(bytes) })\n                }\n                Cow::Owned(s) => Cow::Owned(s),\n            }\n        }\n    }\n}",
)
The code is Ok(
    "match input {\n        Cow::Borrowed(bytes) => String::from_utf8_lossy(bytes),\n        Cow::Owned(bytes) => {\n            match String::from_utf8_lossy(&bytes) {\n                Cow::Borrowed(utf8) => {\n                    // If from_utf8_lossy returns a Cow::Borrowed, then we can\n                    // be sure our original bytes were valid UTF-8. This is because\n                    // if the bytes were invalid UTF-8 from_utf8_lossy would have\n                    // to allocate a new owned string to back the Cow so it could\n                    // replace invalid bytes with a placeholder.\n\n                    // First we do a debug_assert to confirm our description above.\n                    let raw_utf8: *const [u8] = utf8.as_bytes();\n                    debug_assert!(raw_utf8 == &*bytes as *const [u8]);\n\n                    // Given we know the original input bytes are valid UTF-8,\n                    // and we have ownership of those bytes, we re-use them and\n                    // return a Cow::Owned here.\n                    Cow::Owned(unsafe { String::from_utf8_unchecked(bytes) })\n                }\n                Cow::Owned(s) => Cow::Owned(s),\n            }\n        }\n    }",
)
The code is Ok(
    "input",
)
The code is Ok(
    "String::from_utf8_lossy(bytes)",
)
The code is Ok(
    "String::from_utf8_lossy",
)
The code is Ok(
    "bytes",
)
The code is Ok(
    "{\n            match String::from_utf8_lossy(&bytes) {\n                Cow::Borrowed(utf8) => {\n                    // If from_utf8_lossy returns a Cow::Borrowed, then we can\n                    // be sure our original bytes were valid UTF-8. This is because\n                    // if the bytes were invalid UTF-8 from_utf8_lossy would have\n                    // to allocate a new owned string to back the Cow so it could\n                    // replace invalid bytes with a placeholder.\n\n                    // First we do a debug_assert to confirm our description above.\n                    let raw_utf8: *const [u8] = utf8.as_bytes();\n                    debug_assert!(raw_utf8 == &*bytes as *const [u8]);\n\n                    // Given we know the original input bytes are valid UTF-8,\n                    // and we have ownership of those bytes, we re-use them and\n                    // return a Cow::Owned here.\n                    Cow::Owned(unsafe { String::from_utf8_unchecked(bytes) })\n                }\n                Cow::Owned(s) => Cow::Owned(s),\n            }\n        }",
)
The code is Ok(
    "match String::from_utf8_lossy(&bytes) {\n                Cow::Borrowed(utf8) => {\n                    // If from_utf8_lossy returns a Cow::Borrowed, then we can\n                    // be sure our original bytes were valid UTF-8. This is because\n                    // if the bytes were invalid UTF-8 from_utf8_lossy would have\n                    // to allocate a new owned string to back the Cow so it could\n                    // replace invalid bytes with a placeholder.\n\n                    // First we do a debug_assert to confirm our description above.\n                    let raw_utf8: *const [u8] = utf8.as_bytes();\n                    debug_assert!(raw_utf8 == &*bytes as *const [u8]);\n\n                    // Given we know the original input bytes are valid UTF-8,\n                    // and we have ownership of those bytes, we re-use them and\n                    // return a Cow::Owned here.\n                    Cow::Owned(unsafe { String::from_utf8_unchecked(bytes) })\n                }\n                Cow::Owned(s) => Cow::Owned(s),\n            }",
)
into Match call
The code is Ok(
    "String::from_utf8_lossy(&bytes)",
)
The code is Ok(
    "String::from_utf8_lossy",
)
The code is Ok(
    "&bytes",
)
The code is Ok(
    "bytes",
)
The code is Ok(
    "{\n                    // If from_utf8_lossy returns a Cow::Borrowed, then we can\n                    // be sure our original bytes were valid UTF-8. This is because\n                    // if the bytes were invalid UTF-8 from_utf8_lossy would have\n                    // to allocate a new owned string to back the Cow so it could\n                    // replace invalid bytes with a placeholder.\n\n                    // First we do a debug_assert to confirm our description above.\n                    let raw_utf8: *const [u8] = utf8.as_bytes();\n                    debug_assert!(raw_utf8 == &*bytes as *const [u8]);\n\n                    // Given we know the original input bytes are valid UTF-8,\n                    // and we have ownership of those bytes, we re-use them and\n                    // return a Cow::Owned here.\n                    Cow::Owned(unsafe { String::from_utf8_unchecked(bytes) })\n                }",
)
The code is Ok(
    "utf8.as_bytes()",
)
The code is Ok(
    "utf8",
)
The code is Ok(
    "if $crate::cfg!(debug_assertions) {\n            $crate::assert!($($arg)*);\n        }",
)
The code is Ok(
    "$crate::cfg!(debug_assertions)",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "raw_utf8 == &*bytes as *const [u8]",
)
The code is Ok(
    "raw_utf8",
)
The code is Ok(
    "&*bytes as *const [u8]",
)
The code is Ok(
    "&*bytes",
)
The code is Ok(
    "*bytes",
)
The code is Ok(
    "bytes",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
resolved new call Call { call_expr: HirId(DefId(0:79 ~ percent_encoding[b3a7]::decode_utf8_lossy).68), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:335:13: 335:38 (#16), caller: Some(DefId(0:79 ~ percent_encoding[b3a7]::decode_utf8_lossy)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:335:13: 335:13 (#16), callee_path: "core::panicking::panic", constraint_depth: 3 }
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "",
)
The code is Ok(
    "Cow::Owned(unsafe { String::from_utf8_unchecked(bytes) })",
)
resolved new call Call { call_expr: HirId(DefId(0:79 ~ percent_encoding[b3a7]::decode_utf8_lossy).80), call_expr_span: percent_encoding/src/lib.rs:359:21: 359:78 (#0), caller: Some(DefId(0:79 ~ percent_encoding[b3a7]::decode_utf8_lossy)), caller_span: None, callee: DefId(5:794 ~ alloc[186e]::borrow::Cow::Owned::{constructor#0}), callee_span: percent_encoding/src/lib.rs:359:21: 359:31 (#0), callee_path: "_::borrow::Cow::Owned", constraint_depth: 2 }
The code is Ok(
    "Cow::Owned",
)
The code is Ok(
    "unsafe { String::from_utf8_unchecked(bytes) }",
)
The code is Ok(
    "String::from_utf8_unchecked(bytes)",
)
The code is Ok(
    "String::from_utf8_unchecked",
)
The code is Ok(
    "bytes",
)
The code is Ok(
    "Cow::Owned(s)",
)
resolved new call Call { call_expr: HirId(DefId(0:79 ~ percent_encoding[b3a7]::decode_utf8_lossy).99), call_expr_span: percent_encoding/src/lib.rs:361:34: 361:47 (#0), caller: Some(DefId(0:79 ~ percent_encoding[b3a7]::decode_utf8_lossy)), caller_span: None, callee: DefId(5:794 ~ alloc[186e]::borrow::Cow::Owned::{constructor#0}), callee_span: percent_encoding/src/lib.rs:361:34: 361:44 (#0), callee_path: "_::borrow::Cow::Owned", constraint_depth: 2 }
The code is Ok(
    "Cow::Owned",
)
The code is Ok(
    "s",
)
The code is Ok(
    "AsciiSet {\n        mask: [0; ASCII_RANGE_LEN / BITS_PER_CHUNK],\n    }",
)
The code is Ok(
    "[0; ASCII_RANGE_LEN / BITS_PER_CHUNK]",
)
The code is Ok(
    "0",
)
The code is Ok(
    "ASCII_RANGE_LEN / BITS_PER_CHUNK",
)
The code is Ok(
    "ASCII_RANGE_LEN",
)
The code is Ok(
    "BITS_PER_CHUNK",
)
The code is Ok(
    "{\n        let chunk = self.mask[byte as usize / BITS_PER_CHUNK];\n        let mask = 1 << (byte as usize % BITS_PER_CHUNK);\n        (chunk & mask) != 0\n    }",
)
The code is Ok(
    "self.mask[byte as usize / BITS_PER_CHUNK]",
)
The code is Ok(
    "self.mask",
)
The code is Ok(
    "self",
)
The code is Ok(
    "byte as usize / BITS_PER_CHUNK",
)
The code is Ok(
    "byte as usize",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "BITS_PER_CHUNK",
)
The code is Ok(
    "1 << (byte as usize % BITS_PER_CHUNK)",
)
The code is Ok(
    "1",
)
The code is Ok(
    "(byte as usize % BITS_PER_CHUNK)",
)
The code is Ok(
    "byte as usize",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "BITS_PER_CHUNK",
)
The code is Ok(
    "(chunk & mask) != 0",
)
The code is Ok(
    "(chunk & mask)",
)
The code is Ok(
    "chunk",
)
The code is Ok(
    "mask",
)
The code is Ok(
    "0",
)
The code is Ok(
    "{\n        !byte.is_ascii() || self.contains(byte)\n    }",
)
The code is Ok(
    "!byte.is_ascii() || self.contains(byte)",
)
The code is Ok(
    "!byte.is_ascii()",
)
The code is Ok(
    "byte.is_ascii()",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "self.contains(byte)",
)
The code is Ok(
    "self",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "{\n        let mut mask = self.mask;\n        mask[byte as usize / BITS_PER_CHUNK] |= 1 << (byte as usize % BITS_PER_CHUNK);\n        AsciiSet { mask }\n    }",
)
The code is Ok(
    "self.mask",
)
The code is Ok(
    "self",
)
The code is Ok(
    "mask[byte as usize / BITS_PER_CHUNK] |= 1 << (byte as usize % BITS_PER_CHUNK)",
)
The code is Ok(
    "1 << (byte as usize % BITS_PER_CHUNK)",
)
The code is Ok(
    "1",
)
The code is Ok(
    "(byte as usize % BITS_PER_CHUNK)",
)
The code is Ok(
    "byte as usize",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "BITS_PER_CHUNK",
)
The code is Ok(
    "mask[byte as usize / BITS_PER_CHUNK]",
)
The code is Ok(
    "mask",
)
The code is Ok(
    "byte as usize / BITS_PER_CHUNK",
)
The code is Ok(
    "byte as usize",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "BITS_PER_CHUNK",
)
The code is Ok(
    "AsciiSet { mask }",
)
The code is Ok(
    "mask",
)
The code is Ok(
    "{\n        let mut mask = self.mask;\n        mask[byte as usize / BITS_PER_CHUNK] &= !(1 << (byte as usize % BITS_PER_CHUNK));\n        AsciiSet { mask }\n    }",
)
The code is Ok(
    "self.mask",
)
The code is Ok(
    "self",
)
The code is Ok(
    "mask[byte as usize / BITS_PER_CHUNK] &= !(1 << (byte as usize % BITS_PER_CHUNK))",
)
The code is Ok(
    "!(1 << (byte as usize % BITS_PER_CHUNK))",
)
The code is Ok(
    "(1 << (byte as usize % BITS_PER_CHUNK))",
)
The code is Ok(
    "1",
)
The code is Ok(
    "(byte as usize % BITS_PER_CHUNK)",
)
The code is Ok(
    "byte as usize",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "BITS_PER_CHUNK",
)
The code is Ok(
    "mask[byte as usize / BITS_PER_CHUNK]",
)
The code is Ok(
    "mask",
)
The code is Ok(
    "byte as usize / BITS_PER_CHUNK",
)
The code is Ok(
    "byte as usize",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "BITS_PER_CHUNK",
)
The code is Ok(
    "AsciiSet { mask }",
)
The code is Ok(
    "mask",
)
The code is Ok(
    "{\n        let mask = [\n            self.mask[0] | other.mask[0],\n            self.mask[1] | other.mask[1],\n            self.mask[2] | other.mask[2],\n            self.mask[3] | other.mask[3],\n        ];\n        AsciiSet { mask }\n    }",
)
The code is Ok(
    "[\n            self.mask[0] | other.mask[0],\n            self.mask[1] | other.mask[1],\n            self.mask[2] | other.mask[2],\n            self.mask[3] | other.mask[3],\n        ]",
)
The code is Ok(
    "self.mask[0] | other.mask[0]",
)
The code is Ok(
    "self.mask[0]",
)
The code is Ok(
    "self.mask",
)
The code is Ok(
    "self",
)
The code is Ok(
    "0",
)
The code is Ok(
    "other.mask[0]",
)
The code is Ok(
    "other.mask",
)
The code is Ok(
    "other",
)
The code is Ok(
    "0",
)
The code is Ok(
    "self.mask[1] | other.mask[1]",
)
The code is Ok(
    "self.mask[1]",
)
The code is Ok(
    "self.mask",
)
The code is Ok(
    "self",
)
The code is Ok(
    "1",
)
The code is Ok(
    "other.mask[1]",
)
The code is Ok(
    "other.mask",
)
The code is Ok(
    "other",
)
The code is Ok(
    "1",
)
The code is Ok(
    "self.mask[2] | other.mask[2]",
)
The code is Ok(
    "self.mask[2]",
)
The code is Ok(
    "self.mask",
)
The code is Ok(
    "self",
)
The code is Ok(
    "2",
)
The code is Ok(
    "other.mask[2]",
)
The code is Ok(
    "other.mask",
)
The code is Ok(
    "other",
)
The code is Ok(
    "2",
)
The code is Ok(
    "self.mask[3] | other.mask[3]",
)
The code is Ok(
    "self.mask[3]",
)
The code is Ok(
    "self.mask",
)
The code is Ok(
    "self",
)
The code is Ok(
    "3",
)
The code is Ok(
    "other.mask[3]",
)
The code is Ok(
    "other.mask",
)
The code is Ok(
    "other",
)
The code is Ok(
    "3",
)
The code is Ok(
    "AsciiSet { mask }",
)
The code is Ok(
    "mask",
)
The code is Ok(
    "{\n        let mask = [!self.mask[0], !self.mask[1], !self.mask[2], !self.mask[3]];\n        AsciiSet { mask }\n    }",
)
The code is Ok(
    "[!self.mask[0], !self.mask[1], !self.mask[2], !self.mask[3]]",
)
The code is Ok(
    "!self.mask[0]",
)
The code is Ok(
    "self.mask[0]",
)
The code is Ok(
    "self.mask",
)
The code is Ok(
    "self",
)
The code is Ok(
    "0",
)
The code is Ok(
    "!self.mask[1]",
)
The code is Ok(
    "self.mask[1]",
)
The code is Ok(
    "self.mask",
)
The code is Ok(
    "self",
)
The code is Ok(
    "1",
)
The code is Ok(
    "!self.mask[2]",
)
The code is Ok(
    "self.mask[2]",
)
The code is Ok(
    "self.mask",
)
The code is Ok(
    "self",
)
The code is Ok(
    "2",
)
The code is Ok(
    "!self.mask[3]",
)
The code is Ok(
    "self.mask[3]",
)
The code is Ok(
    "self.mask",
)
The code is Ok(
    "self",
)
The code is Ok(
    "3",
)
The code is Ok(
    "AsciiSet { mask }",
)
The code is Ok(
    "mask",
)
The code is Ok(
    "{\n        self.union(other)\n    }",
)
The code is Ok(
    "self.union(other)",
)
The code is Ok(
    "self",
)
The code is Ok(
    "other",
)
The code is Ok(
    "{\n        self.complement()\n    }",
)
The code is Ok(
    "self.complement()",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        if let Some((&first_byte, remaining)) = self.bytes.split_first() {\n            if self.ascii_set.should_percent_encode(first_byte) {\n                self.bytes = remaining;\n                Some(percent_encode_byte(first_byte))\n            } else {\n                // The unsafe blocks here are appropriate because the bytes are\n                // confirmed as a subset of UTF-8 in should_percent_encode.\n                for (i, &byte) in remaining.iter().enumerate() {\n                    if self.ascii_set.should_percent_encode(byte) {\n                        // 1 for first_byte + i for previous iterations of this loop\n                        let (unchanged_slice, remaining) = self.bytes.split_at(1 + i);\n                        self.bytes = remaining;\n                        return Some(unsafe { str::from_utf8_unchecked(unchanged_slice) });\n                    }\n                }\n                let unchanged_slice = self.bytes;\n                self.bytes = &[][..];\n                Some(unsafe { str::from_utf8_unchecked(unchanged_slice) })\n            }\n        } else {\n            None\n        }\n    }",
)
The code is Ok(
    "if let Some((&first_byte, remaining)) = self.bytes.split_first() {\n            if self.ascii_set.should_percent_encode(first_byte) {\n                self.bytes = remaining;\n                Some(percent_encode_byte(first_byte))\n            } else {\n                // The unsafe blocks here are appropriate because the bytes are\n                // confirmed as a subset of UTF-8 in should_percent_encode.\n                for (i, &byte) in remaining.iter().enumerate() {\n                    if self.ascii_set.should_percent_encode(byte) {\n                        // 1 for first_byte + i for previous iterations of this loop\n                        let (unchanged_slice, remaining) = self.bytes.split_at(1 + i);\n                        self.bytes = remaining;\n                        return Some(unsafe { str::from_utf8_unchecked(unchanged_slice) });\n                    }\n                }\n                let unchanged_slice = self.bytes;\n                self.bytes = &[][..];\n                Some(unsafe { str::from_utf8_unchecked(unchanged_slice) })\n            }\n        } else {\n            None\n        }",
)
The code is Ok(
    "self.bytes.split_first()",
)
The code is Ok(
    "self.bytes",
)
The code is Ok(
    "self",
)
The code is Ok(
    "if self.ascii_set.should_percent_encode(first_byte) {\n                self.bytes = remaining;\n                Some(percent_encode_byte(first_byte))\n            } else {\n                // The unsafe blocks here are appropriate because the bytes are\n                // confirmed as a subset of UTF-8 in should_percent_encode.\n                for (i, &byte) in remaining.iter().enumerate() {\n                    if self.ascii_set.should_percent_encode(byte) {\n                        // 1 for first_byte + i for previous iterations of this loop\n                        let (unchanged_slice, remaining) = self.bytes.split_at(1 + i);\n                        self.bytes = remaining;\n                        return Some(unsafe { str::from_utf8_unchecked(unchanged_slice) });\n                    }\n                }\n                let unchanged_slice = self.bytes;\n                self.bytes = &[][..];\n                Some(unsafe { str::from_utf8_unchecked(unchanged_slice) })\n            }",
)
The code is Ok(
    "self.ascii_set.should_percent_encode(first_byte)",
)
The code is Ok(
    "self.ascii_set",
)
The code is Ok(
    "self",
)
The code is Ok(
    "first_byte",
)
The code is Ok(
    "self.bytes = remaining",
)
The code is Ok(
    "remaining",
)
The code is Ok(
    "self.bytes",
)
The code is Ok(
    "self",
)
The code is Ok(
    "Some(percent_encode_byte(first_byte))",
)
resolved new call Call { call_expr: HirId(DefId(0:55 ~ percent_encoding[b3a7]::{impl#0}::next).32), call_expr_span: percent_encoding/src/lib.rs:154:17: 154:54 (#0), caller: Some(DefId(0:55 ~ percent_encoding[b3a7]::{impl#0}::next)), caller_span: None, callee: DefId(1:45302 ~ core[f118]::option::Option::Some::{constructor#0}), callee_span: percent_encoding/src/lib.rs:154:17: 154:21 (#0), callee_path: "core::prelude::v1::Some", constraint_depth: 2 }
The code is Ok(
    "Some",
)
The code is Ok(
    "percent_encode_byte(first_byte)",
)
resolved new call Call { call_expr: HirId(DefId(0:55 ~ percent_encoding[b3a7]::{impl#0}::next).35), call_expr_span: percent_encoding/src/lib.rs:154:22: 154:53 (#0), caller: Some(DefId(0:55 ~ percent_encoding[b3a7]::{impl#0}::next)), caller_span: None, callee: DefId(0:45 ~ percent_encoding[b3a7]::percent_encode_byte), callee_span: percent_encoding/src/lib.rs:154:22: 154:41 (#0), callee_path: "percent_encode_byte", constraint_depth: 2 }
The code is Ok(
    "percent_encode_byte",
)
The code is Ok(
    "first_byte",
)
The code is Ok(
    "for (i, &byte) in remaining.iter().enumerate() {\n                    if self.ascii_set.should_percent_encode(byte) {\n                        // 1 for first_byte + i for previous iterations of this loop\n                        let (unchanged_slice, remaining) = self.bytes.split_at(1 + i);\n                        self.bytes = remaining;\n                        return Some(unsafe { str::from_utf8_unchecked(unchanged_slice) });\n                    }\n                }",
)
The code is Ok(
    "for (i, &byte) in remaining.iter().enumerate() {\n                    if self.ascii_set.should_percent_encode(byte) {\n                        // 1 for first_byte + i for previous iterations of this loop\n                        let (unchanged_slice, remaining) = self.bytes.split_at(1 + i);\n                        self.bytes = remaining;\n                        return Some(unsafe { str::from_utf8_unchecked(unchanged_slice) });\n                    }\n                }",
)
into Match call
The code is Ok(
    "remaining.iter().enumerate()",
)
LangItem path: percent_encoding/src/lib.rs:158:35: 158:63 (#22)
The code is Ok(
    "remaining.iter().enumerate()",
)
The code is Ok(
    "remaining.iter().enumerate()",
)
The code is Ok(
    "remaining.iter()",
)
The code is Ok(
    "remaining",
)
The code is Ok(
    "for (i, &byte) in remaining.iter().enumerate() {\n                    if self.ascii_set.should_percent_encode(byte) {\n                        // 1 for first_byte + i for previous iterations of this loop\n                        let (unchanged_slice, remaining) = self.bytes.split_at(1 + i);\n                        self.bytes = remaining;\n                        return Some(unsafe { str::from_utf8_unchecked(unchanged_slice) });\n                    }\n                }",
)
The code is Ok(
    "remaining.iter().enumerate()",
)
into Match call
is inner Match
The code is Ok(
    "remaining.iter().enumerate()",
)
LangItem path: percent_encoding/src/lib.rs:158:35: 158:63 (#22)
The code is Ok(
    "remaining.iter().enumerate()",
)
The code is Ok(
    "remaining.iter().enumerate()",
)
The code is Ok(
    "remaining.iter().enumerate()",
)
The code is Ok(
    "for (i, &byte) in remaining.iter().enumerate() {\n                    if self.ascii_set.should_percent_encode(byte) {\n                        // 1 for first_byte + i for previous iterations of this loop\n                        let (unchanged_slice, remaining) = self.bytes.split_at(1 + i);\n                        self.bytes = remaining;\n                        return Some(unsafe { str::from_utf8_unchecked(unchanged_slice) });\n                    }\n                }",
)
The code is Ok(
    "{\n                    if self.ascii_set.should_percent_encode(byte) {\n                        // 1 for first_byte + i for previous iterations of this loop\n                        let (unchanged_slice, remaining) = self.bytes.split_at(1 + i);\n                        self.bytes = remaining;\n                        return Some(unsafe { str::from_utf8_unchecked(unchanged_slice) });\n                    }\n                }",
)
The code is Ok(
    "if self.ascii_set.should_percent_encode(byte) {\n                        // 1 for first_byte + i for previous iterations of this loop\n                        let (unchanged_slice, remaining) = self.bytes.split_at(1 + i);\n                        self.bytes = remaining;\n                        return Some(unsafe { str::from_utf8_unchecked(unchanged_slice) });\n                    }",
)
The code is Ok(
    "self.ascii_set.should_percent_encode(byte)",
)
The code is Ok(
    "self.ascii_set",
)
The code is Ok(
    "self",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "self.bytes.split_at(1 + i)",
)
The code is Ok(
    "self.bytes",
)
The code is Ok(
    "self",
)
The code is Ok(
    "1 + i",
)
The code is Ok(
    "1",
)
The code is Ok(
    "i",
)
The code is Ok(
    "self.bytes = remaining",
)
The code is Ok(
    "remaining",
)
The code is Ok(
    "self.bytes",
)
The code is Ok(
    "self",
)
The code is Ok(
    "return Some(unsafe { str::from_utf8_unchecked(unchanged_slice) })",
)
The code is Ok(
    "Some(unsafe { str::from_utf8_unchecked(unchanged_slice) })",
)
resolved new call Call { call_expr: HirId(DefId(0:55 ~ percent_encoding[b3a7]::{impl#0}::next).90), call_expr_span: percent_encoding/src/lib.rs:163:32: 163:90 (#0), caller: Some(DefId(0:55 ~ percent_encoding[b3a7]::{impl#0}::next)), caller_span: None, callee: DefId(1:45302 ~ core[f118]::option::Option::Some::{constructor#0}), callee_span: percent_encoding/src/lib.rs:163:32: 163:36 (#0), callee_path: "core::prelude::v1::Some", constraint_depth: 4 }
The code is Ok(
    "Some",
)
The code is Ok(
    "unsafe { str::from_utf8_unchecked(unchanged_slice) }",
)
The code is Ok(
    "str::from_utf8_unchecked(unchanged_slice)",
)
resolved new call Call { call_expr: HirId(DefId(0:55 ~ percent_encoding[b3a7]::{impl#0}::next).94), call_expr_span: percent_encoding/src/lib.rs:163:46: 163:87 (#0), caller: Some(DefId(0:55 ~ percent_encoding[b3a7]::{impl#0}::next)), caller_span: None, callee: DefId(1:12976 ~ core[f118]::str::converts::from_utf8_unchecked), callee_span: percent_encoding/src/lib.rs:163:46: 163:70 (#0), callee_path: "core::str::from_utf8_unchecked", constraint_depth: 4 }
The code is Ok(
    "str::from_utf8_unchecked",
)
The code is Ok(
    "unchanged_slice",
)
The code is Ok(
    "self.bytes",
)
The code is Ok(
    "self",
)
The code is Ok(
    "self.bytes = &[][..]",
)
The code is Ok(
    "&[][..]",
)
The code is Ok(
    "[][..]",
)
The code is Ok(
    "[]",
)
The code is Ok(
    "..",
)
The code is Ok(
    "self.bytes",
)
The code is Ok(
    "self",
)
The code is Ok(
    "Some(unsafe { str::from_utf8_unchecked(unchanged_slice) })",
)
resolved new call Call { call_expr: HirId(DefId(0:55 ~ percent_encoding[b3a7]::{impl#0}::next).137), call_expr_span: percent_encoding/src/lib.rs:168:17: 168:75 (#0), caller: Some(DefId(0:55 ~ percent_encoding[b3a7]::{impl#0}::next)), caller_span: None, callee: DefId(1:45302 ~ core[f118]::option::Option::Some::{constructor#0}), callee_span: percent_encoding/src/lib.rs:168:17: 168:21 (#0), callee_path: "core::prelude::v1::Some", constraint_depth: 2 }
The code is Ok(
    "Some",
)
The code is Ok(
    "unsafe { str::from_utf8_unchecked(unchanged_slice) }",
)
The code is Ok(
    "str::from_utf8_unchecked(unchanged_slice)",
)
resolved new call Call { call_expr: HirId(DefId(0:55 ~ percent_encoding[b3a7]::{impl#0}::next).141), call_expr_span: percent_encoding/src/lib.rs:168:31: 168:72 (#0), caller: Some(DefId(0:55 ~ percent_encoding[b3a7]::{impl#0}::next)), caller_span: None, callee: DefId(1:12976 ~ core[f118]::str::converts::from_utf8_unchecked), callee_span: percent_encoding/src/lib.rs:168:31: 168:55 (#0), callee_path: "core::str::from_utf8_unchecked", constraint_depth: 2 }
The code is Ok(
    "str::from_utf8_unchecked",
)
The code is Ok(
    "unchanged_slice",
)
The code is Ok(
    "None",
)
The code is Ok(
    "{\n        if self.bytes.is_empty() {\n            (0, Some(0))\n        } else {\n            (1, Some(self.bytes.len()))\n        }\n    }",
)
The code is Ok(
    "if self.bytes.is_empty() {\n            (0, Some(0))\n        } else {\n            (1, Some(self.bytes.len()))\n        }",
)
The code is Ok(
    "self.bytes.is_empty()",
)
The code is Ok(
    "self.bytes",
)
The code is Ok(
    "self",
)
The code is Ok(
    "(0, Some(0))",
)
The code is Ok(
    "0",
)
The code is Ok(
    "Some(0)",
)
resolved new call Call { call_expr: HirId(DefId(0:56 ~ percent_encoding[b3a7]::{impl#0}::size_hint).12), call_expr_span: percent_encoding/src/lib.rs:177:17: 177:24 (#0), caller: Some(DefId(0:56 ~ percent_encoding[b3a7]::{impl#0}::size_hint)), caller_span: None, callee: DefId(1:45302 ~ core[f118]::option::Option::Some::{constructor#0}), callee_span: percent_encoding/src/lib.rs:177:17: 177:21 (#0), callee_path: "core::prelude::v1::Some", constraint_depth: 1 }
The code is Ok(
    "Some",
)
The code is Ok(
    "0",
)
The code is Ok(
    "(1, Some(self.bytes.len()))",
)
The code is Ok(
    "1",
)
The code is Ok(
    "Some(self.bytes.len())",
)
resolved new call Call { call_expr: HirId(DefId(0:56 ~ percent_encoding[b3a7]::{impl#0}::size_hint).21), call_expr_span: percent_encoding/src/lib.rs:179:17: 179:39 (#0), caller: Some(DefId(0:56 ~ percent_encoding[b3a7]::{impl#0}::size_hint)), caller_span: None, callee: DefId(1:45302 ~ core[f118]::option::Option::Some::{constructor#0}), callee_span: percent_encoding/src/lib.rs:179:17: 179:21 (#0), callee_path: "core::prelude::v1::Some", constraint_depth: 1 }
The code is Ok(
    "Some",
)
The code is Ok(
    "self.bytes.len()",
)
The code is Ok(
    "self.bytes",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        for c in (*self).clone() {\n            formatter.write_str(c)?\n        }\n        Ok(())\n    }",
)
The code is Ok(
    "for c in (*self).clone() {\n            formatter.write_str(c)?\n        }",
)
The code is Ok(
    "for c in (*self).clone() {\n            formatter.write_str(c)?\n        }",
)
into Match call
The code is Ok(
    "(*self).clone()",
)
LangItem path: percent_encoding/src/lib.rs:186:18: 186:33 (#27)
The code is Ok(
    "(*self).clone()",
)
The code is Ok(
    "(*self).clone()",
)
The code is Ok(
    "(*self)",
)
The code is Ok(
    "self",
)
The code is Ok(
    "for c in (*self).clone() {\n            formatter.write_str(c)?\n        }",
)
The code is Ok(
    "(*self).clone()",
)
into Match call
is inner Match
The code is Ok(
    "(*self).clone()",
)
LangItem path: percent_encoding/src/lib.rs:186:18: 186:33 (#27)
The code is Ok(
    "(*self).clone()",
)
The code is Ok(
    "(*self).clone()",
)
The code is Ok(
    "(*self).clone()",
)
The code is Ok(
    "for c in (*self).clone() {\n            formatter.write_str(c)?\n        }",
)
The code is Ok(
    "{\n            formatter.write_str(c)?\n        }",
)
The code is Ok(
    "formatter.write_str(c)?",
)
into Match call
The code is Ok(
    "formatter.write_str(c)?",
)
LangItem path: percent_encoding/src/lib.rs:187:13: 187:36 (#29)
The code is Ok(
    "formatter.write_str(c)?",
)
The code is Ok(
    "formatter.write_str(c)",
)
The code is Ok(
    "formatter",
)
The code is Ok(
    "c",
)
The code is Ok(
    "?",
)
The code is Ok(
    "formatter.write_str(c)?",
)
LangItem path: percent_encoding/src/lib.rs:187:35: 187:36 (#30)
The code is Ok(
    "?",
)
The code is Ok(
    "?",
)
The code is Ok(
    "formatter.write_str(c)?",
)
The code is Ok(
    "Ok(())",
)
resolved new call Call { call_expr: HirId(DefId(0:58 ~ percent_encoding[b3a7]::{impl#1}::fmt).59), call_expr_span: percent_encoding/src/lib.rs:189:9: 189:15 (#0), caller: Some(DefId(0:58 ~ percent_encoding[b3a7]::{impl#1}::fmt)), caller_span: None, callee: DefId(1:45569 ~ core[f118]::result::Result::Ok::{constructor#0}), callee_span: percent_encoding/src/lib.rs:189:9: 189:11 (#0), callee_path: "core::prelude::v1::Ok", constraint_depth: 0 }
The code is Ok(
    "Ok",
)
The code is Ok(
    "()",
)
The code is Ok(
    "{\n        match iter.next() {\n            None => \"\".into(),\n            Some(first) => match iter.next() {\n                None => first.into(),\n                Some(second) => {\n                    let mut string = first.to_owned();\n                    string.push_str(second);\n                    string.extend(iter);\n                    string.into()\n                }\n            },\n        }\n    }",
)
The code is Ok(
    "match iter.next() {\n            None => \"\".into(),\n            Some(first) => match iter.next() {\n                None => first.into(),\n                Some(second) => {\n                    let mut string = first.to_owned();\n                    string.push_str(second);\n                    string.extend(iter);\n                    string.into()\n                }\n            },\n        }",
)
The code is Ok(
    "iter.next()",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "\"\".into()",
)
The code is Ok(
    "\"\"",
)
The code is Ok(
    "match iter.next() {\n                None => first.into(),\n                Some(second) => {\n                    let mut string = first.to_owned();\n                    string.push_str(second);\n                    string.extend(iter);\n                    string.into()\n                }\n            }",
)
The code is Ok(
    "iter.next()",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "first.into()",
)
The code is Ok(
    "first",
)
The code is Ok(
    "{\n                    let mut string = first.to_owned();\n                    string.push_str(second);\n                    string.extend(iter);\n                    string.into()\n                }",
)
The code is Ok(
    "first.to_owned()",
)
The code is Ok(
    "first",
)
The code is Ok(
    "string.push_str(second)",
)
The code is Ok(
    "string",
)
The code is Ok(
    "second",
)
The code is Ok(
    "string.extend(iter)",
)
The code is Ok(
    "string",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "string.into()",
)
The code is Ok(
    "string",
)
The code is Ok(
    "{\n        self.bytes.next().map(|&byte| {\n            if byte == b'%' {\n                after_percent_sign(&mut self.bytes).unwrap_or(byte)\n            } else {\n                byte\n            }\n        })\n    }",
)
The code is Ok(
    "self.bytes.next().map(|&byte| {\n            if byte == b'%' {\n                after_percent_sign(&mut self.bytes).unwrap_or(byte)\n            } else {\n                byte\n            }\n        })",
)
The code is Ok(
    "self.bytes.next()",
)
The code is Ok(
    "self.bytes",
)
The code is Ok(
    "self",
)
The code is Ok(
    "|&byte| {\n            if byte == b'%' {\n                after_percent_sign(&mut self.bytes).unwrap_or(byte)\n            } else {\n                byte\n            }\n        }",
)
The code is Ok(
    "{\n            if byte == b'%' {\n                after_percent_sign(&mut self.bytes).unwrap_or(byte)\n            } else {\n                byte\n            }\n        }",
)
The code is Ok(
    "if byte == b'%' {\n                after_percent_sign(&mut self.bytes).unwrap_or(byte)\n            } else {\n                byte\n            }",
)
The code is Ok(
    "byte == b'%'",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "b'%'",
)
The code is Ok(
    "after_percent_sign(&mut self.bytes).unwrap_or(byte)",
)
The code is Ok(
    "after_percent_sign(&mut self.bytes)",
)
resolved new call Call { call_expr: HirId(DefId(0:67 ~ percent_encoding[b3a7]::{impl#3}::next).23), call_expr_span: percent_encoding/src/lib.rs:266:17: 266:52 (#0), caller: Some(DefId(0:67 ~ percent_encoding[b3a7]::{impl#3}::next)), caller_span: None, callee: DefId(0:64 ~ percent_encoding[b3a7]::after_percent_sign), callee_span: percent_encoding/src/lib.rs:266:17: 266:35 (#0), callee_path: "after_percent_sign", constraint_depth: 1 }
The code is Ok(
    "after_percent_sign",
)
The code is Ok(
    "&mut self.bytes",
)
The code is Ok(
    "self.bytes",
)
The code is Ok(
    "self",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "{\n        let bytes = self.bytes.len();\n        ((bytes + 2) / 3, Some(bytes))\n    }",
)
The code is Ok(
    "self.bytes.len()",
)
The code is Ok(
    "self.bytes",
)
The code is Ok(
    "self",
)
The code is Ok(
    "((bytes + 2) / 3, Some(bytes))",
)
The code is Ok(
    "(bytes + 2) / 3",
)
The code is Ok(
    "(bytes + 2)",
)
The code is Ok(
    "bytes",
)
The code is Ok(
    "2",
)
The code is Ok(
    "3",
)
The code is Ok(
    "Some(bytes)",
)
resolved new call Call { call_expr: HirId(DefId(0:69 ~ percent_encoding[b3a7]::{impl#3}::size_hint).18), call_expr_span: percent_encoding/src/lib.rs:275:27: 275:38 (#0), caller: Some(DefId(0:69 ~ percent_encoding[b3a7]::{impl#3}::size_hint)), caller_span: None, callee: DefId(1:45302 ~ core[f118]::option::Option::Some::{constructor#0}), callee_span: percent_encoding/src/lib.rs:275:27: 275:31 (#0), callee_path: "core::prelude::v1::Some", constraint_depth: 0 }
The code is Ok(
    "Some",
)
The code is Ok(
    "bytes",
)
The code is Ok(
    "{\n        match iter.if_any() {\n            Some(vec) => Cow::Owned(vec),\n            None => Cow::Borrowed(iter.bytes.as_slice()),\n        }\n    }",
)
The code is Ok(
    "match iter.if_any() {\n            Some(vec) => Cow::Owned(vec),\n            None => Cow::Borrowed(iter.bytes.as_slice()),\n        }",
)
The code is Ok(
    "iter.if_any()",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "Cow::Owned(vec)",
)
resolved new call Call { call_expr: HirId(DefId(0:72 ~ percent_encoding[b3a7]::{impl#4}::from).12), call_expr_span: percent_encoding/src/lib.rs:283:26: 283:41 (#0), caller: Some(DefId(0:72 ~ percent_encoding[b3a7]::{impl#4}::from)), caller_span: None, callee: DefId(5:794 ~ alloc[186e]::borrow::Cow::Owned::{constructor#0}), callee_span: percent_encoding/src/lib.rs:283:26: 283:36 (#0), callee_path: "_::borrow::Cow::Owned", constraint_depth: 1 }
The code is Ok(
    "Cow::Owned",
)
The code is Ok(
    "vec",
)
The code is Ok(
    "Cow::Borrowed(iter.bytes.as_slice())",
)
resolved new call Call { call_expr: HirId(DefId(0:72 ~ percent_encoding[b3a7]::{impl#4}::from).21), call_expr_span: percent_encoding/src/lib.rs:284:21: 284:57 (#0), caller: Some(DefId(0:72 ~ percent_encoding[b3a7]::{impl#4}::from)), caller_span: None, callee: DefId(5:791 ~ alloc[186e]::borrow::Cow::Borrowed::{constructor#0}), callee_span: percent_encoding/src/lib.rs:284:21: 284:34 (#0), callee_path: "_::borrow::Cow::Borrowed", constraint_depth: 1 }
The code is Ok(
    "Cow::Borrowed",
)
The code is Ok(
    "iter.bytes.as_slice()",
)
The code is Ok(
    "iter.bytes",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "{\n        let mut bytes_iter = self.bytes.clone();\n        while bytes_iter.any(|&b| b == b'%') {\n            if let Some(decoded_byte) = after_percent_sign(&mut bytes_iter) {\n                let initial_bytes = self.bytes.as_slice();\n                let unchanged_bytes_len = initial_bytes.len() - bytes_iter.len() - 3;\n                let mut decoded = initial_bytes[..unchanged_bytes_len].to_owned();\n                decoded.push(decoded_byte);\n                decoded.extend(PercentDecode { bytes: bytes_iter });\n                return Some(decoded);\n            }\n        }\n        // Nothing to decode\n        None\n    }",
)
The code is Ok(
    "self.bytes.clone()",
)
The code is Ok(
    "self.bytes",
)
The code is Ok(
    "self",
)
The code is Ok(
    "while bytes_iter.any(|&b| b == b'%') {\n            if let Some(decoded_byte) = after_percent_sign(&mut bytes_iter) {\n                let initial_bytes = self.bytes.as_slice();\n                let unchanged_bytes_len = initial_bytes.len() - bytes_iter.len() - 3;\n                let mut decoded = initial_bytes[..unchanged_bytes_len].to_owned();\n                decoded.push(decoded_byte);\n                decoded.extend(PercentDecode { bytes: bytes_iter });\n                return Some(decoded);\n            }\n        }",
)
The code is Ok(
    "while bytes_iter.any(|&b| b == b'%') {\n            if let Some(decoded_byte) = after_percent_sign(&mut bytes_iter) {\n                let initial_bytes = self.bytes.as_slice();\n                let unchanged_bytes_len = initial_bytes.len() - bytes_iter.len() - 3;\n                let mut decoded = initial_bytes[..unchanged_bytes_len].to_owned();\n                decoded.push(decoded_byte);\n                decoded.extend(PercentDecode { bytes: bytes_iter });\n                return Some(decoded);\n            }\n        }",
)
The code is Ok(
    "bytes_iter.any(|&b| b == b'%')",
)
The code is Ok(
    "bytes_iter",
)
The code is Ok(
    "|&b| b == b'%'",
)
The code is Ok(
    "b == b'%'",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'%'",
)
The code is Ok(
    "if let Some(decoded_byte) = after_percent_sign(&mut bytes_iter) {\n                let initial_bytes = self.bytes.as_slice();\n                let unchanged_bytes_len = initial_bytes.len() - bytes_iter.len() - 3;\n                let mut decoded = initial_bytes[..unchanged_bytes_len].to_owned();\n                decoded.push(decoded_byte);\n                decoded.extend(PercentDecode { bytes: bytes_iter });\n                return Some(decoded);\n            }",
)
The code is Ok(
    "after_percent_sign(&mut bytes_iter)",
)
resolved new call Call { call_expr: HirId(DefId(0:75 ~ percent_encoding[b3a7]::{impl#5}::if_any).31), call_expr_span: percent_encoding/src/lib.rs:295:41: 295:76 (#0), caller: Some(DefId(0:75 ~ percent_encoding[b3a7]::{impl#5}::if_any)), caller_span: None, callee: DefId(0:64 ~ percent_encoding[b3a7]::after_percent_sign), callee_span: percent_encoding/src/lib.rs:295:41: 295:59 (#0), callee_path: "after_percent_sign", constraint_depth: 1 }
The code is Ok(
    "after_percent_sign",
)
The code is Ok(
    "&mut bytes_iter",
)
The code is Ok(
    "bytes_iter",
)
The code is Ok(
    "self.bytes.as_slice()",
)
The code is Ok(
    "self.bytes",
)
The code is Ok(
    "self",
)
The code is Ok(
    "initial_bytes.len() - bytes_iter.len() - 3",
)
The code is Ok(
    "initial_bytes.len() - bytes_iter.len()",
)
The code is Ok(
    "initial_bytes.len()",
)
The code is Ok(
    "initial_bytes",
)
The code is Ok(
    "bytes_iter.len()",
)
The code is Ok(
    "bytes_iter",
)
The code is Ok(
    "3",
)
The code is Ok(
    "initial_bytes[..unchanged_bytes_len].to_owned()",
)
The code is Ok(
    "initial_bytes[..unchanged_bytes_len]",
)
The code is Ok(
    "initial_bytes",
)
The code is Ok(
    "..unchanged_bytes_len",
)
The code is Ok(
    "unchanged_bytes_len",
)
The code is Ok(
    "decoded.push(decoded_byte)",
)
The code is Ok(
    "decoded",
)
The code is Ok(
    "decoded_byte",
)
The code is Ok(
    "decoded.extend(PercentDecode { bytes: bytes_iter })",
)
The code is Ok(
    "decoded",
)
The code is Ok(
    "PercentDecode { bytes: bytes_iter }",
)
The code is Ok(
    "bytes_iter",
)
The code is Ok(
    "return Some(decoded)",
)
The code is Ok(
    "Some(decoded)",
)
resolved new call Call { call_expr: HirId(DefId(0:75 ~ percent_encoding[b3a7]::{impl#5}::if_any).90), call_expr_span: percent_encoding/src/lib.rs:301:24: 301:37 (#0), caller: Some(DefId(0:75 ~ percent_encoding[b3a7]::{impl#5}::if_any)), caller_span: None, callee: DefId(1:45302 ~ core[f118]::option::Option::Some::{constructor#0}), callee_span: percent_encoding/src/lib.rs:301:24: 301:28 (#0), callee_path: "core::prelude::v1::Some", constraint_depth: 2 }
The code is Ok(
    "Some",
)
The code is Ok(
    "decoded",
)
The code is Ok(
    "while bytes_iter.any(|&b| b == b'%') {\n            if let Some(decoded_byte) = after_percent_sign(&mut bytes_iter) {\n                let initial_bytes = self.bytes.as_slice();\n                let unchanged_bytes_len = initial_bytes.len() - bytes_iter.len() - 3;\n                let mut decoded = initial_bytes[..unchanged_bytes_len].to_owned();\n                decoded.push(decoded_byte);\n                decoded.extend(PercentDecode { bytes: bytes_iter });\n                return Some(decoded);\n            }\n        }",
)
The code is Ok(
    "None",
)
The code is Ok(
    "{\n        match self.clone().into() {\n            Cow::Borrowed(bytes) => match str::from_utf8(bytes) {\n                Ok(s) => Ok(s.into()),\n                Err(e) => Err(e),\n            },\n            Cow::Owned(bytes) => match String::from_utf8(bytes) {\n                Ok(s) => Ok(s.into()),\n                Err(e) => Err(e.utf8_error()),\n            },\n        }\n    }",
)
The code is Ok(
    "match self.clone().into() {\n            Cow::Borrowed(bytes) => match str::from_utf8(bytes) {\n                Ok(s) => Ok(s.into()),\n                Err(e) => Err(e),\n            },\n            Cow::Owned(bytes) => match String::from_utf8(bytes) {\n                Ok(s) => Ok(s.into()),\n                Err(e) => Err(e.utf8_error()),\n            },\n        }",
)
The code is Ok(
    "self.clone().into()",
)
The code is Ok(
    "self.clone()",
)
The code is Ok(
    "self",
)
The code is Ok(
    "match str::from_utf8(bytes) {\n                Ok(s) => Ok(s.into()),\n                Err(e) => Err(e),\n            }",
)
into Match call
The code is Ok(
    "str::from_utf8(bytes)",
)
resolved new call Call { call_expr: HirId(DefId(0:77 ~ percent_encoding[b3a7]::{impl#5}::decode_utf8).16), call_expr_span: percent_encoding/src/lib.rs:314:43: 314:64 (#0), caller: Some(DefId(0:77 ~ percent_encoding[b3a7]::{impl#5}::decode_utf8)), caller_span: None, callee: DefId(1:12974 ~ core[f118]::str::converts::from_utf8), callee_span: percent_encoding/src/lib.rs:314:43: 314:57 (#0), callee_path: "core::str::from_utf8", constraint_depth: 2 }
The code is Ok(
    "str::from_utf8",
)
The code is Ok(
    "bytes",
)
The code is Ok(
    "Ok(s.into())",
)
resolved new call Call { call_expr: HirId(DefId(0:77 ~ percent_encoding[b3a7]::{impl#5}::decode_utf8).26), call_expr_span: percent_encoding/src/lib.rs:315:26: 315:38 (#0), caller: Some(DefId(0:77 ~ percent_encoding[b3a7]::{impl#5}::decode_utf8)), caller_span: None, callee: DefId(1:45569 ~ core[f118]::result::Result::Ok::{constructor#0}), callee_span: percent_encoding/src/lib.rs:315:26: 315:28 (#0), callee_path: "core::prelude::v1::Ok", constraint_depth: 2 }
The code is Ok(
    "Ok",
)
The code is Ok(
    "s.into()",
)
The code is Ok(
    "s",
)
The code is Ok(
    "Err(e)",
)
resolved new call Call { call_expr: HirId(DefId(0:77 ~ percent_encoding[b3a7]::{impl#5}::decode_utf8).37), call_expr_span: percent_encoding/src/lib.rs:316:27: 316:33 (#0), caller: Some(DefId(0:77 ~ percent_encoding[b3a7]::{impl#5}::decode_utf8)), caller_span: None, callee: DefId(1:45572 ~ core[f118]::result::Result::Err::{constructor#0}), callee_span: percent_encoding/src/lib.rs:316:27: 316:30 (#0), callee_path: "core::prelude::v1::Err", constraint_depth: 2 }
The code is Ok(
    "Err",
)
The code is Ok(
    "e",
)
The code is Ok(
    "match String::from_utf8(bytes) {\n                Ok(s) => Ok(s.into()),\n                Err(e) => Err(e.utf8_error()),\n            }",
)
into Match call
The code is Ok(
    "String::from_utf8(bytes)",
)
The code is Ok(
    "String::from_utf8",
)
The code is Ok(
    "bytes",
)
The code is Ok(
    "Ok(s.into())",
)
resolved new call Call { call_expr: HirId(DefId(0:77 ~ percent_encoding[b3a7]::{impl#5}::decode_utf8).59), call_expr_span: percent_encoding/src/lib.rs:319:26: 319:38 (#0), caller: Some(DefId(0:77 ~ percent_encoding[b3a7]::{impl#5}::decode_utf8)), caller_span: None, callee: DefId(1:45569 ~ core[f118]::result::Result::Ok::{constructor#0}), callee_span: percent_encoding/src/lib.rs:319:26: 319:28 (#0), callee_path: "core::prelude::v1::Ok", constraint_depth: 2 }
The code is Ok(
    "Ok",
)
The code is Ok(
    "s.into()",
)
The code is Ok(
    "s",
)
The code is Ok(
    "Err(e.utf8_error())",
)
resolved new call Call { call_expr: HirId(DefId(0:77 ~ percent_encoding[b3a7]::{impl#5}::decode_utf8).70), call_expr_span: percent_encoding/src/lib.rs:320:27: 320:46 (#0), caller: Some(DefId(0:77 ~ percent_encoding[b3a7]::{impl#5}::decode_utf8)), caller_span: None, callee: DefId(1:45572 ~ core[f118]::result::Result::Err::{constructor#0}), callee_span: percent_encoding/src/lib.rs:320:27: 320:30 (#0), callee_path: "core::prelude::v1::Err", constraint_depth: 2 }
The code is Ok(
    "Err",
)
The code is Ok(
    "e.utf8_error()",
)
The code is Ok(
    "e",
)
The code is Ok(
    "{\n        decode_utf8_lossy(self.clone().into())\n    }",
)
The code is Ok(
    "decode_utf8_lossy(self.clone().into())",
)
resolved new call Call { call_expr: HirId(DefId(0:78 ~ percent_encoding[b3a7]::{impl#5}::decode_utf8_lossy).3), call_expr_span: percent_encoding/src/lib.rs:331:9: 331:47 (#0), caller: Some(DefId(0:78 ~ percent_encoding[b3a7]::{impl#5}::decode_utf8_lossy)), caller_span: None, callee: DefId(0:79 ~ percent_encoding[b3a7]::decode_utf8_lossy), callee_span: percent_encoding/src/lib.rs:331:9: 331:26 (#0), callee_path: "decode_utf8_lossy", constraint_depth: 0 }
The code is Ok(
    "decode_utf8_lossy",
)
The code is Ok(
    "self.clone().into()",
)
The code is Ok(
    "self.clone()",
)
The code is Ok(
    "self",
)
Functions:
  Function: ascii_set::AsciiSet::should_percent_encode, Span: percent_encoding/src/ascii_set.rs:52:5: 54:6 (#0)
  Function: ascii_set::AsciiSet::contains, Span: percent_encoding/src/ascii_set.rs:46:5: 50:6 (#0)
  Function: ascii_set::AsciiSet::union, Span: percent_encoding/src/ascii_set.rs:69:5: 77:6 (#0)
  Function: decode_utf8_lossy, Span: percent_encoding/src/lib.rs:339:1: 365:2 (#0)
  Function: utf8_percent_encode, Span: percent_encoding/src/lib.rs:136:1: 138:2 (#0)
  Function: <PercentEncode<'a> as core::iter::Iterator>::size_hint, Span: percent_encoding/src/lib.rs:175:5: 181:6 (#0)
  Function: <impl core::convert::From<PercentEncode<'a>> for _::borrow::Cow<'a, str>>::from, Span: percent_encoding/src/lib.rs:195:5: 208:6 (#0)
  Function: ascii_set::AsciiSet::complement, Span: percent_encoding/src/ascii_set.rs:80:5: 83:6 (#0)
  Function: <PercentDecode<'_> as core::iter::Iterator>::next, Span: percent_encoding/src/lib.rs:263:5: 271:6 (#0)
  Function: PercentDecode::<'a>::decode_utf8_lossy, Span: percent_encoding/src/lib.rs:330:5: 332:6 (#0)
  Function: percent_encode_byte, Span: percent_encoding/src/lib.rs:73:1: 97:2 (#0)
  Function: percent_decode, Span: percent_encoding/src/lib.rs:240:1: 244:2 (#0)
  Function: after_percent_sign, Span: percent_encoding/src/lib.rs:252:1: 258:2 (#0)
  Function: percent_decode_str, Span: percent_encoding/src/lib.rs:217:1: 219:2 (#0)
  Function: PercentDecode::<'a>::if_any, Span: percent_encoding/src/lib.rs:292:5: 306:6 (#0)
  Function: percent_encode, Span: percent_encoding/src/lib.rs:117:1: 122:2 (#0)
  Function: <impl core::convert::From<PercentDecode<'a>> for _::borrow::Cow<'a, [u8]>>::from, Span: percent_encoding/src/lib.rs:281:5: 286:6 (#0)
  Function: ascii_set::AsciiSet::add, Span: percent_encoding/src/ascii_set.rs:56:5: 60:6 (#0)
  Function: <ascii_set::AsciiSet as core::ops::Add>::add, Span: percent_encoding/src/ascii_set.rs:89:5: 91:6 (#0)
  Function: <PercentDecode<'_> as core::iter::Iterator>::size_hint, Span: percent_encoding/src/lib.rs:273:5: 276:6 (#0)
  Function: <PercentEncode<'_> as core::fmt::Display>::fmt, Span: percent_encoding/src/lib.rs:185:5: 190:6 (#0)
  Function: PercentDecode::<'a>::decode_utf8, Span: percent_encoding/src/lib.rs:312:5: 323:6 (#0)
  Function: <PercentEncode<'a> as core::iter::Iterator>::next, Span: percent_encoding/src/lib.rs:150:5: 173:6 (#0)
  Function: ascii_set::AsciiSet::remove, Span: percent_encoding/src/ascii_set.rs:62:5: 66:6 (#0)
  Function: <ascii_set::AsciiSet as core::ops::Not>::not, Span: percent_encoding/src/ascii_set.rs:97:5: 99:6 (#0)

Method Declarations:

Method Implementations:
  Method Implementation for core::ops::Add::add: [DefId(0:38 ~ percent_encoding[b3a7]::ascii_set::{impl#1}::add)]
  Method Implementation for core::fmt::Display::fmt: [DefId(0:58 ~ percent_encoding[b3a7]::{impl#1}::fmt)]
  Method Implementation for core::ops::Not::not: [DefId(0:41 ~ percent_encoding[b3a7]::ascii_set::{impl#2}::not)]
  Method Implementation for core::iter::Iterator::next: [DefId(0:55 ~ percent_encoding[b3a7]::{impl#0}::next), DefId(0:67 ~ percent_encoding[b3a7]::{impl#3}::next)]
  Method Implementation for core::iter::Iterator::size_hint: [DefId(0:56 ~ percent_encoding[b3a7]::{impl#0}::size_hint), DefId(0:69 ~ percent_encoding[b3a7]::{impl#3}::size_hint)]
  Method Implementation for core::convert::From::from: [DefId(0:61 ~ percent_encoding[b3a7]::{impl#2}::from), DefId(0:72 ~ percent_encoding[b3a7]::{impl#4}::from)]

Static Calls:
PercentDecode::<'a>::decode_utf8 --- core::prelude::v1::Err (Constraint Depth: 2)
PercentDecode::<'a>::decode_utf8_lossy --- decode_utf8_lossy (Constraint Depth: 0)
percent_encode_byte --- core::str::from_utf8_unchecked (Constraint Depth: 0)
decode_utf8_lossy --- core::panicking::panic (Constraint Depth: 3)
<ascii_set::AsciiSet as core::ops::Add>::add --- ascii_set::AsciiSet::union (Constraint Depth: 0)
<impl core::convert::From<PercentEncode<'a>> for _::borrow::Cow<'a, str>>::from --- <PercentEncode<'a> as core::iter::Iterator>::next (Constraint Depth: 1)
percent_decode_str --- percent_decode (Constraint Depth: 0)
<PercentEncode<'_> as core::fmt::Display>::fmt --- core::prelude::v1::Ok (Constraint Depth: 0)
Unknown Caller --- core::mem::size_of (Constraint Depth: 0)
PercentDecode::<'a>::decode_utf8 --- <PercentDecode<'a> as core::clone::Clone>::clone (Constraint Depth: 1)
<PercentEncode<'a> as core::iter::Iterator>::next --- core::str::from_utf8_unchecked (Constraint Depth: 2)
decode_utf8_lossy --- _::string::String::from_utf8_unchecked (Constraint Depth: 2)
decode_utf8_lossy --- _::string::String::from_utf8_lossy (Constraint Depth: 1)
<impl core::convert::From<PercentDecode<'a>> for _::borrow::Cow<'a, [u8]>>::from --- _::borrow::Cow::Owned (Constraint Depth: 1)
<PercentEncode<'a> as core::iter::Iterator>::next --- percent_encode_byte (Constraint Depth: 2)
PercentDecode::<'a>::if_any --- after_percent_sign (Constraint Depth: 1)
after_percent_sign --- core::prelude::v1::Some (Constraint Depth: 0)
PercentDecode::<'a>::decode_utf8_lossy --- <PercentDecode<'a> as core::clone::Clone>::clone (Constraint Depth: 0)
<PercentDecode<'_> as core::iter::Iterator>::size_hint --- core::prelude::v1::Some (Constraint Depth: 0)
<impl core::convert::From<PercentDecode<'a>> for _::borrow::Cow<'a, [u8]>>::from --- PercentDecode::<'a>::if_any (Constraint Depth: 1)
ascii_set::AsciiSet::should_percent_encode --- ascii_set::AsciiSet::contains (Constraint Depth: 0)
<ascii_set::AsciiSet as core::ops::Not>::not --- ascii_set::AsciiSet::complement (Constraint Depth: 0)
<PercentEncode<'a> as core::iter::Iterator>::next --- ascii_set::AsciiSet::should_percent_encode (Constraint Depth: 1)
<PercentEncode<'_> as core::fmt::Display>::fmt --- <PercentEncode<'a> as core::clone::Clone>::clone (Constraint Depth: 1)
PercentDecode::<'a>::if_any --- core::prelude::v1::Some (Constraint Depth: 2)
<PercentEncode<'a> as core::iter::Iterator>::size_hint --- core::prelude::v1::Some (Constraint Depth: 1)
<PercentDecode<'_> as core::iter::Iterator>::next --- after_percent_sign (Constraint Depth: 1)
PercentDecode::<'a>::decode_utf8 --- core::prelude::v1::Ok (Constraint Depth: 2)
PercentDecode::<'a>::decode_utf8 --- core::str::from_utf8 (Constraint Depth: 2)
PercentDecode::<'a>::decode_utf8 --- _::string::String::from_utf8 (Constraint Depth: 2)
<impl core::convert::From<PercentDecode<'a>> for _::borrow::Cow<'a, [u8]>>::from --- _::borrow::Cow::Borrowed (Constraint Depth: 1)
decode_utf8_lossy --- _::borrow::Cow::Owned (Constraint Depth: 2)
<PercentEncode<'a> as core::iter::Iterator>::next --- core::prelude::v1::Some (Constraint Depth: 2)
utf8_percent_encode --- percent_encode (Constraint Depth: 0)

Dynamic Calls:

Non Local Calls:
percent_decode --- core::slice::<impl [T]>::iter (Constraint Depth: 0)
<PercentEncode<'a> as core::iter::Iterator>::next --- core::slice::<impl [T]>::iter (Constraint Depth: 3)
PercentDecode::<'a>::if_any --- <_::vec::Vec<T, A> as core::iter::Extend<T>>::extend (Constraint Depth: 2)
<impl core::convert::From<PercentEncode<'a>> for _::borrow::Cow<'a, str>>::from --- _::str::<impl _::borrow::ToOwned for str>::to_owned (Constraint Depth: 2)
PercentDecode::<'a>::decode_utf8_lossy --- <T as core::convert::Into<U>>::into (Constraint Depth: 0)
<impl core::convert::From<PercentEncode<'a>> for _::borrow::Cow<'a, str>>::from --- _::string::String::push_str (Constraint Depth: 2)
PercentDecode::<'a>::decode_utf8 --- _::string::FromUtf8Error::utf8_error (Constraint Depth: 2)
PercentDecode::<'a>::if_any --- <core::slice::Iter<'_, T> as core::clone::Clone>::clone (Constraint Depth: 0)
PercentDecode::<'a>::if_any --- _::vec::Vec::<T, A>::push (Constraint Depth: 2)
<PercentEncode<'a> as core::iter::Iterator>::size_hint --- core::slice::<impl [T]>::is_empty (Constraint Depth: 0)
PercentDecode::<'a>::if_any --- core::slice::<impl [T]>::len (Constraint Depth: 2)
<PercentEncode<'a> as core::iter::Iterator>::size_hint --- core::slice::<impl [T]>::len (Constraint Depth: 1)
<PercentDecode<'_> as core::iter::Iterator>::next --- <core::slice::Iter<'a, T> as core::iter::Iterator>::next (Constraint Depth: 0)
PercentDecode::<'a>::if_any --- core::slice::Iter::<'a, T>::as_slice (Constraint Depth: 2)
decode_utf8_lossy --- core::str::<impl str>::as_bytes (Constraint Depth: 2)
<PercentEncode<'a> as core::iter::Iterator>::next --- core::slice::<impl [T]>::split_at (Constraint Depth: 4)
PercentDecode::<'a>::if_any --- <core::slice::Iter<'a, T> as core::iter::Iterator>::any (Constraint Depth: 0)
PercentDecode::<'a>::if_any --- <core::slice::Iter<'_, T> as core::iter::ExactSizeIterator>::len (Constraint Depth: 2)
<PercentEncode<'a> as core::iter::Iterator>::next --- core::iter::Iterator::enumerate (Constraint Depth: 3)
<PercentDecode<'_> as core::iter::Iterator>::next --- core::option::Option::<T>::map (Constraint Depth: 0)
ascii_set::AsciiSet::should_percent_encode --- core::num::<impl u8>::is_ascii (Constraint Depth: 0)
PercentDecode::<'a>::if_any --- _::slice::<impl _::borrow::ToOwned for [T]>::to_owned (Constraint Depth: 2)
after_percent_sign --- <core::slice::Iter<'_, T> as core::clone::Clone>::clone (Constraint Depth: 0)
<PercentDecode<'_> as core::iter::Iterator>::size_hint --- <core::slice::Iter<'_, T> as core::iter::ExactSizeIterator>::len (Constraint Depth: 0)
after_percent_sign --- core::char::methods::<impl char>::to_digit (Constraint Depth: 0)
<impl core::convert::From<PercentEncode<'a>> for _::borrow::Cow<'a, str>>::from --- <T as core::convert::Into<U>>::into (Constraint Depth: 1)
<PercentDecode<'_> as core::iter::Iterator>::next --- core::option::Option::<T>::unwrap_or (Constraint Depth: 1)
<PercentEncode<'a> as core::iter::Iterator>::next --- core::slice::<impl [T]>::split_first (Constraint Depth: 0)
<impl core::convert::From<PercentEncode<'a>> for _::borrow::Cow<'a, str>>::from --- <_::string::String as core::iter::Extend<&'a str>>::extend (Constraint Depth: 2)
<impl core::convert::From<PercentDecode<'a>> for _::borrow::Cow<'a, [u8]>>::from --- core::slice::Iter::<'a, T>::as_slice (Constraint Depth: 1)
PercentDecode::<'a>::decode_utf8 --- <T as core::convert::Into<U>>::into (Constraint Depth: 1)
percent_decode_str --- core::str::<impl str>::as_bytes (Constraint Depth: 0)
<PercentEncode<'_> as core::fmt::Display>::fmt --- core::fmt::Formatter::<'a>::write_str (Constraint Depth: 1)
after_percent_sign --- <core::slice::Iter<'a, T> as core::iter::Iterator>::next (Constraint Depth: 0)
utf8_percent_encode --- core::str::<impl str>::as_bytes (Constraint Depth: 0)
The code is Ok(
    "{\n    Parse { input }\n}",
)
The code is Ok(
    "Parse { input }",
)
The code is Ok(
    "input",
)
The code is Ok(
    "{\n    let replaced = replace_plus(input);\n    decode_utf8_lossy(match percent_decode(&replaced).into() {\n        Cow::Owned(vec) => Cow::Owned(vec),\n        Cow::Borrowed(_) => replaced,\n    })\n}",
)
The code is Ok(
    "replace_plus(input)",
)
resolved new call Call { call_expr: HirId(DefId(0:22 ~ form_urlencoded[df2e]::decode).4), call_expr_span: form_urlencoded/src/lib.rs:71:20: 71:39 (#0), caller: Some(DefId(0:22 ~ form_urlencoded[df2e]::decode)), caller_span: None, callee: DefId(0:23 ~ form_urlencoded[df2e]::replace_plus), callee_span: form_urlencoded/src/lib.rs:71:20: 71:32 (#0), callee_path: "replace_plus", constraint_depth: 0 }
The code is Ok(
    "replace_plus",
)
The code is Ok(
    "input",
)
The code is Ok(
    "decode_utf8_lossy(match percent_decode(&replaced).into() {\n        Cow::Owned(vec) => Cow::Owned(vec),\n        Cow::Borrowed(_) => replaced,\n    })",
)
resolved new call Call { call_expr: HirId(DefId(0:22 ~ form_urlencoded[df2e]::decode).11), call_expr_span: form_urlencoded/src/lib.rs:72:5: 75:7 (#0), caller: Some(DefId(0:22 ~ form_urlencoded[df2e]::decode)), caller_span: None, callee: DefId(0:86 ~ form_urlencoded[df2e]::decode_utf8_lossy), callee_span: form_urlencoded/src/lib.rs:72:5: 72:22 (#0), callee_path: "decode_utf8_lossy", constraint_depth: 0 }
The code is Ok(
    "decode_utf8_lossy",
)
The code is Ok(
    "match percent_decode(&replaced).into() {\n        Cow::Owned(vec) => Cow::Owned(vec),\n        Cow::Borrowed(_) => replaced,\n    }",
)
The code is Ok(
    "percent_decode(&replaced).into()",
)
The code is Ok(
    "percent_decode(&replaced)",
)
resolved new call Call { call_expr: HirId(DefId(0:22 ~ form_urlencoded[df2e]::decode).17), call_expr_span: form_urlencoded/src/lib.rs:72:29: 72:54 (#0), caller: Some(DefId(0:22 ~ form_urlencoded[df2e]::decode)), caller_span: None, callee: DefId(20:63 ~ percent_encoding[b3a7]::percent_decode), callee_span: form_urlencoded/src/lib.rs:72:29: 72:43 (#0), callee_path: "percent_encoding::percent_decode", constraint_depth: 1 }
The code is Ok(
    "percent_decode",
)
The code is Ok(
    "&replaced",
)
The code is Ok(
    "replaced",
)
The code is Ok(
    "Cow::Owned(vec)",
)
resolved new call Call { call_expr: HirId(DefId(0:22 ~ form_urlencoded[df2e]::decode).28), call_expr_span: form_urlencoded/src/lib.rs:73:28: 73:43 (#0), caller: Some(DefId(0:22 ~ form_urlencoded[df2e]::decode)), caller_span: None, callee: DefId(5:794 ~ alloc[186e]::borrow::Cow::Owned::{constructor#0}), callee_span: form_urlencoded/src/lib.rs:73:28: 73:38 (#0), callee_path: "_::borrow::Cow::Owned", constraint_depth: 1 }
The code is Ok(
    "Cow::Owned",
)
The code is Ok(
    "vec",
)
The code is Ok(
    "replaced",
)
The code is Ok(
    "{\n    match input.iter().position(|&b| b == b'+') {\n        None => Cow::Borrowed(input),\n        Some(first_position) => {\n            let mut replaced = input.to_owned();\n            replaced[first_position] = b' ';\n            for byte in &mut replaced[first_position + 1..] {\n                if *byte == b'+' {\n                    *byte = b' ';\n                }\n            }\n            Cow::Owned(replaced)\n        }\n    }\n}",
)
The code is Ok(
    "match input.iter().position(|&b| b == b'+') {\n        None => Cow::Borrowed(input),\n        Some(first_position) => {\n            let mut replaced = input.to_owned();\n            replaced[first_position] = b' ';\n            for byte in &mut replaced[first_position + 1..] {\n                if *byte == b'+' {\n                    *byte = b' ';\n                }\n            }\n            Cow::Owned(replaced)\n        }\n    }",
)
The code is Ok(
    "input.iter().position(|&b| b == b'+')",
)
The code is Ok(
    "input.iter()",
)
The code is Ok(
    "input",
)
The code is Ok(
    "|&b| b == b'+'",
)
The code is Ok(
    "b == b'+'",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'+'",
)
The code is Ok(
    "Cow::Borrowed(input)",
)
resolved new call Call { call_expr: HirId(DefId(0:23 ~ form_urlencoded[df2e]::replace_plus).22), call_expr_span: form_urlencoded/src/lib.rs:81:17: 81:37 (#0), caller: Some(DefId(0:23 ~ form_urlencoded[df2e]::replace_plus)), caller_span: None, callee: DefId(5:791 ~ alloc[186e]::borrow::Cow::Borrowed::{constructor#0}), callee_span: form_urlencoded/src/lib.rs:81:17: 81:30 (#0), callee_path: "_::borrow::Cow::Borrowed", constraint_depth: 1 }
The code is Ok(
    "Cow::Borrowed",
)
The code is Ok(
    "input",
)
The code is Ok(
    "{\n            let mut replaced = input.to_owned();\n            replaced[first_position] = b' ';\n            for byte in &mut replaced[first_position + 1..] {\n                if *byte == b'+' {\n                    *byte = b' ';\n                }\n            }\n            Cow::Owned(replaced)\n        }",
)
The code is Ok(
    "input.to_owned()",
)
The code is Ok(
    "input",
)
The code is Ok(
    "replaced[first_position] = b' '",
)
The code is Ok(
    "b' '",
)
The code is Ok(
    "replaced[first_position]",
)
The code is Ok(
    "replaced",
)
The code is Ok(
    "first_position",
)
The code is Ok(
    "for byte in &mut replaced[first_position + 1..] {\n                if *byte == b'+' {\n                    *byte = b' ';\n                }\n            }",
)
The code is Ok(
    "for byte in &mut replaced[first_position + 1..] {\n                if *byte == b'+' {\n                    *byte = b' ';\n                }\n            }",
)
into Match call
The code is Ok(
    "&mut replaced[first_position + 1..]",
)
LangItem path: form_urlencoded/src/lib.rs:85:25: 85:60 (#23)
The code is Ok(
    "&mut replaced[first_position + 1..]",
)
The code is Ok(
    "&mut replaced[first_position + 1..]",
)
The code is Ok(
    "replaced[first_position + 1..]",
)
The code is Ok(
    "replaced",
)
The code is Ok(
    "first_position + 1..",
)
The code is Ok(
    "first_position + 1",
)
The code is Ok(
    "first_position",
)
The code is Ok(
    "1",
)
The code is Ok(
    "for byte in &mut replaced[first_position + 1..] {\n                if *byte == b'+' {\n                    *byte = b' ';\n                }\n            }",
)
The code is Ok(
    "&mut replaced[first_position + 1..]",
)
into Match call
is inner Match
The code is Ok(
    "&mut replaced[first_position + 1..]",
)
LangItem path: form_urlencoded/src/lib.rs:85:25: 85:60 (#23)
The code is Ok(
    "&mut replaced[first_position + 1..]",
)
The code is Ok(
    "&mut replaced[first_position + 1..]",
)
The code is Ok(
    "&mut replaced[first_position + 1..]",
)
The code is Ok(
    "for byte in &mut replaced[first_position + 1..] {\n                if *byte == b'+' {\n                    *byte = b' ';\n                }\n            }",
)
The code is Ok(
    "{\n                if *byte == b'+' {\n                    *byte = b' ';\n                }\n            }",
)
The code is Ok(
    "if *byte == b'+' {\n                    *byte = b' ';\n                }",
)
The code is Ok(
    "*byte == b'+'",
)
The code is Ok(
    "*byte",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "b'+'",
)
The code is Ok(
    "*byte = b' '",
)
The code is Ok(
    "b' '",
)
The code is Ok(
    "*byte",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "Cow::Owned(replaced)",
)
resolved new call Call { call_expr: HirId(DefId(0:23 ~ form_urlencoded[df2e]::replace_plus).98), call_expr_span: form_urlencoded/src/lib.rs:90:13: 90:33 (#0), caller: Some(DefId(0:23 ~ form_urlencoded[df2e]::replace_plus)), caller_span: None, callee: DefId(5:794 ~ alloc[186e]::borrow::Cow::Owned::{constructor#0}), callee_span: form_urlencoded/src/lib.rs:90:13: 90:23 (#0), callee_path: "_::borrow::Cow::Owned", constraint_depth: 1 }
The code is Ok(
    "Cow::Owned",
)
The code is Ok(
    "replaced",
)
The code is Ok(
    "{\n    ByteSerialize { bytes: input }\n}",
)
The code is Ok(
    "ByteSerialize { bytes: input }",
)
The code is Ok(
    "input",
)
The code is Ok(
    "{\n    matches!(byte, b'*' | b'-' | b'.' | b'0' ..= b'9' | b'A' ..= b'Z' | b'_' | b'a' ..= b'z')\n}",
)
The code is Ok(
    "match $expression {\n            $pattern $(if $guard)? => true,\n            _ => false\n        }",
)
The code is Ok(
    "byte",
)
The code is Ok(
    "b'*'",
)
The code is Ok(
    "b'-'",
)
The code is Ok(
    "b'.'",
)
The code is Ok(
    "b'0'",
)
The code is Ok(
    "b'9'",
)
The code is Ok(
    "b'A'",
)
The code is Ok(
    "b'Z'",
)
The code is Ok(
    "b'_'",
)
The code is Ok(
    "b'a'",
)
The code is Ok(
    "b'z'",
)
The code is Ok(
    "true",
)
The code is Ok(
    "false",
)
The code is Ok(
    "{\n    if string.len() > start_position {\n        string.push('&')\n    }\n}",
)
The code is Ok(
    "if string.len() > start_position {\n        string.push('&')\n    }",
)
The code is Ok(
    "string.len() > start_position",
)
The code is Ok(
    "string.len()",
)
The code is Ok(
    "string",
)
The code is Ok(
    "start_position",
)
The code is Ok(
    "string.push('&')",
)
The code is Ok(
    "string",
)
The code is Ok(
    "'&'",
)
The code is Ok(
    "{\n    target\n        .as_mut()\n        .expect(\"url::form_urlencoded::Serializer finished\")\n        .as_mut_string()\n}",
)
The code is Ok(
    "target\n        .as_mut()\n        .expect(\"url::form_urlencoded::Serializer finished\")\n        .as_mut_string()",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:79 ~ form_urlencoded[df2e]::string).3),
    call_expr_span: form_urlencoded/src/lib.rs:359:5: 362:25 (#0),
    caller: Some(
        DefId(0:79 ~ form_urlencoded[df2e]::string),
    ),
    caller_span: None,
    callee: DefId(0:50 ~ form_urlencoded[df2e]::Target::as_mut_string),
    callee_span: form_urlencoded/src/lib.rs:359:5: 362:25 (#0),
    callee_path: "Target::as_mut_string",
    constraint_depth: 0,
}
The code is Ok(
    "target\n        .as_mut()\n        .expect(\"url::form_urlencoded::Serializer finished\")",
)
The code is Ok(
    "target\n        .as_mut()",
)
The code is Ok(
    "target",
)
The code is Ok(
    "\"url::form_urlencoded::Serializer finished\"",
)
The code is Ok(
    "{\n    append_separator_if_needed(string, start_position);\n    append_encoded(name, string, encoding);\n    string.push('=');\n    append_encoded(value, string, encoding);\n}",
)
The code is Ok(
    "append_separator_if_needed(string, start_position)",
)
resolved new call Call { call_expr: HirId(DefId(0:81 ~ form_urlencoded[df2e]::append_pair).11), call_expr_span: form_urlencoded/src/lib.rs:372:5: 372:55 (#0), caller: Some(DefId(0:81 ~ form_urlencoded[df2e]::append_pair)), caller_span: None, callee: DefId(0:78 ~ form_urlencoded[df2e]::append_separator_if_needed), callee_span: form_urlencoded/src/lib.rs:372:5: 372:31 (#0), callee_path: "append_separator_if_needed", constraint_depth: 0 }
The code is Ok(
    "append_separator_if_needed",
)
The code is Ok(
    "string",
)
The code is Ok(
    "start_position",
)
The code is Ok(
    "append_encoded(name, string, encoding)",
)
resolved new call Call { call_expr: HirId(DefId(0:81 ~ form_urlencoded[df2e]::append_pair).19), call_expr_span: form_urlencoded/src/lib.rs:373:5: 373:43 (#0), caller: Some(DefId(0:81 ~ form_urlencoded[df2e]::append_pair)), caller_span: None, callee: DefId(0:83 ~ form_urlencoded[df2e]::append_encoded), callee_span: form_urlencoded/src/lib.rs:373:5: 373:19 (#0), callee_path: "append_encoded", constraint_depth: 0 }
The code is Ok(
    "append_encoded",
)
The code is Ok(
    "name",
)
The code is Ok(
    "string",
)
The code is Ok(
    "encoding",
)
The code is Ok(
    "string.push('=')",
)
The code is Ok(
    "string",
)
The code is Ok(
    "'='",
)
The code is Ok(
    "append_encoded(value, string, encoding)",
)
resolved new call Call { call_expr: HirId(DefId(0:81 ~ form_urlencoded[df2e]::append_pair).35), call_expr_span: form_urlencoded/src/lib.rs:375:5: 375:44 (#0), caller: Some(DefId(0:81 ~ form_urlencoded[df2e]::append_pair)), caller_span: None, callee: DefId(0:83 ~ form_urlencoded[df2e]::append_encoded), callee_span: form_urlencoded/src/lib.rs:375:5: 375:19 (#0), callee_path: "append_encoded", constraint_depth: 0 }
The code is Ok(
    "append_encoded",
)
The code is Ok(
    "value",
)
The code is Ok(
    "string",
)
The code is Ok(
    "encoding",
)
The code is Ok(
    "{\n    append_separator_if_needed(string, start_position);\n    append_encoded(name, string, encoding);\n}",
)
The code is Ok(
    "append_separator_if_needed(string, start_position)",
)
resolved new call Call { call_expr: HirId(DefId(0:82 ~ form_urlencoded[df2e]::append_key_only).9), call_expr_span: form_urlencoded/src/lib.rs:384:5: 384:55 (#0), caller: Some(DefId(0:82 ~ form_urlencoded[df2e]::append_key_only)), caller_span: None, callee: DefId(0:78 ~ form_urlencoded[df2e]::append_separator_if_needed), callee_span: form_urlencoded/src/lib.rs:384:5: 384:31 (#0), callee_path: "append_separator_if_needed", constraint_depth: 0 }
The code is Ok(
    "append_separator_if_needed",
)
The code is Ok(
    "string",
)
The code is Ok(
    "start_position",
)
The code is Ok(
    "append_encoded(name, string, encoding)",
)
resolved new call Call { call_expr: HirId(DefId(0:82 ~ form_urlencoded[df2e]::append_key_only).17), call_expr_span: form_urlencoded/src/lib.rs:385:5: 385:43 (#0), caller: Some(DefId(0:82 ~ form_urlencoded[df2e]::append_key_only)), caller_span: None, callee: DefId(0:83 ~ form_urlencoded[df2e]::append_encoded), callee_span: form_urlencoded/src/lib.rs:385:5: 385:19 (#0), callee_path: "append_encoded", constraint_depth: 0 }
The code is Ok(
    "append_encoded",
)
The code is Ok(
    "name",
)
The code is Ok(
    "string",
)
The code is Ok(
    "encoding",
)
The code is Ok(
    "{\n    string.extend(byte_serialize(&encode(encoding, s)))\n}",
)
The code is Ok(
    "string.extend(byte_serialize(&encode(encoding, s)))",
)
The code is Ok(
    "string",
)
The code is Ok(
    "byte_serialize(&encode(encoding, s))",
)
resolved new call Call { call_expr: HirId(DefId(0:83 ~ form_urlencoded[df2e]::append_encoded).11), call_expr_span: form_urlencoded/src/lib.rs:389:19: 389:55 (#0), caller: Some(DefId(0:83 ~ form_urlencoded[df2e]::append_encoded)), caller_span: None, callee: DefId(0:35 ~ form_urlencoded[df2e]::byte_serialize), callee_span: form_urlencoded/src/lib.rs:389:19: 389:33 (#0), callee_path: "byte_serialize", constraint_depth: 0 }
The code is Ok(
    "byte_serialize",
)
The code is Ok(
    "&encode(encoding, s)",
)
The code is Ok(
    "encode(encoding, s)",
)
resolved new call Call { call_expr: HirId(DefId(0:83 ~ form_urlencoded[df2e]::append_encoded).15), call_expr_span: form_urlencoded/src/lib.rs:389:35: 389:54 (#0), caller: Some(DefId(0:83 ~ form_urlencoded[df2e]::append_encoded)), caller_span: None, callee: DefId(0:84 ~ form_urlencoded[df2e]::encode), callee_span: form_urlencoded/src/lib.rs:389:35: 389:41 (#0), callee_path: "encode", constraint_depth: 0 }
The code is Ok(
    "encode",
)
The code is Ok(
    "encoding",
)
The code is Ok(
    "s",
)
The code is Ok(
    "{\n    if let Some(o) = encoding_override {\n        return o(input);\n    }\n    input.as_bytes().into()\n}",
)
The code is Ok(
    "if let Some(o) = encoding_override {\n        return o(input);\n    }",
)
The code is Ok(
    "encoding_override",
)
The code is Ok(
    "return o(input)",
)
The code is Ok(
    "o(input)",
)
The code is Ok(
    "o",
)
The code is Ok(
    "input",
)
The code is Ok(
    "input.as_bytes().into()",
)
The code is Ok(
    "input.as_bytes()",
)
The code is Ok(
    "input",
)
The code is Ok(
    "{\n    // Note: This function is duplicated in `percent_encoding/lib.rs`.\n    match input {\n        Cow::Borrowed(bytes) => String::from_utf8_lossy(bytes),\n        Cow::Owned(bytes) => {\n            match String::from_utf8_lossy(&bytes) {\n                Cow::Borrowed(utf8) => {\n                    // If from_utf8_lossy returns a Cow::Borrowed, then we can\n                    // be sure our original bytes were valid UTF-8. This is because\n                    // if the bytes were invalid UTF-8 from_utf8_lossy would have\n                    // to allocate a new owned string to back the Cow so it could\n                    // replace invalid bytes with a placeholder.\n\n                    // First we do a debug_assert to confirm our description above.\n                    let raw_utf8: *const [u8] = utf8.as_bytes();\n                    debug_assert!(raw_utf8 == &*bytes as *const [u8]);\n\n                    // Given we know the original input bytes are valid UTF-8,\n                    // and we have ownership of those bytes, we re-use them and\n                    // return a Cow::Owned here.\n                    Cow::Owned(unsafe { String::from_utf8_unchecked(bytes) })\n                }\n                Cow::Owned(s) => Cow::Owned(s),\n            }\n        }\n    }\n}",
)
The code is Ok(
    "match input {\n        Cow::Borrowed(bytes) => String::from_utf8_lossy(bytes),\n        Cow::Owned(bytes) => {\n            match String::from_utf8_lossy(&bytes) {\n                Cow::Borrowed(utf8) => {\n                    // If from_utf8_lossy returns a Cow::Borrowed, then we can\n                    // be sure our original bytes were valid UTF-8. This is because\n                    // if the bytes were invalid UTF-8 from_utf8_lossy would have\n                    // to allocate a new owned string to back the Cow so it could\n                    // replace invalid bytes with a placeholder.\n\n                    // First we do a debug_assert to confirm our description above.\n                    let raw_utf8: *const [u8] = utf8.as_bytes();\n                    debug_assert!(raw_utf8 == &*bytes as *const [u8]);\n\n                    // Given we know the original input bytes are valid UTF-8,\n                    // and we have ownership of those bytes, we re-use them and\n                    // return a Cow::Owned here.\n                    Cow::Owned(unsafe { String::from_utf8_unchecked(bytes) })\n                }\n                Cow::Owned(s) => Cow::Owned(s),\n            }\n        }\n    }",
)
The code is Ok(
    "input",
)
The code is Ok(
    "String::from_utf8_lossy(bytes)",
)
The code is Ok(
    "String::from_utf8_lossy",
)
The code is Ok(
    "bytes",
)
The code is Ok(
    "{\n            match String::from_utf8_lossy(&bytes) {\n                Cow::Borrowed(utf8) => {\n                    // If from_utf8_lossy returns a Cow::Borrowed, then we can\n                    // be sure our original bytes were valid UTF-8. This is because\n                    // if the bytes were invalid UTF-8 from_utf8_lossy would have\n                    // to allocate a new owned string to back the Cow so it could\n                    // replace invalid bytes with a placeholder.\n\n                    // First we do a debug_assert to confirm our description above.\n                    let raw_utf8: *const [u8] = utf8.as_bytes();\n                    debug_assert!(raw_utf8 == &*bytes as *const [u8]);\n\n                    // Given we know the original input bytes are valid UTF-8,\n                    // and we have ownership of those bytes, we re-use them and\n                    // return a Cow::Owned here.\n                    Cow::Owned(unsafe { String::from_utf8_unchecked(bytes) })\n                }\n                Cow::Owned(s) => Cow::Owned(s),\n            }\n        }",
)
The code is Ok(
    "match String::from_utf8_lossy(&bytes) {\n                Cow::Borrowed(utf8) => {\n                    // If from_utf8_lossy returns a Cow::Borrowed, then we can\n                    // be sure our original bytes were valid UTF-8. This is because\n                    // if the bytes were invalid UTF-8 from_utf8_lossy would have\n                    // to allocate a new owned string to back the Cow so it could\n                    // replace invalid bytes with a placeholder.\n\n                    // First we do a debug_assert to confirm our description above.\n                    let raw_utf8: *const [u8] = utf8.as_bytes();\n                    debug_assert!(raw_utf8 == &*bytes as *const [u8]);\n\n                    // Given we know the original input bytes are valid UTF-8,\n                    // and we have ownership of those bytes, we re-use them and\n                    // return a Cow::Owned here.\n                    Cow::Owned(unsafe { String::from_utf8_unchecked(bytes) })\n                }\n                Cow::Owned(s) => Cow::Owned(s),\n            }",
)
into Match call
The code is Ok(
    "String::from_utf8_lossy(&bytes)",
)
The code is Ok(
    "String::from_utf8_lossy",
)
The code is Ok(
    "&bytes",
)
The code is Ok(
    "bytes",
)
The code is Ok(
    "{\n                    // If from_utf8_lossy returns a Cow::Borrowed, then we can\n                    // be sure our original bytes were valid UTF-8. This is because\n                    // if the bytes were invalid UTF-8 from_utf8_lossy would have\n                    // to allocate a new owned string to back the Cow so it could\n                    // replace invalid bytes with a placeholder.\n\n                    // First we do a debug_assert to confirm our description above.\n                    let raw_utf8: *const [u8] = utf8.as_bytes();\n                    debug_assert!(raw_utf8 == &*bytes as *const [u8]);\n\n                    // Given we know the original input bytes are valid UTF-8,\n                    // and we have ownership of those bytes, we re-use them and\n                    // return a Cow::Owned here.\n                    Cow::Owned(unsafe { String::from_utf8_unchecked(bytes) })\n                }",
)
The code is Ok(
    "utf8.as_bytes()",
)
The code is Ok(
    "utf8",
)
The code is Ok(
    "if $crate::cfg!(debug_assertions) {\n            $crate::assert!($($arg)*);\n        }",
)
The code is Ok(
    "$crate::cfg!(debug_assertions)",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "raw_utf8 == &*bytes as *const [u8]",
)
The code is Ok(
    "raw_utf8",
)
The code is Ok(
    "&*bytes as *const [u8]",
)
The code is Ok(
    "&*bytes",
)
The code is Ok(
    "*bytes",
)
The code is Ok(
    "bytes",
)
The code is Ok(
    "$crate::assert!($($arg)*)",
)
resolved new call Call { call_expr: HirId(DefId(0:86 ~ form_urlencoded[df2e]::decode_utf8_lossy).68), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:335:13: 335:38 (#16), caller: Some(DefId(0:86 ~ form_urlencoded[df2e]::decode_utf8_lossy)), caller_span: None, callee: DefId(1:9575 ~ core[f118]::panicking::panic), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:335:13: 335:13 (#16), callee_path: "core::panicking::panic", constraint_depth: 3 }
The code is Ok(
    "$crate::assert!($($arg)*)",
)
The code is Ok(
    "",
)
The code is Ok(
    "Cow::Owned(unsafe { String::from_utf8_unchecked(bytes) })",
)
resolved new call Call { call_expr: HirId(DefId(0:86 ~ form_urlencoded[df2e]::decode_utf8_lossy).80), call_expr_span: form_urlencoded/src/lib.rs:422:21: 422:78 (#0), caller: Some(DefId(0:86 ~ form_urlencoded[df2e]::decode_utf8_lossy)), caller_span: None, callee: DefId(5:794 ~ alloc[186e]::borrow::Cow::Owned::{constructor#0}), callee_span: form_urlencoded/src/lib.rs:422:21: 422:31 (#0), callee_path: "_::borrow::Cow::Owned", constraint_depth: 2 }
The code is Ok(
    "Cow::Owned",
)
The code is Ok(
    "unsafe { String::from_utf8_unchecked(bytes) }",
)
The code is Ok(
    "String::from_utf8_unchecked(bytes)",
)
The code is Ok(
    "String::from_utf8_unchecked",
)
The code is Ok(
    "bytes",
)
The code is Ok(
    "Cow::Owned(s)",
)
resolved new call Call { call_expr: HirId(DefId(0:86 ~ form_urlencoded[df2e]::decode_utf8_lossy).99), call_expr_span: form_urlencoded/src/lib.rs:424:34: 424:47 (#0), caller: Some(DefId(0:86 ~ form_urlencoded[df2e]::decode_utf8_lossy)), caller_span: None, callee: DefId(5:794 ~ alloc[186e]::borrow::Cow::Owned::{constructor#0}), callee_span: form_urlencoded/src/lib.rs:424:34: 424:44 (#0), callee_path: "_::borrow::Cow::Owned", constraint_depth: 2 }
The code is Ok(
    "Cow::Owned",
)
The code is Ok(
    "s",
)
The code is Ok(
    "{\n        loop {\n            if self.input.is_empty() {\n                return None;\n            }\n            let mut split2 = self.input.splitn(2, |&b| b == b'&');\n            let sequence = split2.next().unwrap();\n            self.input = split2.next().unwrap_or(&[][..]);\n            if sequence.is_empty() {\n                continue;\n            }\n            let mut split2 = sequence.splitn(2, |&b| b == b'=');\n            let name = split2.next().unwrap();\n            let value = split2.next().unwrap_or(&[][..]);\n            return Some((decode(name), decode(value)));\n        }\n    }",
)
The code is Ok(
    "loop {\n            if self.input.is_empty() {\n                return None;\n            }\n            let mut split2 = self.input.splitn(2, |&b| b == b'&');\n            let sequence = split2.next().unwrap();\n            self.input = split2.next().unwrap_or(&[][..]);\n            if sequence.is_empty() {\n                continue;\n            }\n            let mut split2 = sequence.splitn(2, |&b| b == b'=');\n            let name = split2.next().unwrap();\n            let value = split2.next().unwrap_or(&[][..]);\n            return Some((decode(name), decode(value)));\n        }",
)
The code is Ok(
    "if self.input.is_empty() {\n                return None;\n            }",
)
The code is Ok(
    "self.input.is_empty()",
)
The code is Ok(
    "self.input",
)
The code is Ok(
    "self",
)
The code is Ok(
    "return None",
)
The code is Ok(
    "None",
)
The code is Ok(
    "self.input.splitn(2, |&b| b == b'&')",
)
The code is Ok(
    "self.input",
)
The code is Ok(
    "self",
)
The code is Ok(
    "2",
)
The code is Ok(
    "|&b| b == b'&'",
)
The code is Ok(
    "b == b'&'",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'&'",
)
The code is Ok(
    "split2.next().unwrap()",
)
The code is Ok(
    "split2.next()",
)
The code is Ok(
    "split2",
)
The code is Ok(
    "self.input = split2.next().unwrap_or(&[][..])",
)
The code is Ok(
    "split2.next().unwrap_or(&[][..])",
)
The code is Ok(
    "split2.next()",
)
The code is Ok(
    "split2",
)
The code is Ok(
    "&[][..]",
)
The code is Ok(
    "[][..]",
)
The code is Ok(
    "[]",
)
The code is Ok(
    "..",
)
The code is Ok(
    "self.input",
)
The code is Ok(
    "self",
)
The code is Ok(
    "if sequence.is_empty() {\n                continue;\n            }",
)
The code is Ok(
    "sequence.is_empty()",
)
The code is Ok(
    "sequence",
)
The code is Ok(
    "continue",
)
The code is Ok(
    "sequence.splitn(2, |&b| b == b'=')",
)
The code is Ok(
    "sequence",
)
The code is Ok(
    "2",
)
The code is Ok(
    "|&b| b == b'='",
)
The code is Ok(
    "b == b'='",
)
The code is Ok(
    "b",
)
The code is Ok(
    "b'='",
)
The code is Ok(
    "split2.next().unwrap()",
)
The code is Ok(
    "split2.next()",
)
The code is Ok(
    "split2",
)
The code is Ok(
    "split2.next().unwrap_or(&[][..])",
)
The code is Ok(
    "split2.next()",
)
The code is Ok(
    "split2",
)
The code is Ok(
    "&[][..]",
)
The code is Ok(
    "[][..]",
)
The code is Ok(
    "[]",
)
The code is Ok(
    "..",
)
The code is Ok(
    "return Some((decode(name), decode(value)))",
)
The code is Ok(
    "Some((decode(name), decode(value)))",
)
resolved new call Call { call_expr: HirId(DefId(0:19 ~ form_urlencoded[df2e]::{impl#0}::next).111), call_expr_span: form_urlencoded/src/lib.rs:65:20: 65:55 (#0), caller: Some(DefId(0:19 ~ form_urlencoded[df2e]::{impl#0}::next)), caller_span: None, callee: DefId(1:45302 ~ core[f118]::option::Option::Some::{constructor#0}), callee_span: form_urlencoded/src/lib.rs:65:20: 65:24 (#0), callee_path: "core::prelude::v1::Some", constraint_depth: 0 }
The code is Ok(
    "Some",
)
The code is Ok(
    "(decode(name), decode(value))",
)
The code is Ok(
    "decode(name)",
)
resolved new call Call { call_expr: HirId(DefId(0:19 ~ form_urlencoded[df2e]::{impl#0}::next).115), call_expr_span: form_urlencoded/src/lib.rs:65:26: 65:38 (#0), caller: Some(DefId(0:19 ~ form_urlencoded[df2e]::{impl#0}::next)), caller_span: None, callee: DefId(0:22 ~ form_urlencoded[df2e]::decode), callee_span: form_urlencoded/src/lib.rs:65:26: 65:32 (#0), callee_path: "decode", constraint_depth: 0 }
The code is Ok(
    "decode",
)
The code is Ok(
    "name",
)
The code is Ok(
    "decode(value)",
)
resolved new call Call { call_expr: HirId(DefId(0:19 ~ form_urlencoded[df2e]::{impl#0}::next).120), call_expr_span: form_urlencoded/src/lib.rs:65:40: 65:53 (#0), caller: Some(DefId(0:19 ~ form_urlencoded[df2e]::{impl#0}::next)), caller_span: None, callee: DefId(0:22 ~ form_urlencoded[df2e]::decode), callee_span: form_urlencoded/src/lib.rs:65:40: 65:46 (#0), callee_path: "decode", constraint_depth: 0 }
The code is Ok(
    "decode",
)
The code is Ok(
    "value",
)
The code is Ok(
    "{\n        ParseIntoOwned { inner: self }\n    }",
)
The code is Ok(
    "ParseIntoOwned { inner: self }",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        self.inner\n            .next()\n            .map(|(k, v)| (k.into_owned(), v.into_owned()))\n    }",
)
The code is Ok(
    "self.inner\n            .next()\n            .map(|(k, v)| (k.into_owned(), v.into_owned()))",
)
The code is Ok(
    "self.inner\n            .next()",
)
The code is Ok(
    "self.inner",
)
The code is Ok(
    "self",
)
The code is Ok(
    "|(k, v)| (k.into_owned(), v.into_owned())",
)
The code is Ok(
    "(k.into_owned(), v.into_owned())",
)
The code is Ok(
    "k.into_owned()",
)
The code is Ok(
    "k",
)
The code is Ok(
    "v.into_owned()",
)
The code is Ok(
    "v",
)
The code is Ok(
    "{\n        if let Some((&first, tail)) = self.bytes.split_first() {\n            if !byte_serialized_unchanged(first) {\n                self.bytes = tail;\n                return Some(if first == b' ' {\n                    \"+\"\n                } else {\n                    percent_encode_byte(first)\n                });\n            }\n            let position = tail.iter().position(|&b| !byte_serialized_unchanged(b));\n            let (unchanged_slice, remaining) = match position {\n                // 1 for first_byte + i unchanged in tail\n                Some(i) => self.bytes.split_at(1 + i),\n                None => (self.bytes, &[][..]),\n            };\n            self.bytes = remaining;\n            // This unsafe is appropriate because we have already checked these\n            // bytes in byte_serialized_unchanged, which checks for a subset\n            // of UTF-8. So we know these bytes are valid UTF-8, and doing\n            // another UTF-8 check would be wasteful.\n            Some(unsafe { str::from_utf8_unchecked(unchanged_slice) })\n        } else {\n            None\n        }\n    }",
)
The code is Ok(
    "if let Some((&first, tail)) = self.bytes.split_first() {\n            if !byte_serialized_unchanged(first) {\n                self.bytes = tail;\n                return Some(if first == b' ' {\n                    \"+\"\n                } else {\n                    percent_encode_byte(first)\n                });\n            }\n            let position = tail.iter().position(|&b| !byte_serialized_unchanged(b));\n            let (unchanged_slice, remaining) = match position {\n                // 1 for first_byte + i unchanged in tail\n                Some(i) => self.bytes.split_at(1 + i),\n                None => (self.bytes, &[][..]),\n            };\n            self.bytes = remaining;\n            // This unsafe is appropriate because we have already checked these\n            // bytes in byte_serialized_unchanged, which checks for a subset\n            // of UTF-8. So we know these bytes are valid UTF-8, and doing\n            // another UTF-8 check would be wasteful.\n            Some(unsafe { str::from_utf8_unchecked(unchanged_slice) })\n        } else {\n            None\n        }",
)
The code is Ok(
    "self.bytes.split_first()",
)
The code is Ok(
    "self.bytes",
)
The code is Ok(
    "self",
)
The code is Ok(
    "if !byte_serialized_unchanged(first) {\n                self.bytes = tail;\n                return Some(if first == b' ' {\n                    \"+\"\n                } else {\n                    percent_encode_byte(first)\n                });\n            }",
)
The code is Ok(
    "!byte_serialized_unchanged(first)",
)
The code is Ok(
    "byte_serialized_unchanged(first)",
)
resolved new call Call { call_expr: HirId(DefId(0:40 ~ form_urlencoded[df2e]::{impl#3}::next).18), call_expr_span: form_urlencoded/src/lib.rs:140:17: 140:49 (#0), caller: Some(DefId(0:40 ~ form_urlencoded[df2e]::{impl#3}::next)), caller_span: None, callee: DefId(0:36 ~ form_urlencoded[df2e]::byte_serialized_unchanged), callee_span: form_urlencoded/src/lib.rs:140:17: 140:42 (#0), callee_path: "byte_serialized_unchanged", constraint_depth: 1 }
The code is Ok(
    "byte_serialized_unchanged",
)
The code is Ok(
    "first",
)
The code is Ok(
    "self.bytes = tail",
)
The code is Ok(
    "tail",
)
The code is Ok(
    "self.bytes",
)
The code is Ok(
    "self",
)
The code is Ok(
    "return Some(if first == b' ' {\n                    \"+\"\n                } else {\n                    percent_encode_byte(first)\n                })",
)
The code is Ok(
    "Some(if first == b' ' {\n                    \"+\"\n                } else {\n                    percent_encode_byte(first)\n                })",
)
resolved new call Call { call_expr: HirId(DefId(0:40 ~ form_urlencoded[df2e]::{impl#3}::next).32), call_expr_span: form_urlencoded/src/lib.rs:142:24: 146:19 (#0), caller: Some(DefId(0:40 ~ form_urlencoded[df2e]::{impl#3}::next)), caller_span: None, callee: DefId(1:45302 ~ core[f118]::option::Option::Some::{constructor#0}), callee_span: form_urlencoded/src/lib.rs:142:24: 142:28 (#0), callee_path: "core::prelude::v1::Some", constraint_depth: 2 }
The code is Ok(
    "Some",
)
The code is Ok(
    "if first == b' ' {\n                    \"+\"\n                } else {\n                    percent_encode_byte(first)\n                }",
)
The code is Ok(
    "first == b' '",
)
The code is Ok(
    "first",
)
The code is Ok(
    "b' '",
)
The code is Ok(
    "\"+\"",
)
The code is Ok(
    "percent_encode_byte(first)",
)
resolved new call Call { call_expr: HirId(DefId(0:40 ~ form_urlencoded[df2e]::{impl#3}::next).45), call_expr_span: form_urlencoded/src/lib.rs:145:21: 145:47 (#0), caller: Some(DefId(0:40 ~ form_urlencoded[df2e]::{impl#3}::next)), caller_span: None, callee: DefId(20:45 ~ percent_encoding[b3a7]::percent_encode_byte), callee_span: form_urlencoded/src/lib.rs:145:21: 145:40 (#0), callee_path: "percent_encoding::percent_encode_byte", constraint_depth: 3 }
The code is Ok(
    "percent_encode_byte",
)
The code is Ok(
    "first",
)
The code is Ok(
    "tail.iter().position(|&b| !byte_serialized_unchanged(b))",
)
The code is Ok(
    "tail.iter()",
)
The code is Ok(
    "tail",
)
The code is Ok(
    "|&b| !byte_serialized_unchanged(b)",
)
The code is Ok(
    "!byte_serialized_unchanged(b)",
)
The code is Ok(
    "byte_serialized_unchanged(b)",
)
resolved new call Call { call_expr: HirId(DefId(0:40 ~ form_urlencoded[df2e]::{impl#3}::next).67), call_expr_span: form_urlencoded/src/lib.rs:148:55: 148:83 (#0), caller: Some(DefId(0:40 ~ form_urlencoded[df2e]::{impl#3}::next)), caller_span: None, callee: DefId(0:36 ~ form_urlencoded[df2e]::byte_serialized_unchanged), callee_span: form_urlencoded/src/lib.rs:148:55: 148:80 (#0), callee_path: "byte_serialized_unchanged", constraint_depth: 1 }
The code is Ok(
    "byte_serialized_unchanged",
)
The code is Ok(
    "b",
)
The code is Ok(
    "match position {\n                // 1 for first_byte + i unchanged in tail\n                Some(i) => self.bytes.split_at(1 + i),\n                None => (self.bytes, &[][..]),\n            }",
)
The code is Ok(
    "position",
)
The code is Ok(
    "self.bytes.split_at(1 + i)",
)
The code is Ok(
    "self.bytes",
)
The code is Ok(
    "self",
)
The code is Ok(
    "1 + i",
)
The code is Ok(
    "1",
)
The code is Ok(
    "i",
)
The code is Ok(
    "(self.bytes, &[][..])",
)
The code is Ok(
    "self.bytes",
)
The code is Ok(
    "self",
)
The code is Ok(
    "&[][..]",
)
The code is Ok(
    "[][..]",
)
The code is Ok(
    "[]",
)
The code is Ok(
    "..",
)
The code is Ok(
    "self.bytes = remaining",
)
The code is Ok(
    "remaining",
)
The code is Ok(
    "self.bytes",
)
The code is Ok(
    "self",
)
The code is Ok(
    "Some(unsafe { str::from_utf8_unchecked(unchanged_slice) })",
)
resolved new call Call { call_expr: HirId(DefId(0:40 ~ form_urlencoded[df2e]::{impl#3}::next).114), call_expr_span: form_urlencoded/src/lib.rs:159:13: 159:71 (#0), caller: Some(DefId(0:40 ~ form_urlencoded[df2e]::{impl#3}::next)), caller_span: None, callee: DefId(1:45302 ~ core[f118]::option::Option::Some::{constructor#0}), callee_span: form_urlencoded/src/lib.rs:159:13: 159:17 (#0), callee_path: "core::prelude::v1::Some", constraint_depth: 1 }
The code is Ok(
    "Some",
)
The code is Ok(
    "unsafe { str::from_utf8_unchecked(unchanged_slice) }",
)
The code is Ok(
    "str::from_utf8_unchecked(unchanged_slice)",
)
resolved new call Call { call_expr: HirId(DefId(0:40 ~ form_urlencoded[df2e]::{impl#3}::next).118), call_expr_span: form_urlencoded/src/lib.rs:159:27: 159:68 (#0), caller: Some(DefId(0:40 ~ form_urlencoded[df2e]::{impl#3}::next)), caller_span: None, callee: DefId(1:12976 ~ core[f118]::str::converts::from_utf8_unchecked), callee_span: form_urlencoded/src/lib.rs:159:27: 159:51 (#0), callee_path: "core::str::from_utf8_unchecked", constraint_depth: 1 }
The code is Ok(
    "str::from_utf8_unchecked",
)
The code is Ok(
    "unchanged_slice",
)
The code is Ok(
    "None",
)
The code is Ok(
    "{\n        if self.bytes.is_empty() {\n            (0, Some(0))\n        } else {\n            (1, Some(self.bytes.len()))\n        }\n    }",
)
The code is Ok(
    "if self.bytes.is_empty() {\n            (0, Some(0))\n        } else {\n            (1, Some(self.bytes.len()))\n        }",
)
The code is Ok(
    "self.bytes.is_empty()",
)
The code is Ok(
    "self.bytes",
)
The code is Ok(
    "self",
)
The code is Ok(
    "(0, Some(0))",
)
The code is Ok(
    "0",
)
The code is Ok(
    "Some(0)",
)
resolved new call Call { call_expr: HirId(DefId(0:42 ~ form_urlencoded[df2e]::{impl#3}::size_hint).12), call_expr_span: form_urlencoded/src/lib.rs:167:17: 167:24 (#0), caller: Some(DefId(0:42 ~ form_urlencoded[df2e]::{impl#3}::size_hint)), caller_span: None, callee: DefId(1:45302 ~ core[f118]::option::Option::Some::{constructor#0}), callee_span: form_urlencoded/src/lib.rs:167:17: 167:21 (#0), callee_path: "core::prelude::v1::Some", constraint_depth: 1 }
The code is Ok(
    "Some",
)
The code is Ok(
    "0",
)
The code is Ok(
    "(1, Some(self.bytes.len()))",
)
The code is Ok(
    "1",
)
The code is Ok(
    "Some(self.bytes.len())",
)
resolved new call Call { call_expr: HirId(DefId(0:42 ~ form_urlencoded[df2e]::{impl#3}::size_hint).21), call_expr_span: form_urlencoded/src/lib.rs:169:17: 169:39 (#0), caller: Some(DefId(0:42 ~ form_urlencoded[df2e]::{impl#3}::size_hint)), caller_span: None, callee: DefId(1:45302 ~ core[f118]::option::Option::Some::{constructor#0}), callee_span: form_urlencoded/src/lib.rs:169:17: 169:21 (#0), callee_path: "core::prelude::v1::Some", constraint_depth: 1 }
The code is Ok(
    "Some",
)
The code is Ok(
    "self.bytes.len()",
)
The code is Ok(
    "self.bytes",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        self\n    }",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        self\n    }",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        self\n    }",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        self\n    }",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        Self::for_suffix(target, 0)\n    }",
)
The code is Ok(
    "Self::for_suffix(target, 0)",
)
The code is Ok(
    "Self::for_suffix",
)
The code is Ok(
    "target",
)
The code is Ok(
    "0",
)
The code is Ok(
    "{\n        if target.as_mut_string().len() < start_position {\n            panic!(\n                \"invalid length {} for target of length {}\",\n                start_position,\n                target.as_mut_string().len()\n            );\n        }\n\n        Serializer {\n            target: Some(target),\n            start_position,\n            encoding: None,\n        }\n    }",
)
The code is Ok(
    "if target.as_mut_string().len() < start_position {\n            panic!(\n                \"invalid length {} for target of length {}\",\n                start_position,\n                target.as_mut_string().len()\n            );\n        }",
)
The code is Ok(
    "target.as_mut_string().len() < start_position",
)
The code is Ok(
    "target.as_mut_string().len()",
)
The code is Ok(
    "target.as_mut_string()",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:65 ~ form_urlencoded[df2e]::{impl#6}::for_suffix).9),
    call_expr_span: form_urlencoded/src/lib.rs:223:12: 223:34 (#0),
    caller: Some(
        DefId(0:65 ~ form_urlencoded[df2e]::{impl#6}::for_suffix),
    ),
    caller_span: None,
    callee: DefId(0:50 ~ form_urlencoded[df2e]::Target::as_mut_string),
    callee_span: form_urlencoded/src/lib.rs:223:12: 223:34 (#0),
    callee_path: "Target::as_mut_string",
    constraint_depth: 0,
}
The code is Ok(
    "target",
)
The code is Ok(
    "start_position",
)
The code is Ok(
    "{\n        // Semicolon to prevent temporaries inside the formatting machinery from\n        // being considered alive in the caller after the panic_fmt call.\n        $crate::panicking::panic_fmt($crate::const_format_args!($fmt, $($arg)+));\n    }",
)
The code is Ok(
    "$crate::panicking::panic_fmt($crate::const_format_args!($fmt, $($arg)+))",
)
resolved new call Call { call_expr: HirId(DefId(0:65 ~ form_urlencoded[df2e]::{impl#6}::for_suffix).17), call_expr_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:42:9: 42:81 (#12), caller: Some(DefId(0:65 ~ form_urlencoded[df2e]::{impl#6}::for_suffix)), caller_span: None, callee: DefId(1:9567 ~ core[f118]::panicking::panic_fmt), callee_span: /home/cindy/.rustup/toolchains/nightly-2024-08-07-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:42:9: 42:37 (#12), callee_path: "core::panicking::panic_fmt", constraint_depth: 1 }
The code is Ok(
    "$crate::panicking::panic_fmt",
)
The code is Ok(
    "$crate::const_format_args!($fmt, $($arg)+)",
)
The code is Ok(
    "$crate::const_format_args!($fmt, $($arg)+)",
)
The code is Ok(
    "\"invalid length {} for target of length {}\"",
)
The code is Ok(
    "\"invalid length {} for target of length {}\"",
)
The code is Ok(
    "\"invalid length {} for target of length {}\"",
)
The code is Ok(
    "\"invalid length {} for target of length {}\"",
)
The code is Ok(
    "$crate::const_format_args!($fmt, $($arg)+)",
)
The code is Ok(
    "$crate::const_format_args!($fmt, $($arg)+)",
)
The code is Ok(
    "{}",
)
The code is Ok(
    "{}",
)
The code is Ok(
    "start_position",
)
The code is Ok(
    "start_position",
)
The code is Ok(
    "{}",
)
The code is Ok(
    "{}",
)
The code is Ok(
    "target.as_mut_string().len()",
)
The code is Ok(
    "target.as_mut_string().len()",
)
The code is Ok(
    "target.as_mut_string()",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:65 ~ form_urlencoded[df2e]::{impl#6}::for_suffix).37),
    call_expr_span: form_urlencoded/src/lib.rs:227:17: 227:39 (#0),
    caller: Some(
        DefId(0:65 ~ form_urlencoded[df2e]::{impl#6}::for_suffix),
    ),
    caller_span: None,
    callee: DefId(0:50 ~ form_urlencoded[df2e]::Target::as_mut_string),
    callee_span: form_urlencoded/src/lib.rs:227:17: 227:39 (#0),
    callee_path: "Target::as_mut_string",
    constraint_depth: 1,
}
The code is Ok(
    "target",
)
The code is Ok(
    "Serializer {\n            target: Some(target),\n            start_position,\n            encoding: None,\n        }",
)
The code is Ok(
    "Some(target)",
)
resolved new call Call { call_expr: HirId(DefId(0:65 ~ form_urlencoded[df2e]::{impl#6}::for_suffix).63), call_expr_span: form_urlencoded/src/lib.rs:232:21: 232:33 (#0), caller: Some(DefId(0:65 ~ form_urlencoded[df2e]::{impl#6}::for_suffix)), caller_span: None, callee: DefId(1:45302 ~ core[f118]::option::Option::Some::{constructor#0}), callee_span: form_urlencoded/src/lib.rs:232:21: 232:25 (#0), callee_path: "core::prelude::v1::Some", constraint_depth: 0 }
The code is Ok(
    "Some",
)
The code is Ok(
    "target",
)
The code is Ok(
    "start_position",
)
The code is Ok(
    "None",
)
The code is Ok(
    "{\n        string(&mut self.target).truncate(self.start_position);\n        self\n    }",
)
The code is Ok(
    "string(&mut self.target).truncate(self.start_position)",
)
The code is Ok(
    "string(&mut self.target)",
)
resolved new call Call { call_expr: HirId(DefId(0:66 ~ form_urlencoded[df2e]::{impl#6}::clear).5), call_expr_span: form_urlencoded/src/lib.rs:242:9: 242:33 (#0), caller: Some(DefId(0:66 ~ form_urlencoded[df2e]::{impl#6}::clear)), caller_span: None, callee: DefId(0:79 ~ form_urlencoded[df2e]::string), callee_span: form_urlencoded/src/lib.rs:242:9: 242:15 (#0), callee_path: "string", constraint_depth: 0 }
The code is Ok(
    "string",
)
The code is Ok(
    "&mut self.target",
)
The code is Ok(
    "self.target",
)
The code is Ok(
    "self",
)
The code is Ok(
    "self.start_position",
)
The code is Ok(
    "self",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        self.encoding = new;\n        self\n    }",
)
The code is Ok(
    "self.encoding = new",
)
The code is Ok(
    "new",
)
The code is Ok(
    "self.encoding",
)
The code is Ok(
    "self",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        append_pair(\n            string(&mut self.target),\n            self.start_position,\n            self.encoding,\n            name,\n            value,\n        );\n        self\n    }",
)
The code is Ok(
    "append_pair(\n            string(&mut self.target),\n            self.start_position,\n            self.encoding,\n            name,\n            value,\n        )",
)
resolved new call Call { call_expr: HirId(DefId(0:68 ~ form_urlencoded[df2e]::{impl#6}::append_pair).7), call_expr_span: form_urlencoded/src/lib.rs:256:9: 262:10 (#0), caller: Some(DefId(0:68 ~ form_urlencoded[df2e]::{impl#6}::append_pair)), caller_span: None, callee: DefId(0:81 ~ form_urlencoded[df2e]::append_pair), callee_span: form_urlencoded/src/lib.rs:256:9: 256:20 (#0), callee_path: "append_pair", constraint_depth: 0 }
The code is Ok(
    "append_pair",
)
The code is Ok(
    "string(&mut self.target)",
)
resolved new call Call { call_expr: HirId(DefId(0:68 ~ form_urlencoded[df2e]::{impl#6}::append_pair).10), call_expr_span: form_urlencoded/src/lib.rs:257:13: 257:37 (#0), caller: Some(DefId(0:68 ~ form_urlencoded[df2e]::{impl#6}::append_pair)), caller_span: None, callee: DefId(0:79 ~ form_urlencoded[df2e]::string), callee_span: form_urlencoded/src/lib.rs:257:13: 257:19 (#0), callee_path: "string", constraint_depth: 0 }
The code is Ok(
    "string",
)
The code is Ok(
    "&mut self.target",
)
The code is Ok(
    "self.target",
)
The code is Ok(
    "self",
)
The code is Ok(
    "self.start_position",
)
The code is Ok(
    "self",
)
The code is Ok(
    "self.encoding",
)
The code is Ok(
    "self",
)
The code is Ok(
    "name",
)
The code is Ok(
    "value",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        append_key_only(\n            string(&mut self.target),\n            self.start_position,\n            self.encoding,\n            name,\n        );\n        self\n    }",
)
The code is Ok(
    "append_key_only(\n            string(&mut self.target),\n            self.start_position,\n            self.encoding,\n            name,\n        )",
)
resolved new call Call { call_expr: HirId(DefId(0:69 ~ form_urlencoded[df2e]::{impl#6}::append_key_only).5), call_expr_span: form_urlencoded/src/lib.rs:270:9: 275:10 (#0), caller: Some(DefId(0:69 ~ form_urlencoded[df2e]::{impl#6}::append_key_only)), caller_span: None, callee: DefId(0:82 ~ form_urlencoded[df2e]::append_key_only), callee_span: form_urlencoded/src/lib.rs:270:9: 270:24 (#0), callee_path: "append_key_only", constraint_depth: 0 }
The code is Ok(
    "append_key_only",
)
The code is Ok(
    "string(&mut self.target)",
)
resolved new call Call { call_expr: HirId(DefId(0:69 ~ form_urlencoded[df2e]::{impl#6}::append_key_only).8), call_expr_span: form_urlencoded/src/lib.rs:271:13: 271:37 (#0), caller: Some(DefId(0:69 ~ form_urlencoded[df2e]::{impl#6}::append_key_only)), caller_span: None, callee: DefId(0:79 ~ form_urlencoded[df2e]::string), callee_span: form_urlencoded/src/lib.rs:271:13: 271:19 (#0), callee_path: "string", constraint_depth: 0 }
The code is Ok(
    "string",
)
The code is Ok(
    "&mut self.target",
)
The code is Ok(
    "self.target",
)
The code is Ok(
    "self",
)
The code is Ok(
    "self.start_position",
)
The code is Ok(
    "self",
)
The code is Ok(
    "self.encoding",
)
The code is Ok(
    "self",
)
The code is Ok(
    "name",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        {\n            let string = string(&mut self.target);\n            for pair in iter {\n                let (k, v) = pair.borrow();\n                append_pair(\n                    string,\n                    self.start_position,\n                    self.encoding,\n                    k.as_ref(),\n                    v.as_ref(),\n                );\n            }\n        }\n        self\n    }",
)
The code is Ok(
    "{\n            let string = string(&mut self.target);\n            for pair in iter {\n                let (k, v) = pair.borrow();\n                append_pair(\n                    string,\n                    self.start_position,\n                    self.encoding,\n                    k.as_ref(),\n                    v.as_ref(),\n                );\n            }\n        }",
)
The code is Ok(
    "string(&mut self.target)",
)
resolved new call Call { call_expr: HirId(DefId(0:70 ~ form_urlencoded[df2e]::{impl#6}::extend_pairs).7), call_expr_span: form_urlencoded/src/lib.rs:294:26: 294:50 (#0), caller: Some(DefId(0:70 ~ form_urlencoded[df2e]::{impl#6}::extend_pairs)), caller_span: None, callee: DefId(0:79 ~ form_urlencoded[df2e]::string), callee_span: form_urlencoded/src/lib.rs:294:26: 294:32 (#0), callee_path: "string", constraint_depth: 0 }
The code is Ok(
    "string",
)
The code is Ok(
    "&mut self.target",
)
The code is Ok(
    "self.target",
)
The code is Ok(
    "self",
)
The code is Ok(
    "for pair in iter {\n                let (k, v) = pair.borrow();\n                append_pair(\n                    string,\n                    self.start_position,\n                    self.encoding,\n                    k.as_ref(),\n                    v.as_ref(),\n                );\n            }",
)
The code is Ok(
    "for pair in iter {\n                let (k, v) = pair.borrow();\n                append_pair(\n                    string,\n                    self.start_position,\n                    self.encoding,\n                    k.as_ref(),\n                    v.as_ref(),\n                );\n            }",
)
into Match call
The code is Ok(
    "iter",
)
LangItem path: form_urlencoded/src/lib.rs:295:25: 295:29 (#31)
The code is Ok(
    "iter",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "for pair in iter {\n                let (k, v) = pair.borrow();\n                append_pair(\n                    string,\n                    self.start_position,\n                    self.encoding,\n                    k.as_ref(),\n                    v.as_ref(),\n                );\n            }",
)
The code is Ok(
    "iter",
)
into Match call
is inner Match
The code is Ok(
    "iter",
)
LangItem path: form_urlencoded/src/lib.rs:295:25: 295:29 (#31)
The code is Ok(
    "iter",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "for pair in iter {\n                let (k, v) = pair.borrow();\n                append_pair(\n                    string,\n                    self.start_position,\n                    self.encoding,\n                    k.as_ref(),\n                    v.as_ref(),\n                );\n            }",
)
The code is Ok(
    "{\n                let (k, v) = pair.borrow();\n                append_pair(\n                    string,\n                    self.start_position,\n                    self.encoding,\n                    k.as_ref(),\n                    v.as_ref(),\n                );\n            }",
)
The code is Ok(
    "pair.borrow()",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:70 ~ form_urlencoded[df2e]::{impl#6}::extend_pairs).26),
    call_expr_span: form_urlencoded/src/lib.rs:296:30: 296:43 (#0),
    caller: Some(
        DefId(0:70 ~ form_urlencoded[df2e]::{impl#6}::extend_pairs),
    ),
    caller_span: None,
    callee: DefId(1:2784 ~ core[f118]::borrow::Borrow::borrow),
    callee_span: form_urlencoded/src/lib.rs:296:30: 296:43 (#0),
    callee_path: "core::borrow::Borrow::borrow",
    constraint_depth: 1,
}
The code is Ok(
    "pair",
)
The code is Ok(
    "append_pair(\n                    string,\n                    self.start_position,\n                    self.encoding,\n                    k.as_ref(),\n                    v.as_ref(),\n                )",
)
resolved new call Call { call_expr: HirId(DefId(0:70 ~ form_urlencoded[df2e]::{impl#6}::extend_pairs).34), call_expr_span: form_urlencoded/src/lib.rs:297:17: 303:18 (#0), caller: Some(DefId(0:70 ~ form_urlencoded[df2e]::{impl#6}::extend_pairs)), caller_span: None, callee: DefId(0:81 ~ form_urlencoded[df2e]::append_pair), callee_span: form_urlencoded/src/lib.rs:297:17: 297:28 (#0), callee_path: "append_pair", constraint_depth: 1 }
The code is Ok(
    "append_pair",
)
The code is Ok(
    "string",
)
The code is Ok(
    "self.start_position",
)
The code is Ok(
    "self",
)
The code is Ok(
    "self.encoding",
)
The code is Ok(
    "self",
)
The code is Ok(
    "k.as_ref()",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:70 ~ form_urlencoded[df2e]::{impl#6}::extend_pairs).45),
    call_expr_span: form_urlencoded/src/lib.rs:301:21: 301:31 (#0),
    caller: Some(
        DefId(0:70 ~ form_urlencoded[df2e]::{impl#6}::extend_pairs),
    ),
    caller_span: None,
    callee: DefId(1:3063 ~ core[f118]::convert::AsRef::as_ref),
    callee_span: form_urlencoded/src/lib.rs:301:21: 301:31 (#0),
    callee_path: "core::convert::AsRef::as_ref",
    constraint_depth: 1,
}
The code is Ok(
    "k",
)
The code is Ok(
    "v.as_ref()",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:70 ~ form_urlencoded[df2e]::{impl#6}::extend_pairs).49),
    call_expr_span: form_urlencoded/src/lib.rs:302:21: 302:31 (#0),
    caller: Some(
        DefId(0:70 ~ form_urlencoded[df2e]::{impl#6}::extend_pairs),
    ),
    caller_span: None,
    callee: DefId(1:3063 ~ core[f118]::convert::AsRef::as_ref),
    callee_span: form_urlencoded/src/lib.rs:302:21: 302:31 (#0),
    callee_path: "core::convert::AsRef::as_ref",
    constraint_depth: 1,
}
The code is Ok(
    "v",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        {\n            let string = string(&mut self.target);\n            for key in iter {\n                let k = key.borrow().as_ref();\n                append_key_only(string, self.start_position, self.encoding, k);\n            }\n        }\n        self\n    }",
)
The code is Ok(
    "{\n            let string = string(&mut self.target);\n            for key in iter {\n                let k = key.borrow().as_ref();\n                append_key_only(string, self.start_position, self.encoding, k);\n            }\n        }",
)
The code is Ok(
    "string(&mut self.target)",
)
resolved new call Call { call_expr: HirId(DefId(0:74 ~ form_urlencoded[df2e]::{impl#6}::extend_keys_only).7), call_expr_span: form_urlencoded/src/lib.rs:323:26: 323:50 (#0), caller: Some(DefId(0:74 ~ form_urlencoded[df2e]::{impl#6}::extend_keys_only)), caller_span: None, callee: DefId(0:79 ~ form_urlencoded[df2e]::string), callee_span: form_urlencoded/src/lib.rs:323:26: 323:32 (#0), callee_path: "string", constraint_depth: 0 }
The code is Ok(
    "string",
)
The code is Ok(
    "&mut self.target",
)
The code is Ok(
    "self.target",
)
The code is Ok(
    "self",
)
The code is Ok(
    "for key in iter {\n                let k = key.borrow().as_ref();\n                append_key_only(string, self.start_position, self.encoding, k);\n            }",
)
The code is Ok(
    "for key in iter {\n                let k = key.borrow().as_ref();\n                append_key_only(string, self.start_position, self.encoding, k);\n            }",
)
into Match call
The code is Ok(
    "iter",
)
LangItem path: form_urlencoded/src/lib.rs:324:24: 324:28 (#34)
The code is Ok(
    "iter",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "for key in iter {\n                let k = key.borrow().as_ref();\n                append_key_only(string, self.start_position, self.encoding, k);\n            }",
)
The code is Ok(
    "iter",
)
into Match call
is inner Match
The code is Ok(
    "iter",
)
LangItem path: form_urlencoded/src/lib.rs:324:24: 324:28 (#34)
The code is Ok(
    "iter",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "iter",
)
The code is Ok(
    "for key in iter {\n                let k = key.borrow().as_ref();\n                append_key_only(string, self.start_position, self.encoding, k);\n            }",
)
The code is Ok(
    "{\n                let k = key.borrow().as_ref();\n                append_key_only(string, self.start_position, self.encoding, k);\n            }",
)
The code is Ok(
    "key.borrow().as_ref()",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:74 ~ form_urlencoded[df2e]::{impl#6}::extend_keys_only).26),
    call_expr_span: form_urlencoded/src/lib.rs:325:25: 325:46 (#0),
    caller: Some(
        DefId(0:74 ~ form_urlencoded[df2e]::{impl#6}::extend_keys_only),
    ),
    caller_span: None,
    callee: DefId(1:3063 ~ core[f118]::convert::AsRef::as_ref),
    callee_span: form_urlencoded/src/lib.rs:325:25: 325:46 (#0),
    callee_path: "core::convert::AsRef::as_ref",
    constraint_depth: 1,
}
The code is Ok(
    "key.borrow()",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:74 ~ form_urlencoded[df2e]::{impl#6}::extend_keys_only).28),
    call_expr_span: form_urlencoded/src/lib.rs:325:25: 325:37 (#0),
    caller: Some(
        DefId(0:74 ~ form_urlencoded[df2e]::{impl#6}::extend_keys_only),
    ),
    caller_span: None,
    callee: DefId(1:2784 ~ core[f118]::borrow::Borrow::borrow),
    callee_span: form_urlencoded/src/lib.rs:325:25: 325:37 (#0),
    callee_path: "core::borrow::Borrow::borrow",
    constraint_depth: 1,
}
The code is Ok(
    "key",
)
The code is Ok(
    "append_key_only(string, self.start_position, self.encoding, k)",
)
resolved new call Call { call_expr: HirId(DefId(0:74 ~ form_urlencoded[df2e]::{impl#6}::extend_keys_only).34), call_expr_span: form_urlencoded/src/lib.rs:326:17: 326:79 (#0), caller: Some(DefId(0:74 ~ form_urlencoded[df2e]::{impl#6}::extend_keys_only)), caller_span: None, callee: DefId(0:82 ~ form_urlencoded[df2e]::append_key_only), callee_span: form_urlencoded/src/lib.rs:326:17: 326:32 (#0), callee_path: "append_key_only", constraint_depth: 1 }
The code is Ok(
    "append_key_only",
)
The code is Ok(
    "string",
)
The code is Ok(
    "self.start_position",
)
The code is Ok(
    "self",
)
The code is Ok(
    "self.encoding",
)
The code is Ok(
    "self",
)
The code is Ok(
    "k",
)
The code is Ok(
    "self",
)
The code is Ok(
    "{\n        self.target\n            .take()\n            .expect(\"url::form_urlencoded::Serializer double finish\")\n            .finish()\n    }",
)
The code is Ok(
    "self.target\n            .take()\n            .expect(\"url::form_urlencoded::Serializer double finish\")\n            .finish()",
)
new dynamic call: Call {
    call_expr: HirId(DefId(0:77 ~ form_urlencoded[df2e]::{impl#6}::finish).3),
    call_expr_span: form_urlencoded/src/lib.rs:345:9: 348:22 (#0),
    caller: Some(
        DefId(0:77 ~ form_urlencoded[df2e]::{impl#6}::finish),
    ),
    caller_span: None,
    callee: DefId(0:51 ~ form_urlencoded[df2e]::Target::finish),
    callee_span: form_urlencoded/src/lib.rs:345:9: 348:22 (#0),
    callee_path: "Target::finish",
    constraint_depth: 0,
}
The code is Ok(
    "self.target\n            .take()\n            .expect(\"url::form_urlencoded::Serializer double finish\")",
)
The code is Ok(
    "self.target\n            .take()",
)
The code is Ok(
    "self.target",
)
The code is Ok(
    "self",
)
The code is Ok(
    "\"url::form_urlencoded::Serializer double finish\"",
)
Functions:
  Function: append_separator_if_needed, Span: form_urlencoded/src/lib.rs:352:1: 356:2 (#0)
  Function: Parse::<'a>::into_owned, Span: form_urlencoded/src/lib.rs:97:5: 99:6 (#0)
  Function: Serializer::<'a, T>::clear, Span: form_urlencoded/src/lib.rs:241:5: 244:6 (#0)
  Function: Serializer::<'a, T>::for_suffix, Span: form_urlencoded/src/lib.rs:222:5: 236:6 (#0)
  Function: Serializer::<'a, T>::append_pair, Span: form_urlencoded/src/lib.rs:255:5: 264:6 (#0)
  Function: decode, Span: form_urlencoded/src/lib.rs:70:1: 76:2 (#0)
  Function: <&mut _::string::String as Target>::as_mut_string, Span: form_urlencoded/src/lib.rs:199:5: 201:6 (#0)
  Function: <_::string::String as Target>::finish, Span: form_urlencoded/src/lib.rs:192:5: 194:6 (#0)
  Function: <ByteSerialize<'a> as core::iter::Iterator>::next, Span: form_urlencoded/src/lib.rs:138:5: 163:6 (#0)
  Function: replace_plus, Span: form_urlencoded/src/lib.rs:79:1: 93:2 (#0)
  Function: append_key_only, Span: form_urlencoded/src/lib.rs:378:1: 386:2 (#0)
  Function: <ByteSerialize<'a> as core::iter::Iterator>::size_hint, Span: form_urlencoded/src/lib.rs:165:5: 171:6 (#0)
  Function: Serializer::<'a, T>::encoding_override, Span: form_urlencoded/src/lib.rs:247:5: 250:6 (#0)
  Function: <&mut _::string::String as Target>::finish, Span: form_urlencoded/src/lib.rs:202:5: 204:6 (#0)
  Function: <_::string::String as Target>::as_mut_string, Span: form_urlencoded/src/lib.rs:189:5: 191:6 (#0)
  Function: parse, Span: form_urlencoded/src/lib.rs:39:1: 41:2 (#0)
  Function: append_encoded, Span: form_urlencoded/src/lib.rs:388:1: 390:2 (#0)
  Function: Serializer::<'a, T>::append_key_only, Span: form_urlencoded/src/lib.rs:269:5: 277:6 (#0)
  Function: Serializer::<'a, T>::extend_pairs, Span: form_urlencoded/src/lib.rs:286:5: 307:6 (#0)
  Function: Serializer::<'a, T>::finish, Span: form_urlencoded/src/lib.rs:344:5: 349:6 (#0)
  Function: append_pair, Span: form_urlencoded/src/lib.rs:365:1: 376:2 (#0)
  Function: byte_serialized_unchanged, Span: form_urlencoded/src/lib.rs:131:1: 133:2 (#0)
  Function: string, Span: form_urlencoded/src/lib.rs:358:1: 363:2 (#0)
  Function: encode, Span: form_urlencoded/src/lib.rs:392:1: 397:2 (#0)
  Function: byte_serialize, Span: form_urlencoded/src/lib.rs:121:1: 123:2 (#0)
  Function: decode_utf8_lossy, Span: form_urlencoded/src/lib.rs:402:1: 428:2 (#0)
  Function: Serializer::<'a, T>::extend_keys_only, Span: form_urlencoded/src/lib.rs:316:5: 330:6 (#0)
  Function: <Parse<'a> as core::iter::Iterator>::next, Span: form_urlencoded/src/lib.rs:51:5: 67:6 (#0)
  Function: Serializer::<'a, T>::new, Span: form_urlencoded/src/lib.rs:213:5: 215:6 (#0)
  Function: <ParseIntoOwned<'_> as core::iter::Iterator>::next, Span: form_urlencoded/src/lib.rs:110:5: 114:6 (#0)

Method Declarations:
  Method Declaration: Target::as_mut_string
  Method Declaration: Target::finish

Method Implementations:
  Method Implementation for Target::finish: [DefId(0:55 ~ form_urlencoded[df2e]::{impl#4}::finish), DefId(0:59 ~ form_urlencoded[df2e]::{impl#5}::finish)]
  Method Implementation for Target::as_mut_string: [DefId(0:54 ~ form_urlencoded[df2e]::{impl#4}::as_mut_string), DefId(0:58 ~ form_urlencoded[df2e]::{impl#5}::as_mut_string)]
  Method Implementation for core::iter::Iterator::size_hint: [DefId(0:42 ~ form_urlencoded[df2e]::{impl#3}::size_hint)]
  Method Implementation for core::iter::Iterator::next: [DefId(0:19 ~ form_urlencoded[df2e]::{impl#0}::next), DefId(0:33 ~ form_urlencoded[df2e]::{impl#2}::next), DefId(0:40 ~ form_urlencoded[df2e]::{impl#3}::next)]

Static Calls:
<Parse<'a> as core::iter::Iterator>::next --- core::prelude::v1::Some (Constraint Depth: 0)
decode --- percent_encoding::percent_decode (Constraint Depth: 1)
Serializer::<'a, T>::append_key_only --- append_key_only (Constraint Depth: 0)
decode_utf8_lossy --- _::string::String::from_utf8_lossy (Constraint Depth: 1)
decode --- decode_utf8_lossy (Constraint Depth: 0)
append_encoded --- encode (Constraint Depth: 0)
decode_utf8_lossy --- _::string::String::from_utf8_unchecked (Constraint Depth: 2)
<ParseIntoOwned<'_> as core::iter::Iterator>::next --- <Parse<'a> as core::iter::Iterator>::next (Constraint Depth: 0)
decode_utf8_lossy --- _::borrow::Cow::Owned (Constraint Depth: 2)
Serializer::<'a, T>::for_suffix --- core::fmt::Arguments::new_v1 (Constraint Depth: 1)
Serializer::<'a, T>::for_suffix --- core::fmt::rt::Argument::new_display (Constraint Depth: 1)
Serializer::<'a, T>::append_pair --- string (Constraint Depth: 0)
append_pair --- append_separator_if_needed (Constraint Depth: 0)
Serializer::<'a, T>::for_suffix --- core::panicking::panic_fmt (Constraint Depth: 1)
Serializer::<'a, T>::append_pair --- append_pair (Constraint Depth: 0)
Serializer::<'a, T>::append_key_only --- string (Constraint Depth: 0)
replace_plus --- _::borrow::Cow::Owned (Constraint Depth: 1)
Serializer::<'a, T>::extend_keys_only --- append_key_only (Constraint Depth: 1)
replace_plus --- _::borrow::Cow::Borrowed (Constraint Depth: 1)
<ByteSerialize<'a> as core::iter::Iterator>::size_hint --- core::prelude::v1::Some (Constraint Depth: 1)
decode --- replace_plus (Constraint Depth: 0)
append_key_only --- append_separator_if_needed (Constraint Depth: 0)
append_key_only --- append_encoded (Constraint Depth: 0)
<ByteSerialize<'a> as core::iter::Iterator>::next --- byte_serialized_unchanged (Constraint Depth: 1)
<ByteSerialize<'a> as core::iter::Iterator>::next --- core::str::from_utf8_unchecked (Constraint Depth: 1)
Serializer::<'a, T>::extend_pairs --- string (Constraint Depth: 0)
Serializer::<'a, T>::extend_pairs --- append_pair (Constraint Depth: 1)
<Parse<'a> as core::iter::Iterator>::next --- decode (Constraint Depth: 0)
decode_utf8_lossy --- core::panicking::panic (Constraint Depth: 3)
Serializer::<'a, T>::for_suffix --- core::prelude::v1::Some (Constraint Depth: 0)
Serializer::<'a, T>::extend_keys_only --- string (Constraint Depth: 0)
Serializer::<'a, T>::clear --- string (Constraint Depth: 0)
<ByteSerialize<'a> as core::iter::Iterator>::next --- percent_encoding::percent_encode_byte (Constraint Depth: 3)
<ByteSerialize<'a> as core::iter::Iterator>::next --- core::prelude::v1::Some (Constraint Depth: 1)
append_pair --- append_encoded (Constraint Depth: 0)
append_encoded --- byte_serialize (Constraint Depth: 0)
decode --- _::borrow::Cow::Owned (Constraint Depth: 1)

Dynamic Calls:
string --- Target::as_mut_string (Constraint Depth: 0)
Serializer::<'a, T>::for_suffix --- Target::as_mut_string (Constraint Depth: 0)
Serializer::<'a, T>::extend_pairs --- core::borrow::Borrow::borrow (Constraint Depth: 1)
Serializer::<'a, T>::finish --- Target::finish (Constraint Depth: 0)
Serializer::<'a, T>::extend_keys_only --- core::convert::AsRef::as_ref (Constraint Depth: 1)
Serializer::<'a, T>::extend_pairs --- core::convert::AsRef::as_ref (Constraint Depth: 1)
Serializer::<'a, T>::extend_keys_only --- core::borrow::Borrow::borrow (Constraint Depth: 1)

Non Local Calls:
<ByteSerialize<'a> as core::iter::Iterator>::next --- <core::slice::Iter<'a, T> as core::iter::Iterator>::position (Constraint Depth: 1)
<ByteSerialize<'a> as core::iter::Iterator>::next --- core::slice::<impl [T]>::split_at (Constraint Depth: 2)
string --- core::option::Option::<T>::expect (Constraint Depth: 0)
Serializer::<'a, T>::finish --- core::option::Option::<T>::take (Constraint Depth: 0)
<Parse<'a> as core::iter::Iterator>::next --- <core::slice::SplitN<'a, T, P> as core::iter::Iterator>::next (Constraint Depth: 0)
replace_plus --- _::slice::<impl _::borrow::ToOwned for [T]>::to_owned (Constraint Depth: 1)
<ByteSerialize<'a> as core::iter::Iterator>::next --- core::slice::<impl [T]>::split_first (Constraint Depth: 0)
<ByteSerialize<'a> as core::iter::Iterator>::size_hint --- core::slice::<impl [T]>::is_empty (Constraint Depth: 0)
<Parse<'a> as core::iter::Iterator>::next --- core::slice::<impl [T]>::splitn (Constraint Depth: 0)
decode --- <T as core::convert::Into<U>>::into (Constraint Depth: 1)
append_pair --- _::string::String::push (Constraint Depth: 0)
<Parse<'a> as core::iter::Iterator>::next --- core::option::Option::<T>::unwrap_or (Constraint Depth: 0)
Serializer::<'a, T>::for_suffix --- _::string::String::len (Constraint Depth: 0)
append_separator_if_needed --- _::string::String::len (Constraint Depth: 0)
append_encoded --- <_::string::String as core::iter::Extend<&'a str>>::extend (Constraint Depth: 0)
<ParseIntoOwned<'_> as core::iter::Iterator>::next --- core::option::Option::<T>::map (Constraint Depth: 0)
<ParseIntoOwned<'_> as core::iter::Iterator>::next --- _::borrow::Cow::<'_, B>::into_owned (Constraint Depth: 0)
replace_plus --- <core::slice::Iter<'a, T> as core::iter::Iterator>::position (Constraint Depth: 1)
replace_plus --- core::slice::<impl [T]>::iter (Constraint Depth: 1)
<Parse<'a> as core::iter::Iterator>::next --- core::slice::<impl [T]>::is_empty (Constraint Depth: 0)
Serializer::<'a, T>::clear --- _::string::String::truncate (Constraint Depth: 0)
<Parse<'a> as core::iter::Iterator>::next --- core::option::Option::<T>::unwrap (Constraint Depth: 0)
decode_utf8_lossy --- core::str::<impl str>::as_bytes (Constraint Depth: 2)
encode --- core::str::<impl str>::as_bytes (Constraint Depth: 0)
append_separator_if_needed --- _::string::String::push (Constraint Depth: 1)
Serializer::<'a, T>::finish --- core::option::Option::<T>::expect (Constraint Depth: 0)
<ByteSerialize<'a> as core::iter::Iterator>::size_hint --- core::slice::<impl [T]>::len (Constraint Depth: 1)
<ByteSerialize<'a> as core::iter::Iterator>::next --- core::slice::<impl [T]>::iter (Constraint Depth: 1)
encode --- <T as core::convert::Into<U>>::into (Constraint Depth: 0)
string --- core::option::Option::<T>::as_mut (Constraint Depth: 0)
